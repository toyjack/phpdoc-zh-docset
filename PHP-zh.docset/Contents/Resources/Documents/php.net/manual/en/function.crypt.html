<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>单向字符串散列</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.crc32.html">? crc32</a></li>
      <li style="float: right;"><a href="function.echo.html">echo ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.strings.html">字符串 函数</a></li>
    <li>单向字符串散列</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.crypt" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">crypt</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">crypt</span> &mdash; <span class="dc-title">单向字符串散列</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.crypt-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>crypt</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$str</code></span>
   [, <span class="methodparam"><span class="type">string</span> <code class="parameter">$salt</code></span>
  ] )</div>

  <p class="para rdfs-comment">
   <span class="function"><strong>crypt()</strong></span> 返回一个基于标准 UNIX <abbr class="abbrev">DES</abbr> 算法或系统上其他可用的替代算法的散列字符串。
  </p>
  <p class="para">
   有些系统支持不止一种散列类型。实际上，有时候，基于 MD5 的算法被用来替代基于标准 DES 的算法。这种散列类型由盐值参数触发。在 5.3 之前，PHP 在安装时根据系统的 crypt() 决定可用的算法。如果没有提供盐值，PHP 将自动生成一个 2 个字符（DES）或者 12 个字符（MD5）的盐值 ，这取决于 MD5 crypt() 的可用性。PHP 设置了一个名为 <strong><code>CRYPT_SALT_LENGTH</code></strong> 的常量，用来表示可用散列允许的最长可用盐值。
  </p>
  <p class="para">
   基于标准 DES 算法的 <span class="function"><strong>crypt()</strong></span> 在输出内容的开始位置返回两个字符的盐值。它也只使用 <code class="parameter">str</code> 的开始 8 个字符，所以更长的以相同 8 个字符开始的字符串也将生成相同的结果（当使用了相同的盐值时）。
  </p>
  <p class="simpara">
   在 crypt() 函数支持多重散列的系统上，下面的常量根据相应的类型是否可用被设置为 0 或 1：
  </p>
  <ul class="itemizedlist">
   <li class="listitem">
    <span class="simpara">
     <strong><code>CRYPT_STD_DES</code></strong> - 基于标准 DES 算法的散列使用 &quot;./0-9A-Za-z&quot; 字符中的两个字符作为盐值。在盐值中使用非法的字符将导致 crypt() 失败。
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     <strong><code>CRYPT_EXT_DES</code></strong> - 扩展的基于 DES 算法的散列。其盐值为 9 个字符的字符串，由 1 个下划线后面跟着 4 字节循环次数和 4 字节盐值组成。它们被编码成可打印字符，每个字符 6 位，有效位最少的优先。0 到 63 被编码为 &quot;./0-9A-Za-z&quot;。在盐值中使用非法的字符将导致 crypt() 失败。
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     <strong><code>CRYPT_MD5</code></strong> - MD5 散列使用一个以 $1$ 开始的 12 字符的字符串盐值。
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     <strong><code>CRYPT_BLOWFISH</code></strong> - Blowfish 算法使用如下盐值："$2a$"，一个两位 cost 参数，"$" 以及 64 位由 "./0-9A-Za-z" 中的字符组合而成的字符串。在盐值中使用此范围之外的字符将导致 crypt() 返回一个空字符串。两位 cost 参数是循环次数以 2 为底的对数，它的范围是 04-31，超出这个范围将导致 crypt() 失败。
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     <strong><code>CRYPT_SHA256</code></strong> - SHA-256 算法使用一个以 $5$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 "rounds=&lt;N&gt;$" 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     <strong><code>CRYPT_SHA512</code></strong> - SHA-512 算法使用一个以 $6$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 "rounds=&lt;N&gt;$" 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。
    </span>
   </li>
  </ul>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    从 PHP 5.3.0 起，PHP 包含了它自己的实现，并将在系统缺乏相应算法支持的时候使用它自己的实现。
   </p>
  </p></blockquote>
 </div>

 
 <div class="refsect1 parameters" id="refsect1-function.crypt-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">str</code></dt>

     <dd>

      <p class="para">
       待散列的字符串。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">salt</code></dt>

     <dd>

      <p class="para">
       可选的盐值字符串。如果没有提供，算法行为将由不同的算法实现决定，并可能导致不可预料的结束。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>

 
 <div class="refsect1 returnvalues" id="refsect1-function.crypt-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回散列后的字符串或一个少于 13 字符的字符串，从而保证在失败时与盐值区分开来。
  </p>
 </div>

 
 <div class="refsect1 changelog" id="refsect1-function.crypt-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.3.2</td>
       <td>
        基于 Ulrich Drepper 的<a href="http://people.redhat.com/drepper/SHA-crypt.txt" class="link external" title="Link : http://people.redhat.com/drepper/SHA-crypt.txt">&raquo;&nbsp;实现</a>，新增基于 SHA-256 算法和 SHA-512 算法的 crypt。
       </td>
      </tr>

      <tr>
       <td>5.3.2</td>
       <td>
        修正了 Blowfish 算法由于非法循环导致的问题，返回"失败"字符串（"*0" 或 "*1"）而不是转而使用 DES 算法。
       </td>
      </tr>

      <tr>
       <td>5.3.0</td>
       <td>
        PHP 现在包含了它自己的 MD5 Crypt 实现，包括标准 DES 算法，扩展的 DES 算法以及 Blowfish 算法。如果系统缺乏相应的实现，那么 PHP 将使用它自己的实现。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>

 
 <div class="refsect1 examples" id="refsect1-function.crypt-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-4856">
    <p><strong>Example #1 <span class="function"><strong>crypt()</strong></span> 范例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$password&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'mypassword'</span><span style="color: #007700">);&nbsp;</span><span style="color: #FF8000">//&nbsp;自动生成盐值<br /><br />/*&nbsp;你应当使用&nbsp;crypt()&nbsp;得到的完整结果作为盐值进行密码校验，以此来避免使用不同散列算法导致的问题。（如上所述，基于标准&nbsp;DES&nbsp;算法的密码散列使用&nbsp;2&nbsp;字符盐值，但是基于&nbsp;MD5&nbsp;算法的散列使用&nbsp;12&nbsp;个字符盐值。）*/<br /></span><span style="color: #007700">if&nbsp;(</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #0000BB">$user_input</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$password</span><span style="color: #007700">)&nbsp;==&nbsp;</span><span style="color: #0000BB">$password</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">"Password&nbsp;verified!"</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
  <p class="para">
   <div class="example" id="example-4857">
    <p><strong>Example #2 利用 htpasswd 进行 <span class="function"><strong>crypt()</strong></span> 加密</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//&nbsp;设置密码<br /></span><span style="color: #0000BB">$password&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'mypassword'</span><span style="color: #007700">;<br /><br /></span><span style="color: #FF8000">//&nbsp;获取散列值，使用自动盐值<br /></span><span style="color: #0000BB">$hash&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #0000BB">$password</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
  <p class="para">
   <div class="example" id="example-4858">
    <p><strong>Example #3 以不同散列类型使用 <span class="function"><strong>crypt()</strong></span></strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">if&nbsp;(</span><span style="color: #0000BB">CRYPT_STD_DES&nbsp;</span><span style="color: #007700">==&nbsp;</span><span style="color: #0000BB">1</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">'Standard&nbsp;DES:&nbsp;'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'rasmuslerdorf'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'rl'</span><span style="color: #007700">)&nbsp;.&nbsp;</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /><br />if&nbsp;(</span><span style="color: #0000BB">CRYPT_EXT_DES&nbsp;</span><span style="color: #007700">==&nbsp;</span><span style="color: #0000BB">1</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">'Extended&nbsp;DES:&nbsp;'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'rasmuslerdorf'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'_J9..rasm'</span><span style="color: #007700">)&nbsp;.&nbsp;</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /><br />if&nbsp;(</span><span style="color: #0000BB">CRYPT_MD5&nbsp;</span><span style="color: #007700">==&nbsp;</span><span style="color: #0000BB">1</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">'MD5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'rasmuslerdorf'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'$1$rasmusle$'</span><span style="color: #007700">)&nbsp;.&nbsp;</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /><br />if&nbsp;(</span><span style="color: #0000BB">CRYPT_BLOWFISH&nbsp;</span><span style="color: #007700">==&nbsp;</span><span style="color: #0000BB">1</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">'Blowfish:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'rasmuslerdorf'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'$2a$07$usesomesillystringforsalt$'</span><span style="color: #007700">)&nbsp;.&nbsp;</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /><br />if&nbsp;(</span><span style="color: #0000BB">CRYPT_SHA256&nbsp;</span><span style="color: #007700">==&nbsp;</span><span style="color: #0000BB">1</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">'SHA-256:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'rasmuslerdorf'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'$5$rounds=5000$usesomesillystringforsalt$'</span><span style="color: #007700">)&nbsp;.&nbsp;</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /><br />if&nbsp;(</span><span style="color: #0000BB">CRYPT_SHA512&nbsp;</span><span style="color: #007700">==&nbsp;</span><span style="color: #0000BB">1</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">'SHA-512:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'rasmuslerdorf'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'$6$rounds=5000$usesomesillystringforsalt$'</span><span style="color: #007700">)&nbsp;.&nbsp;</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上例程的输出类似于：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
Standard DES: rl.3StKT.4T8M
Extended DES: _J9..rasmBYk8r9AiWNc
MD5:          $1$rasmusle$rISCgZzpwk3UhDidwXvin0
Blowfish:     $2a$07$usesomesillystringfore2uDLvp1Ii2e./U9C8sBjqp8I90dH6hi
SHA-256:      $5$rounds=5000$usesomesillystri$KqJWpanXZHKq2BOB43TSaYhEWsQ1Lr5QNyPCDH/Tp.6
SHA-512:      $6$rounds=5000$usesomesillystri$D4IrlXatmP7rx3P3InaxBeoomnAihCKRVQP22JZ6EY47Wc6BkroIuUUBOov1i.S5KPgErtP/EN5mcO.ChWQW21
</pre></div>
    </div>
   </div>
  </p>
 </div>

 
 <div class="refsect1 notes" id="refsect1-function.crypt-notes">
  <h3 class="title">注释</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <span class="simpara">
    由于 <span class="function"><strong>crypt()</strong></span> 使用的是单向算法，因此不存在 decrypt 函数。
   </span>
  </p></blockquote>
 </div>

 
 <div class="refsect1 seealso" id="refsect1-function.crypt-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.md5.html" class="function" rel="rdfs-seeAlso">md5()</a> - 计算字符串的 MD5 散列值</span></li>
    <li class="member"><a href="ref.mcrypt.html" class="link">Mcrypt</a> 扩展</li>
    <li class="member">更多关于 crypt 函数的信息，请阅读 Unix man 页面</li>
   </ul>
  </p>
 </div>

 
</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="116672""></a>
  <div class="note">
   <strong class="user">bob dot orr at mailinator dot com</strong>
   <a href="#116672" class="date">09-Feb-2015 11:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The #2 comment on this comments page (as of Feb 2015) is 9 years old and recommends phpass.&nbsp; I have independently security audited this product and, while it continues to be recommended for password security, it is actually insecure and should NOT be used.&nbsp; It hasn't seen any updates in years (still at v0.3) and there are more recent alternatives such as using the newer built-in PHP password_hash() function that are much better.&nbsp; Everyone, please take a few moments to confirm what I'm saying is accurate (i.e. review the phpass code for yourself) and then click the down arrow to sink the phpass comment to the bottom.&nbsp; You'll be increasing security across the Internet by doing so.<br />
<br />
For those who want details:&nbsp; md5() with microtime() are a fallback position within the source code of phpass.&nbsp; Instead of terminating, it continues to execute code.&nbsp; The author's intentions of trying to work everywhere are admirable but, when it comes to application security, that stance actually backfires.&nbsp; The only correct answer in a security context is to terminate the application rather than fallback to a weak position that can potentially be exploited (usually by forcing that weaker position to happen).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115866""></a>
  <div class="note">
   <strong class="user">sandeep</strong>
   <a href="#115866" class="date">06-Oct-2014 06:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Sometimes because of crypt function used in code, a user may not be able to login on a site on one server but succeeds on another server. It may be because the hash generated on the development server is using different hash type and the&nbsp; testing/production server&nbsp; hash type&nbsp; is different. PHP version also plays some role here.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115041""></a>
  <div class="note">
   <strong class="user">ian+php dot net at eiloart dot ocm</strong>
   <a href="#115041" class="date">16-May-2014 09:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you're stuck with CRYPT_EXT_DES, then you'll want to pick a number of iterations: the 2nd-5th characters of the "salt".<br />
<br />
My experimentation suggests that the 5th character is the most significant. A '.' is a zero and 'Z' is the highest value. Using all dots will create an error: all passwords will be encrypted to the same value.<br />
<br />
Here are some encryption timings (in seconds) that I obtained, with five different iteration counts over the same salt, and the same password, on a quad core 2.66GHz Intel Xeon machine.<br />
<br />
_1111 time: 0.15666794776917<br />
_J9.Z time: 1.8860530853271<br />
_J9.. time: 0.00015401840209961<br />
_...Z time: 1.9095730781555<br />
_ZZZZ time: 1.9124970436096<br />
_...A time: 0.61211705207825<br />
<br />
I think a half a second is reasonable for an application, but for the back end authentication? I'm not so sure: there's a significant risk of overloading the back end if we're getting lots of authentication requests.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114893""></a>
  <div class="note">
   <strong class="user">chris at seccosquared dot com</strong>
   <a href="#114893" class="date">22-Apr-2014 01:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A great implementation of crypt, that will generate the password and a unique salt used for it for you to easily add the data to your Database.&nbsp; It is called Encryptor and it is available on github: <br />
<br />
<a href="http://git.io/mSJqpw" rel="nofollow" target="_blank">http://git.io/mSJqpw</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114060""></a>
  <div class="note">
   <strong class="user">Marten Jacobs</strong>
   <a href="#114060" class="date">08-Jan-2014 06:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As I understand it, blowfish is generally seen a secure hashing algorithm, even for enterprise use (correct me if I'm wrong). Because of this, I created functions to create and check secure password hashes using this algorithm, and using the (also deemed cryptographically secure) openssl_random_pseudo_bytes function to generate the salt.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/*<br />
&nbsp;* Generate a secure hash for a given password. The cost is passed<br />
&nbsp;* to the blowfish algorithm. Check the PHP manual page for crypt to<br />
&nbsp;* find more information about this setting.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">generate_hash</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$cost</span><span class="keyword">=</span><span class="default">11</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/* To generate the salt, first generate enough random bytes. Because<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * base64 returns one character for each 6 bits, the we should generate<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * at least 22*6/8=16.5 bytes, so we generate 17. Then we get the first<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * 22 base64 characters<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; */<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$salt</span><span class="keyword">=</span><span class="default">substr</span><span class="keyword">(</span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">openssl_random_pseudo_bytes</span><span class="keyword">(</span><span class="default">17</span><span class="keyword">)),</span><span class="default">0</span><span class="keyword">,</span><span class="default">22</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/* As blowfish takes a salt with the alphabet ./A-Za-z0-9 we have to<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * replace any '+' in the base64 string with '.'. We don't have to do<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * anything about the '=', as this only occurs when the b64 string is<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * padded, which is always after the first 22 characters.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; */<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$salt</span><span class="keyword">=</span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">"+"</span><span class="keyword">,</span><span class="string">"."</span><span class="keyword">,</span><span class="default">$salt</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/* Next, create a string that will be passed to crypt, containing all<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * of the settings, separated by dollar signs<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; */<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$param</span><span class="keyword">=</span><span class="string">'$'</span><span class="keyword">.</span><span class="default">implode</span><span class="keyword">(</span><span class="string">'$'</span><span class="keyword">,array(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"2y"</span><span class="keyword">, </span><span class="comment">//select the most secure version of blowfish (&gt;=PHP 5.3.7)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$cost</span><span class="keyword">,</span><span class="default">2</span><span class="keyword">,</span><span class="string">"0"</span><span class="keyword">,</span><span class="default">STR_PAD_LEFT</span><span class="keyword">), </span><span class="comment">//add the cost in two digits<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$salt </span><span class="comment">//add the salt<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//now do the actual hashing<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">crypt</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">,</span><span class="default">$param</span><span class="keyword">);<br />
}<br />
&nbsp;<br />
</span><span class="comment">/*<br />
&nbsp;* Check the password against a hash generated by the generate_hash<br />
&nbsp;* function.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">validate_pw</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$hash</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/* Regenerating the with an available hash as the options parameter should<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; * produce the same hash if the same password is passed.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; */<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">crypt</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$hash</span><span class="keyword">)==</span><span class="default">$hash</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112817""></a>
  <div class="note">
   <strong class="user">mrdaniel619 at gmail dot com</strong>
   <a href="#112817" class="date">26-Jul-2013 05:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">/*<br />
nice script for creating a hash with random salt<br />
*/<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">rand_str</span><span class="keyword">(</span><span class="default">$length</span><span class="keyword">, </span><span class="default">$charset</span><span class="keyword">=</span><span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$count </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$charset</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; while (</span><span class="default">$length</span><span class="keyword">--) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">.= </span><span class="default">$charset</span><span class="keyword">[</span><span class="default">mt_rand</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">, </span><span class="default">$count</span><span class="keyword">-</span><span class="default">1</span><span class="keyword">)];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$str</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hash </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; if(isset(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'string'</span><span class="keyword">]) &amp;&amp; !empty(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'string'</span><span class="keyword">]) &amp;&amp; </span><span class="default">is_string</span><span class="keyword">(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'string'</span><span class="keyword">]))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">rand_str</span><span class="keyword">(</span><span class="default">rand</span><span class="keyword">(</span><span class="default">100</span><span class="keyword">,</span><span class="default">200</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hash </span><span class="keyword">= </span><span class="default">crypt</span><span class="keyword">(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'string'</span><span class="keyword">], </span><span class="string">'$6$rounds=9000$'</span><span class="keyword">.</span><span class="default">$salt</span><span class="keyword">.</span><span class="string">'$'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="default">?&gt;<br />
</span>&lt;!DOCTYPE html&gt;<br />
&lt;html&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;head&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;meta http-equiv="Content-Type" content="text/html; CHARSET=gb2312"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;title&gt;&lt;/title&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;/head&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;body&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;h1&gt;512 Hash&lt;/h1&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;div&gt;<span class="default">&lt;?= $hash ?&gt;</span>&lt;/div&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;form method ="post"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;table&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;tr&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;td&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;input type ="text" <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value ="<span class="default">&lt;?php </span><span class="keyword">if(</span><span class="default">$hash</span><span class="keyword">!== </span><span class="string">""</span><span class="keyword">){ echo </span><span class="default">htmlspecialchars</span><span class="keyword">(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'string'</span><span class="keyword">]); } </span><span class="default">?&gt;</span>" <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id ="string" <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name ="string" /&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;/td&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;td&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;input type ="submit" value ="hash" /&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;/td&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;/tr&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;/table&gt;&nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;/form&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;/body&gt;<br />
&lt;/html&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112035""></a>
  <div class="note">
   <strong class="user">jette at nerdgirl dot dk</strong>
   <a href="#112035" class="date">25-Apr-2013 04:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The crypt() function cant handle plus signs correctly. So if for example you are using crypt in a login function, use urlencode on the password first to make sure that the login procedure can handle any character:<br />
<br />
<span class="default">&lt;?php<br />
$user_input </span><span class="keyword">=&nbsp; </span><span class="string">'12+#?345'</span><span class="keyword">;<br />
</span><span class="default">$pass </span><span class="keyword">= </span><span class="default">urlencode</span><span class="keyword">(</span><span class="default">$user_input</span><span class="keyword">));<br />
</span><span class="default">$pass_crypt </span><span class="keyword">= </span><span class="default">crypt</span><span class="keyword">(</span><span class="default">$pass</span><span class="keyword">);<br />
<br />
if (</span><span class="default">$pass_crypt </span><span class="keyword">== </span><span class="default">crypt</span><span class="keyword">(</span><span class="default">$pass</span><span class="keyword">, </span><span class="default">$pass_crypt</span><span class="keyword">)) {<br />
&nbsp; echo </span><span class="string">"Success! Valid password"</span><span class="keyword">;<br />
} else {<br />
&nbsp; echo </span><span class="string">"Invalid password"</span><span class="keyword">;<br />
} <br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112006""></a>
  <div class="note">
   <strong class="user">mblaney at gmail dot com</strong>
   <a href="#112006" class="date">22-Apr-2013 10:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For those wondering, like I did, what the maximum length of the returned hash can be for the purpose of storing it in a database, the answer is:<br />
<br />
123 characters.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111086""></a>
  <div class="note">
   <strong class="user">steve at tobtu dot com</strong>
   <a href="#111086" class="date">13-Jan-2013 09:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To generate salt use mcrypt_create_iv() not mt_rand() because no matter how many times you call mt_rand() it will only have at most 32 bits of entropy. Which you will start seeing salt collisions after about 2^16 users. mt_rand() is seeded poorly so it should happen sooner.<br />
<br />
For bcrypt this will actually generate a 128 bit salt:<br />
<span class="default">&lt;?php $salt </span><span class="keyword">= </span><span class="default">strtr</span><span class="keyword">(</span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">mcrypt_create_iv</span><span class="keyword">(</span><span class="default">16</span><span class="keyword">, </span><span class="default">MCRYPT_DEV_URANDOM</span><span class="keyword">)), </span><span class="string">'+'</span><span class="keyword">, </span><span class="string">'.'</span><span class="keyword">); </span><span class="default">?&gt;<br />
</span><br />
*** Bike shed ***<br />
The last character in the 22 character salt is 2 bits.<br />
base64_encode() will have these four character "AQgw"<br />
bcrypt will have these four character ".Oeu"<br />
<br />
You don't need to do a full translate because they "round" to different characters:<br />
echo crypt('', '$2y$05$.....................A') . "\n";<br />
echo crypt('', '$2y$05$.....................Q') . "\n";<br />
echo crypt('', '$2y$05$.....................g') . "\n";<br />
echo crypt('', '$2y$05$.....................w') . "\n";<br />
<br />
$2y$05$......................J2ihDv8vVf7QZ9BsaRrKyqs2tkn55Yq<br />
$2y$05$.....................O/jw2XygQa2.LrIT7CFCBQowLowDP6Y.<br />
$2y$05$.....................eDOx4wMcy7WU.kE21W6nJfdMimsBE3V6<br />
$2y$05$.....................uMMcgjnOELIa6oydRivPkiMrBG8.aFp.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108704""></a>
  <div class="note">
   <strong class="user">Matteo</strong>
   <a href="#108704" class="date">19-May-2012 07:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Password hashing should be done only with crypt and NEVER with SHA* and MD5 or hash(). The fundamental reason is that crypt is designed to be SLOW which is a VERY good thing for password hashing.
<br />

<br />
It also automatically generate a salt every time which makes pre-computed tables to "decrypt" passwords useless (the generated salt is stored in the returned string for convenience).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="105949""></a>
  <div class="note">
   <strong class="user">harry at simans dot net</strong>
   <a href="#105949" class="date">27-Sep-2011 01:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I made a nice little wrapper function for crypt():
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">hasher</span><span class="keyword">(</span><span class="default">$info</span><span class="keyword">, </span><span class="default">$encdata </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">)
<br />
{
<br />
&nbsp; </span><span class="default">$strength </span><span class="keyword">= </span><span class="string">"08"</span><span class="keyword">;
<br />
&nbsp; </span><span class="comment">//if encrypted data is passed, check it against input ($info)
<br />
&nbsp; </span><span class="keyword">if (</span><span class="default">$encdata</span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$encdata</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">60</span><span class="keyword">) == </span><span class="default">crypt</span><span class="keyword">(</span><span class="default">$info</span><span class="keyword">, </span><span class="string">"$2a$"</span><span class="keyword">.</span><span class="default">$strength</span><span class="keyword">.</span><span class="string">"$"</span><span class="keyword">.</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$encdata</span><span class="keyword">, </span><span class="default">60</span><span class="keyword">))) {
<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">true</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; else {
<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp; }
<br />
&nbsp; else {
<br />
&nbsp; </span><span class="comment">//make a salt and hash it with input, and add salt to end
<br />
&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;
<br />
&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">22</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$salt </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="string">"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span><span class="keyword">, </span><span class="default">mt_rand</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">, </span><span class="default">63</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);
<br />
&nbsp; }
<br />
&nbsp; </span><span class="comment">//return 82 char string (60 char hash &amp; 22 char salt)
<br />
</span><span class="keyword">return </span><span class="default">crypt</span><span class="keyword">(</span><span class="default">$info</span><span class="keyword">, </span><span class="string">"$2a$"</span><span class="keyword">.</span><span class="default">$strength</span><span class="keyword">.</span><span class="string">"$"</span><span class="keyword">.</span><span class="default">$salt</span><span class="keyword">).</span><span class="default">$salt</span><span class="keyword">;
<br />
}
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
This wrapper will accept a string as input and hash it, and output the hash result of the string and salt together, plus the salt added on the end. You can then store that output in a db, and pass it on to the function as the 2nd parameter when you go to verify it, along with the user input or whatever as the first.
<br />

<br />
Examples:
<br />

<br />
<span class="default">&lt;?php
<br />
$hash </span><span class="keyword">= </span><span class="default">hasher</span><span class="keyword">(</span><span class="default">$userinput</span><span class="keyword">);
<br />
if (</span><span class="default">$hash </span><span class="keyword">== </span><span class="default">hasher</span><span class="keyword">(</span><span class="default">$userinput</span><span class="keyword">, </span><span class="default">$hash</span><span class="keyword">) {</span><span class="comment">//authed}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Neat huh?</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102278""></a>
  <div class="note">
   <strong class="user">kaminski at istori dot com</strong>
   <a href="#102278" class="date">06-Feb-2011 12:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is an expression to generate pseudorandom salt for the CRYPT_BLOWFISH hash type:<br />
<br />
<span class="default">&lt;?php $salt </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'+'</span><span class="keyword">, </span><span class="string">'.'</span><span class="keyword">, </span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">(</span><span class="string">'N4'</span><span class="keyword">, </span><span class="default">mt_rand</span><span class="keyword">(), </span><span class="default">mt_rand</span><span class="keyword">(), </span><span class="default">mt_rand</span><span class="keyword">(), </span><span class="default">mt_rand</span><span class="keyword">()))), </span><span class="default">0</span><span class="keyword">, </span><span class="default">22</span><span class="keyword">); </span><span class="default">?&gt;<br />
</span><br />
It is intended for use on systems where mt_getrandmax() == 2147483647.<br />
<br />
The salt created will be 128 bits in length, padded to 132 bits and then expressed in 22 base64 characters.&nbsp; (CRYPT_BLOWFISH only uses 128 bits for the salt, even though there are 132 bits in 22 base64 characters.&nbsp; If you examine the CRYPT_BLOWFISH input and output, you can see that it ignores the last four bits on input, and sets them to zero on output.)<br />
<br />
Note that the high-order bits of the four 32-bit dwords returned by mt_rand() will always be zero (since mt_getrandmax == 2^31), so only 124 of the 128 bits will be pseudorandom.&nbsp; I found that acceptable for my application.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73619""></a>
  <div class="note">
   <strong class="user">mikey_nich (at) hotmáil . com</strong>
   <a href="#73619" class="date">04-Mar-2007 04:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Are you using Apache2 on f.i. WinXP and want to create .htpasswd files via php? Then you need to use the APR1-MD5 encryption method. Here is a function for that:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">crypt_apr1_md5</span><span class="keyword">(</span><span class="default">$plainpasswd</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">str_shuffle</span><span class="keyword">(</span><span class="string">"abcdefghijklmnopqrstuvwxyz0123456789"</span><span class="keyword">), </span><span class="default">0</span><span class="keyword">, </span><span class="default">8</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$len </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$plainpasswd</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$text </span><span class="keyword">= </span><span class="default">$plainpasswd</span><span class="keyword">.</span><span class="string">'$apr1$'</span><span class="keyword">.</span><span class="default">$salt</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"H32"</span><span class="keyword">, </span><span class="default">md5</span><span class="keyword">(</span><span class="default">$plainpasswd</span><span class="keyword">.</span><span class="default">$salt</span><span class="keyword">.</span><span class="default">$plainpasswd</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt; </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">-= </span><span class="default">16</span><span class="keyword">) { </span><span class="default">$text </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">min</span><span class="keyword">(</span><span class="default">16</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)); }<br />
&nbsp;&nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt; </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt;&gt;= </span><span class="default">1</span><span class="keyword">) { </span><span class="default">$text </span><span class="keyword">.= (</span><span class="default">$i </span><span class="keyword">&amp; </span><span class="default">1</span><span class="keyword">) ? </span><span class="default">chr</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">) : </span><span class="default">$plainpasswd</span><span class="keyword">{</span><span class="default">0</span><span class="keyword">}; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"H32"</span><span class="keyword">, </span><span class="default">md5</span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">1000</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$new </span><span class="keyword">= (</span><span class="default">$i </span><span class="keyword">&amp; </span><span class="default">1</span><span class="keyword">) ? </span><span class="default">$plainpasswd </span><span class="keyword">: </span><span class="default">$bin</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$i </span><span class="keyword">% </span><span class="default">3</span><span class="keyword">) </span><span class="default">$new </span><span class="keyword">.= </span><span class="default">$salt</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$i </span><span class="keyword">% </span><span class="default">7</span><span class="keyword">) </span><span class="default">$new </span><span class="keyword">.= </span><span class="default">$plainpasswd</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$new </span><span class="keyword">.= (</span><span class="default">$i </span><span class="keyword">&amp; </span><span class="default">1</span><span class="keyword">) ? </span><span class="default">$bin </span><span class="keyword">: </span><span class="default">$plainpasswd</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"H32"</span><span class="keyword">, </span><span class="default">md5</span><span class="keyword">(</span><span class="default">$new</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">5</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$k </span><span class="keyword">= </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">6</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">12</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$j </span><span class="keyword">== </span><span class="default">16</span><span class="keyword">) </span><span class="default">$j </span><span class="keyword">= </span><span class="default">5</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">$bin</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">].</span><span class="default">$bin</span><span class="keyword">[</span><span class="default">$k</span><span class="keyword">].</span><span class="default">$bin</span><span class="keyword">[</span><span class="default">$j</span><span class="keyword">].</span><span class="default">$tmp</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">chr</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">).</span><span class="default">chr</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">).</span><span class="default">$bin</span><span class="keyword">[</span><span class="default">11</span><span class="keyword">].</span><span class="default">$tmp</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">strtr</span><span class="keyword">(</span><span class="default">strrev</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">$tmp</span><span class="keyword">), </span><span class="default">2</span><span class="keyword">)),<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; return </span><span class="string">"$"</span><span class="keyword">.</span><span class="string">"apr1"</span><span class="keyword">.</span><span class="string">"$"</span><span class="keyword">.</span><span class="default">$salt</span><span class="keyword">.</span><span class="string">"$"</span><span class="keyword">.</span><span class="default">$tmp</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60056""></a>
  <div class="note">
   <strong class="user">solar at openwall dot com</strong>
   <a href="#60056" class="date">24-Dec-2005 08:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
With different password hashing methods supported on different systems and with the need to generate salts with your own PHP code in order to use the more advanced / more secure methods, it takes special knowledge to use crypt() optimally, producing strong password hashes.&nbsp; Other message digest / hashing functions supported by PHP, such as md5() and sha1(), are really no good for password hashing if used naively, resulting in hashes which may be brute-forced at rates much higher than those possible for hashes produced by crypt().<br />
<br />
I have implemented a PHP password hashing framework (in PHP, tested with all of PHP 3, 4, and 5) which hides the complexity from your PHP applications (no need for you to worry about salts, etc.), yet does things in almost the best way possible given the constraints of the available functions.&nbsp; The homepage for the framework is:<br />
<br />
<a href="http://www.openwall.com/phpass/" rel="nofollow" target="_blank">http://www.openwall.com/phpass/</a><br />
<br />
I have placed this code in the public domain, so there are no copyrights or licensing restrictions to worry about.<br />
<br />
P.S. I have 10 years of experience in password (in)security and I've developed several other password security tools and libraries.&nbsp; So most people can feel confident they're getting this done better by using my framework than they could have done it on their own.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58805""></a>
  <div class="note">
   <strong class="user">hotdog (at) gmx (dot) net</strong>
   <a href="#58805" class="date">16-Nov-2005 04:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
WRONG:<br />
<br />
$mypassword = "toto";<br />
$smd5_pass = "{SMD5}......." // in openldap<br />
<br />
if (preg_match ("/{SMD5}/i", $smd5_pass))<br />
&nbsp;{<br />
&nbsp; $encrypted = substr($md5_pass, 6);<br />
&nbsp; $hash = base64_decode($encrypted);<br />
&nbsp; $salt = substr($hash,16);<br />
&nbsp; $mhashed =&nbsp; mhash(MHASH_MD5, $mypassword . $salt) ;<br />
&nbsp; $without_salt = explode($salt,$hash_hex);<br />
&nbsp;&nbsp; if ($without_salt[0] == $mhashed) {<br />
&nbsp;&nbsp;&nbsp; echo "Password verified &lt;br&gt;";<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp;&nbsp; echo "Password Not verified&lt;br&gt;";<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;}<br />
<br />
$without_salt = explode($salt,$hash_hex); should be $without_salt = explode($salt,$hash); <br />
<br />
RIGHT:<br />
<br />
$mypassword = "toto";<br />
$smd5_pass = "{SMD5}......." // in openldap<br />
<br />
if (preg_match ("/{SMD5}/i", $smd5_pass))<br />
&nbsp;{<br />
&nbsp; $encrypted = substr($md5_pass, 6);<br />
&nbsp; $hash = base64_decode($encrypted);<br />
&nbsp; $salt = substr($hash,16);<br />
&nbsp; $mhashed =&nbsp; mhash(MHASH_MD5, $mypassword . $salt) ;<br />
&nbsp; $without_salt = explode($salt,$hash);<br />
&nbsp;&nbsp; if ($without_salt[0] == $mhashed) {<br />
&nbsp;&nbsp;&nbsp; echo "Password verified &lt;br&gt;";<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp;&nbsp; echo "Password Not verified&lt;br&gt;";<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45350""></a>
  <div class="note">
   <strong class="user">thorhajo at gmail dot com</strong>
   <a href="#45350" class="date">03-Sep-2004 12:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a little function I wrote to generate MD5 password hashes in the format they're found in /etc/shadow:<br />
<br />
function shadow($password)<br />
{<br />
&nbsp; $hash = '';<br />
&nbsp; for($i=0;$i&lt;8;$i++)<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; $j = mt_rand(0,53);<br />
&nbsp;&nbsp;&nbsp; if($j&lt;26)$hash .= chr(rand(65,90));<br />
&nbsp;&nbsp;&nbsp; else if($j&lt;52)$hash .= chr(rand(97,122));<br />
&nbsp;&nbsp;&nbsp; else if($j&lt;53)$hash .= '.';<br />
&nbsp;&nbsp;&nbsp; else $hash .= '/';<br />
&nbsp; }<br />
&nbsp; return crypt($password,'$1$'.$hash.'$');<br />
}<br />
<br />
I've written this so that each character in the a-zA-Z./ set has a 1/54 of a chance of being selected (26 + 26 + 2 = 54), thus being statistically even.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
