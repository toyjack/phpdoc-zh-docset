<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>加密数据</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.mcrypt-generic-init.html">? mcrypt_generic_init</a></li>
      <li style="float: right;"><a href="function.mcrypt-get-block-size.html">mcrypt_get_block_size ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.mcrypt.html">Mcrypt 函数</a></li>
    <li>加密数据</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.mcrypt-generic" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">mcrypt_generic</h1>
  <p class="verinfo">(PHP 4 &gt;= 4.0.2, PHP 5)</p><p class="refpurpose"><span class="refname">mcrypt_generic</span> &mdash; <span class="dc-title">加密数据</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.mcrypt-generic-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>mcrypt_generic</strong></span>
    ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$td</code></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$data</code></span>
   )</div>

  <p class="para rdfs-comment">
    本函数用来加密数据。
    传入数据长度必须是 n * 分组大小，否则需要后补 &quot;<em>\0</em>&quot;。
    本函数返回加密后的数据。
    注意，根据数据补齐不同，
    返回的数据可能比输入的数据长度有所增加。
  </p>
  <p class="para">
    如果你需要把加密后的数据保存到数据库，
    请确保保存 mcrypt_generic 返回的完整的字符串，
    否则将无法正确解密。
    如果原始数据有 10 个字符，分组大小为 8 
    （使用 <span class="function"><a href="function.mcrypt-enc-get-block-size.html" class="function">mcrypt_enc_get_block_size()</a></span> 获取分组大小），
    则数据库中至少需要 16 个字符来保存数据。
    请注意 <span class="function"><a href="function.mdecrypt-generic.html" class="function">mdecrypt_generic()</a></span> 函数返回的数据也会是 16 个字符。
    使用 rtrim($str, &quot;\0&quot;) 移除字符串末尾的 0 。
  </p>
  <p class="para">
    如果你在例如 MySQL 这样的数据库中存储数据，
    请注意 varchar 类型的字段会在插入数据时自动移除字符串末尾的"空格"。
    由于加密后的数据可能是以空格（ASCII 32）结尾，
    这种特性会导致数据损坏。
    请使用 tinyblob/tinytext（或 larger）字段来存储加密数据。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.mcrypt-generic-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">td</code></dt>

     <dd>

      <p class="para">
       加密描述符。
      </p>
      <p class="para">
        在调用本函数之前，
        请使用 <span class="function"><a href="function.mcrypt-generic-init.html" class="function">mcrypt_generic_init()</a></span> 函数初始化加密句柄。
        在加密完成之后，
        需要调用 <span class="function"><a href="function.mcrypt-generic-deinit.html" class="function">mcrypt_generic_deinit()</a></span> 函数进行必要的清理工作。
        请参见 <span class="function"><a href="function.mcrypt-module-open.html" class="function">mcrypt_module_open()</a></span> 。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">data</code></dt>

     <dd>

      <p class="para">
       要加密的数据。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.mcrypt-generic-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回加密后的数据。
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.mcrypt-generic-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.mdecrypt-generic.html" class="function" rel="rdfs-seeAlso">mdecrypt_generic()</a> - 解密数据</span></li>
    <li class="member"><span class="function"><a href="function.mcrypt-generic-init.html" class="function" rel="rdfs-seeAlso">mcrypt_generic_init()</a> - 初始化加密所需的缓冲区</span></li>
    <li class="member"><span class="function"><a href="function.mcrypt-generic-deinit.html" class="function" rel="rdfs-seeAlso">mcrypt_generic_deinit()</a> - 对加密模块进行清理工作</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="77133""></a>
  <div class="note">
   <strong class="user">maxximus007 at gmail dot com</strong>
   <a href="#77133" class="date">16-Aug-2007 05:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Behaviour change: Since 5.2.x mcrypt_generic will issue a warning when the datastring is empty.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71135""></a>
  <div class="note">
   <strong class="user">tmacedo at linux dot ime dot usp dot br</strong>
   <a href="#71135" class="date">13-Nov-2006 06:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
completing&nbsp; the post from Ryan Thomas, ryanrst at gmail dot com, if u post a cookie w/ HTTP method, its may be encoded;<br />
As some chars in base64 will be encoded to another things, u can just replace them before encode and after decode;<br />
Its a tweak from dawgeatschikin at hotmail dot com to original idea from massimo dot scamarcia at gmail dot com<br />
(see @ <a href="http://www.php.net/manual/en/function.base64-encode.php" rel="nofollow" target="_blank">http://www.php.net/manual/en/function.base64-encode.php</a>):<br />
<span class="default">&lt;?php <br />
</span><span class="keyword">function </span><span class="default">urlsafe_b64encode</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">)<br />
{<br />
&nbsp; </span><span class="default">$data </span><span class="keyword">= </span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">);<br />
&nbsp; </span><span class="default">$data </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'+'</span><span class="keyword">,</span><span class="string">'/'</span><span class="keyword">,</span><span class="string">'='</span><span class="keyword">),array(</span><span class="string">'-'</span><span class="keyword">,</span><span class="string">'_'</span><span class="keyword">,</span><span class="string">'.'</span><span class="keyword">),</span><span class="default">$data</span><span class="keyword">);<br />
&nbsp; return </span><span class="default">$data</span><span class="keyword">;<br />
}<br />
function </span><span class="default">urlsafe_b64decode</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">)<br />
{<br />
&nbsp; </span><span class="default">$data </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'-'</span><span class="keyword">,</span><span class="string">'_'</span><span class="keyword">,</span><span class="string">'.'</span><span class="keyword">),array(</span><span class="string">'+'</span><span class="keyword">,</span><span class="string">'/'</span><span class="keyword">,</span><span class="string">'='</span><span class="keyword">),</span><span class="default">$string</span><span class="keyword">);<br />
&nbsp; </span><span class="default">$mod4 </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">) % </span><span class="default">4</span><span class="keyword">;<br />
&nbsp; if (</span><span class="default">$mod4</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$data </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="string">'===='</span><span class="keyword">, </span><span class="default">$mod4</span><span class="keyword">);<br />
&nbsp; }<br />
&nbsp; return </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68085""></a>
  <div class="note">
   <strong class="user">chad 0x40 herballure 0x2e com</strong>
   <a href="#68085" class="date">12-Jul-2006 05:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Addendum to my previous note: apparently there was some sort of character encoding breakage; PHP does not pad if no padding is needed, and the extra padding I saw was the result of chr(X) returning multiple bytes or something.<br />
<br />
The pad/unpad functions I gave are still binary-safe, though, and are to the best of my knowledge completely compatible with NIST 800-38a.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68082""></a>
  <div class="note">
   <strong class="user">chad 0x40 herballure 0x2e com</strong>
   <a href="#68082" class="date">12-Jul-2006 04:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If the data is already n*blocksize long, PHP pads with another full block of "\0", so there will be between 1 and mcrypt_enc_get_block_size($td) bytes of padding.<br />
<br />
You can create binary-safe padding by unconditionally adding a 0x80 to the string, then stripping trailing "\0"s PHP added, plus the one 0x80 byte.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">pad</span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">) {<br />
&nbsp; </span><span class="comment">// Add a single 0x80 byte and let PHP pad with 0x00 bytes.<br />
&nbsp; </span><span class="keyword">return </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"a*H2"</span><span class="keyword">, </span><span class="default">$text</span><span class="keyword">, </span><span class="string">"80"</span><span class="keyword">);<br />
}<br />
function </span><span class="default">unpad</span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">) {<br />
&nbsp; </span><span class="comment">// Return all but the trailing 0x80 from text that had the 0x00 bytes removed<br />
&nbsp; </span><span class="keyword">return </span><span class="default">substr</span><span class="keyword">(</span><span class="default">rtrim</span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">), </span><span class="default">0</span><span class="keyword">, -</span><span class="default">1</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="62876""></a>
  <div class="note">
   <strong class="user">eric at ez-llc dot com</strong>
   <a href="#62876" class="date">11-Mar-2006 09:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was able get php and perl to play together with blowfish using cipher block chaining.&nbsp; The blowfish key needs to be atleast 8 chars (even though blowfish min is 8 bits, perl didn't like keys smaller than 8 chars) and max 56.&nbsp; The iv must be exactly 8 chars and padding needs to be null because php pads with nulls.&nbsp; Also, php needs libmcrypt &gt;= 2.4.9 to be compatible with perl.<br />
<br />
PERL<br />
----<br />
<br />
use Crypt::CBC;<br />
$cipher = Crypt::CBC-&gt;new( {'key' =&gt; 'my secret key',<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 'cipher'=&gt; 'Blowfish',<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 'iv' =&gt; '12345678',<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 'regenerate_key' =&gt; 0,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 'padding' =&gt; 'null',<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 'prepend_iv' =&gt; 0<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; });<br />
$cc = 'my secret text';<br />
$encrypted = $cipher-&gt;encrypt($cc);<br />
$decrypted = $cipher-&gt;decrypt($encrypted);<br />
<br />
print "encrypted : ".$encrypted;<br />
print "&lt;br&gt;";<br />
print "decrypted : ".$decrypted;<br />
<br />
PHP<br />
---<br />
<br />
$cc = 'my secret text';<br />
$key = 'my secret key';<br />
$iv = '12345678';<br />
<br />
$cipher = mcrypt_module_open(MCRYPT_BLOWFISH,'','cbc','');<br />
<br />
mcrypt_generic_init($cipher, $key, $iv);<br />
$encrypted = mcrypt_generic($cipher,$cc);<br />
mcrypt_generic_deinit($cipher);<br />
<br />
mcrypt_generic_init($cipher, $key, $iv);<br />
$decrypted = mdecrypt_generic($cipher,$encrypted);<br />
mcrypt_generic_deinit($cipher);<br />
<br />
echo "encrypted : ".$encrypted;<br />
echo "&lt;br&gt;";<br />
echo "decrypted : ".$decrypted;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60378""></a>
  <div class="note">
   <strong class="user">Ryan Thomas, ryanrst at gmail dot com</strong>
   <a href="#60378" class="date">05-Jan-2006 11:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you wish to store encrypted data in a cookie variable on the browser you will encounter problems when decrypting the data. This is because cookies will only store US-ASCII characters and your encrypted data may contain non-US-ASCII characters.<br />
<br />
The solution: <br />
<br />
base64_encode your encrypted string before you store it in the cookie and base64_decode the string stored in the cookie becore decrypting.<br />
<br />
Example:<br />
<br />
function setEncryptedCookie($cookieName, $data)<br />
{<br />
&nbsp; setcookie($cookieName, base64_encode($this-&gt;encrypt($data)), time()+$this-&gt;expire);&nbsp; <br />
}<br />
<br />
function getEncryptedCookie($cookieName)<br />
{<br />
&nbsp; return $this-&gt;decrypt(base64_decode($_COOKIE[$cookieName]));<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="32074""></a>
  <div class="note">
   <strong class="user">pauls at sellingsource dot com</strong>
   <a href="#32074" class="date">15-May-2003 08:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are encrypting binary and there is a null terminator partway through your encryption, you will loose the rest of the string.&nbsp; A workaround is to base64_encode your binary string first.<br />
<br />
We found this problem while trying to encrypt CC information.&nbsp; Some CC values would not decrypt after we converted them to a binary string.<br />
<br />
We were using the MCRYPT_RIJNDAEL_256 module to encrypt with.<br />
<br />
Hope this helps someone.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
