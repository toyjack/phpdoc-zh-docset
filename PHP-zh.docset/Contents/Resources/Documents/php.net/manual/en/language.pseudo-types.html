<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>本文档中使用的伪类型与变量</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.types.callable.html">? Callback 回调类型</a></li>
      <li style="float: right;"><a href="language.types.type-juggling.html">类型转换的判别 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="language.types.html">类型</a></li>
    <li>本文档中使用的伪类型与变量</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.pseudo-types" class="sect1">
 <h2 class="title">本文档中使用的伪类型与变量</h2> 

 <div class="sect2" id="language.types.mixed">
  <h3 class="title">mixed</h3>

  <p class="para">
   <em>mixed</em> 说明一个参数可以接受多种不同的（但不一定是所有的）类型。
  </p>

  <p class="para">
   例如 <span class="function"><a href="function.gettype.html" class="function">gettype()</a></span> 可以接受所有的 PHP 类型，<span class="function"><a href="function.str-replace.html" class="function">str_replace()</a></span> 可以接受字符串和数组。
  </p>

 </div>

 <div class="sect2" id="language.types.number">
  <h3 class="title">number</h3>

  <p class="para">
   <em>number</em> 说明一个参数可以是 <span class="type"><a href="language.types.integer.html" class="type integer">integer</a></span> 或者 <span class="type"><a href="language.types.float.html" class="type float">float</a></span>。
  </p>

 </div>

 <div class="sect2" id="language.types.callback">
  <h3 class="title">callback</h3>

  <p class="para">
   本文档中在 PHP 5.4 引入 <span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span> 类型之前使用
   了 <span class="type"><a href="language.pseudo-types.html#language.types.callback" class="type callback">callback</a></span> 伪类型。二者含义完全相同。
  </p>

 </div>
 
 <div class="sect2" id="language.types.void">
  <h3 class="title">void</h3>

  <p class="para">
   <em>void</em> 作为返回类型意味着函数的返回值是无用的。<em>void</em>
   作为参数列表意味着函数不接受任何参数。
  </p>

 </div>

 <div class="sect2" id="language.types.dotdotdot">
  <h3 class="title">...</h3>

  <p class="para">
   在函数原型中，<code class="parameter">$...</code> 表示<em>等等</em>的意思。当一个函数可以接受任意个参数时使用此变量名。
  </p>

 </div>
</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="118645""></a>
  <div class="note">
   <strong class="user">gried at NOSPAM dot nsys dot by</strong>
   <a href="#118645" class="date">15-Jan-2016 06:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In response to phpguy at lifetoward dot com.<br />
<br />
I tested on PHP 5.5.9 and found that his claims are outdated.<br />
Code below can be used to check it.<br />
<br />
PS: It's probably best to downvote that comment, so people who are new to PHP won't be misinformed.<br />
<br />
<span class="default">&lt;?php<br />
error_reporting</span><span class="keyword">(</span><span class="default">E_ALL</span><span class="keyword">);<br />
<br />
</span><span class="default">$test </span><span class="keyword">= [</span><span class="default">2</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">, </span><span class="default">5</span><span class="keyword">, </span><span class="default">6</span><span class="keyword">, </span><span class="default">3</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">];<br />
echo </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$test</span><span class="keyword">).</span><span class="string">'&lt;hr&gt;'</span><span class="keyword">;<br />
<br />
</span><span class="default">$reverse </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
</span><span class="default">usort</span><span class="keyword">(</span><span class="default">$test</span><span class="keyword">, (</span><span class="default">$reverse</span><span class="keyword">?</span><span class="string">'sortRev'</span><span class="keyword">:</span><span class="string">'sortForw'</span><span class="keyword">) );<br />
echo </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$test</span><span class="keyword">).</span><span class="string">'&lt;hr&gt;'</span><span class="keyword">;<br />
<br />
function </span><span class="default">sortForw</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">) {<br />
&nbsp; return </span><span class="default">$a </span><span class="keyword">- </span><span class="default">$b</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">sortRev</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">) {<br />
&nbsp; return </span><span class="default">$b </span><span class="keyword">- </span><span class="default">$a</span><span class="keyword">;<br />
}</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109705""></a>
  <div class="note">
   <strong class="user">mike@EastGhostCom</strong>
   <a href="#109705" class="date">13-Aug-2012 02:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you pass a string as the callback function (i.e., 2nd parm to preg_replace_callback()), then PHP will interpret it as a function's name in the current scope -- and Main::dada_cb is not a valid function name in any scope.<br />
<br />
If you want to specify a static method of a class as the callback (i.e., "Main::dada_cb"), then you must pass as 2nd parm to preg_replace_callback:<br />
<br />
array( 'Main', 'dada_cb')<br />
<br />
And, if you want to use as a callback some method of an instantiated object (i.e., $object-&gt;dada_cb), then you must pass as the 2nd parm to preg_replace_callback:<br />
<br />
array( $object, 'dada_cb' )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101268""></a>
  <div class="note">
   <strong class="user">liam at helios-sites dot com</strong>
   <a href="#101268" class="date">06-Dec-2010 01:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that (e.g.) usort calls on static methods of classes in a namespace need to be laid out as follows:<br />
<br />
usort($arr, array('\Namespace\ClassName', 'functionName'));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93234""></a>
  <div class="note">
   <strong class="user">michael dot martinek at gmail dot com</strong>
   <a href="#93234" class="date">29-Aug-2009 06:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The documentation is a little confusing, and with the recent OO changes it adds a little more to the confusion.<br />
<br />
I was curious whether you could pass an object through the user func, modify it in that callback and have the actual object updated or whether some cloning was going on behind the scenes.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">Test<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var </span><span class="default">$sValue </span><span class="keyword">= </span><span class="string">'abc'</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function </span><span class="default">testing</span><span class="keyword">(</span><span class="default">$objTest</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$objTest</span><span class="keyword">-&gt;</span><span class="default">sValue </span><span class="keyword">= </span><span class="string">'123'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Test</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">call_user_func</span><span class="keyword">(array(</span><span class="default">$obj</span><span class="keyword">, </span><span class="string">'testing'</span><span class="keyword">), </span><span class="default">$obj</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$obj</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
This works as expected: The object is not cloned, and $sValue is properly set to '123'. With the OO changes in PHP 5, you don't need to do "function testing(&amp;$objTest)" as it is already passed by reference.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91482""></a>
  <div class="note">
   <strong class="user">phpguy at lifetoward dot com</strong>
   <a href="#91482" class="date">12-Jun-2009 02:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I noticed two important thing about putting callbacks into an arg list when calling a function:<br />
<br />
1. The function to which the callback refers must be defined earlier in the source stream. So for example:<br />
<br />
function main() {...; usort($array, 'sortfunction'); ... }<br />
function sortfunction($a, $b){ return 0; }<br />
<br />
Will NOT work, but this will:<br />
<br />
function sortfunction($a, $b){ return 0; }<br />
function main() {...; usort($array, 'sortfunction'); ... }<br />
<br />
2. It's not really just a string. For example, this doesn't work:<br />
<br />
usort($array, ($reverse?'reversesorter':'forwardsorter'));<br />
<br />
I found these two discoveries quite counterintuitive.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90397""></a>
  <div class="note">
   <strong class="user">sahid dot ferdjaoui at gmail dot com</strong>
   <a href="#90397" class="date">20-Apr-2009 12:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
An example with PHP 5.3 and lambda functions<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp; array_map </span><span class="keyword">(function (</span><span class="default">$value</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return new </span><span class="default">MyFormElement </span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">);<br />
&nbsp; }, </span><span class="default">$_POST</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75329""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#75329" class="date">24-May-2007 07:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The mixed pseudotype is explained as meaning "multiple but not necessarily all" types, and the example of str_replace(mixed, mixed, mixed) is given where "mixed" means "string or array".<br />
Keep in mind that this refers to the types of the function's arguments _after_ any type juggling.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73104""></a>
  <div class="note">
   <strong class="user">levi at alliancesoftware dot com dot au</strong>
   <a href="#73104" class="date">08-Feb-2007 11:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Parent methods for callbacks should be called 'parent::method', so if you wish to call a non-static parent method via a callback, you should use a callback of<br />
&lt;?<br />
&nbsp;// always works<br />
&nbsp;$callback = array($this, 'parent::method') <br />
<br />
&nbsp;// works but gives an error in PHP5 with E_STRICT if the parent method is not static<br />
&nbsp;$callback array('parent', 'method'); <br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72778""></a>
  <div class="note">
   <strong class="user">Edward</strong>
   <a href="#72778" class="date">01-Feb-2007 11:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To recap mr dot lilov at gmail dot com's comment: If you want to pass a function as an argument to another function, for example "array_map", do this:<br />
<br />
regular functions: <br />
&lt;? <br />
array_map(intval, $array)<br />
?&gt;<br />
<br />
static functions in a class:<br />
&lt;?<br />
array_map(array('MyClass', 'MyFunction'), $array)<br />
?&gt;<br />
<br />
functions from an object:<br />
&lt;?<br />
array_map(array($this, 'MyFunction'), $array)<br />
?&gt;<br />
<br />
I hope this clarifies things a little bit</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
