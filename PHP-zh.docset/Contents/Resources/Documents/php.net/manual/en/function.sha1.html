<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>计算字符串的 sha1 散列值</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.sha1-file.html">? sha1_file</a></li>
      <li style="float: right;"><a href="function.similar-text.html">similar_text ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.strings.html">字符串 函数</a></li>
    <li>计算字符串的 sha1 散列值</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.sha1" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">sha1</h1>
  <p class="verinfo">(PHP 4 &gt;= 4.3.0, PHP 5, PHP 7)</p><p class="refpurpose"><span class="refname">sha1</span> &mdash; <span class="dc-title">计算字符串的 sha1 散列值</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.sha1-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>sha1</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$str</code></span>
   [, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$raw_output</code><span class="initializer"> = false</span></span>
  ] )</div>

  <p class="simpara">
   利用<a href="http://www.faqs.org/rfcs/rfc3174" class="link external" title="Link : http://www.faqs.org/rfcs/rfc3174">&raquo;&nbsp;美国安全散列算法 1</a> 计算字符串的 sha1 散列值。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.sha1-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">str</code></dt>

     <dd>

      <p class="para">
       输入字符串。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">raw_output</code></dt>

     <dd>

      <p class="para">
       如果可选的 <code class="parameter">raw_output</code> 参数被设置为 <strong><code>TRUE</code></strong>，那么 sha1 摘要将以 20 字符长度的原始格式返回，否则返回值是一个 40 字符长度的十六进制数字。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.sha1-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回 sha1 散列值字符串。
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.sha1-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.0.0</td>
       <td>
        新增 <code class="parameter">raw_output</code> 参数。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.sha1-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-5269">
    <p><strong>Example #1 <span class="function"><strong>sha1()</strong></span> 范例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$str&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'apple'</span><span style="color: #007700">;<br /><br />if&nbsp;(</span><span style="color: #0000BB">sha1</span><span style="color: #007700">(</span><span style="color: #0000BB">$str</span><span style="color: #007700">)&nbsp;===&nbsp;</span><span style="color: #DD0000">'d0be2dc421be4fcd0172e5afceea3970e2f3d940'</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">"Would&nbsp;you&nbsp;like&nbsp;a&nbsp;green&nbsp;or&nbsp;red&nbsp;apple?"</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.sha1-notes">
  <h3 class="title">注释</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
<strong>Secure password hashing</strong><br />
<p class="para">
 由于此函数依赖的算法已不足够复杂,不推荐使用此函数对明文密码加密。详细内容参见<a href="faq.passwords.html#faq.passwords.fasthash" class="link">这里</a>。
</p>
</p></blockquote>

 </div>


 <div class="refsect1 seealso" id="refsect1-function.sha1-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.sha1-file.html" class="function" rel="rdfs-seeAlso">sha1_file()</a> - 计算文件的 sha1 散列值</span></li>
    <li class="member"><span class="function"><a href="function.crc32.html" class="function" rel="rdfs-seeAlso">crc32()</a> - 计算一个字符串的 crc32 多项式</span></li>
    <li class="member"><span class="function"><a href="function.md5.html" class="function" rel="rdfs-seeAlso">md5()</a> - 计算字符串的 MD5 散列值</span></li>
    <li class="member"><span class="function"><a href="function.hash.html" class="function" rel="rdfs-seeAlso">hash()</a> - 生成哈希值 （消息摘要）</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="118770""></a>
  <div class="note">
   <strong class="user">jcastromail at yahoo dot es</strong>
   <a href="#118770" class="date">03-Feb-2016 05:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi there:<br />
<br />
About the complexity of sha1, sha1 generates a code a different code each 1,4615016373309029182036848327163e+48 (2 ^ 160 bits).&nbsp; So the chances of the use of the same hash is really small.<br />
<br />
The "problem" of sha1 (and md5) is the speed of the generation. However, the speed is proportional with the length of the text to encrypt. <br />
<br />
However, using a SALT, it increases tenfold times the security, even for a weak password.<br />
<br />
In gross terms, a password of 6 characters can be hacked in a minute (if its store in md5 or sha).&nbsp;&nbsp; However, a password of 7 characters takes an hour, a password of 8 a year and a password of more than 8 character is virtually inviable of hack.<br />
<br />
However, if we used an SALT (a secret salt btw), then even a password of 3 characters will be really safe.<br />
<br />
sha1('SALT SECRET TEXT!!@@@aaa0000'.'123');<br />
<br />
And a double sha1 will ensure more safety <br />
<br />
sha1(sha1('SALT SECRET TEXT'.'123',false),false)<br />
<br />
It will require a rainbow table of 20 characters, enough big to be absurdly safe even for a thousand of servers running during a year.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="116387""></a>
  <div class="note">
   <strong class="user">Mohit Mishra</strong>
   <a href="#116387" class="date">26-Dec-2014 03:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A combination of md5() and sha1() could be used for creating more secured hash strings. Here is a function which exactly does this download it from <a href="http://Webgrape.in/download.php?fileid=10 ." rel="nofollow" target="_blank">http://Webgrape.in/download.php?fileid=10 .</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112844""></a>
  <div class="note">
   <strong class="user">marcin at marcinwolny dot net</strong>
   <a href="#112844" class="date">30-Jul-2013 12:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Keep in mind that MD5 is less secure than SHA1.<br />
Older CPUs can calculate MD5 over twice as fast as SHA1. GPUs in parallel calculations can handle MD5 over 3 times as fast as SHA1!<br />
<br />
Two Radeon 79xx-series GPUs can calculate a rainbow table for 6-character lowercase MD5 password in... roughly 6 seconds!<br />
<br />
Source: <a href="http://www.codinghorror.com/blog/2012/04/speed-hashing.html" rel="nofollow" target="_blank">http://www.codinghorror.com/blog/2012/04/speed-hashing.html</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109602""></a>
  <div class="note">
   <strong class="user">php at wbhostmax dot de</strong>
   <a href="#109602" class="date">01-Aug-2012 07:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">DoubleSaltedHash</span><span class="keyword">(</span><span class="default">$pw</span><span class="keyword">, </span><span class="default">$salt</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">.</span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">.</span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$pw</span><span class="keyword">)));<br />
}<br />
<br />
function </span><span class="default">generate_salt</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$dummy </span><span class="keyword">= </span><span class="default">array_merge</span><span class="keyword">(</span><span class="default">range</span><span class="keyword">(</span><span class="string">'0'</span><span class="keyword">, </span><span class="string">'9'</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">mt_srand</span><span class="keyword">((double)</span><span class="default">microtime</span><span class="keyword">()*</span><span class="default">1000000</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt;= (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$dummy</span><span class="keyword">)*</span><span class="default">2</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$swap </span><span class="keyword">= </span><span class="default">mt_rand</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">,</span><span class="default">count</span><span class="keyword">(</span><span class="default">$dummy</span><span class="keyword">)-</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">$dummy</span><span class="keyword">[</span><span class="default">$swap</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$dummy</span><span class="keyword">[</span><span class="default">$swap</span><span class="keyword">] = </span><span class="default">$dummy</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$dummy</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">] = </span><span class="default">$tmp</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">implode</span><span class="keyword">(</span><span class="string">''</span><span class="keyword">,</span><span class="default">$dummy</span><span class="keyword">),</span><span class="default">0</span><span class="keyword">,</span><span class="default">9</span><span class="keyword">));<br />
}<br />
</span><span class="default">$pw</span><span class="keyword">=</span><span class="string">"geheim"<br />
</span><span class="default">$salt</span><span class="keyword">=</span><span class="default">generate_salt</span><span class="keyword">();<br />
echo </span><span class="string">"hash:"</span><span class="keyword">.</span><span class="default">DoubleSaltedHash</span><span class="keyword">(</span><span class="default">$pw</span><span class="keyword">, </span><span class="default">$salt</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
this is my way to crypt passwords</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103024""></a>
  <div class="note">
   <strong class="user">mgcummings at yahoo dot com</strong>
   <a href="#103024" class="date">21-Mar-2011 09:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Thought I might save someone else some time trying to figure out how to generate a hash like MySQL5 PASSWORD() makes using just PHP.<br />
<br />
$hash = '*' . sha1(sha1($pass), TRUE));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101087""></a>
  <div class="note">
   <strong class="user">rich dot sage at gmail dot com</strong>
   <a href="#101087" class="date">25-Nov-2010 09:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you're using Dovecot for mail retrieval and you want to generate SHA1 passwords yourself, you'll need to set the raw_output value to true, then base64_encode the output:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">makeDovecotPassword</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">)<br />
{<br />
&nbsp; return </span><span class="string">'{SHA}' </span><span class="keyword">. </span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">));<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94326""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#94326" class="date">29-Oct-2009 02:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another solution to the salted hash with salt included directly in the hash, while keeping the same length of the result. If you want to generate a hash, call the function without the second argument. If you want to check a password against a hash, use the hash as the second argument. In this case, the function returns the hash itself on success, or boolean false on failure. You can also specify a hash algorithm as the third argument (otherwise SHA-1 will be used).<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">__hash</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$obscured </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$algorithm </span><span class="keyword">= </span><span class="string">"sha1"</span><span class="keyword">)<br />
{<br />
&nbsp; </span><span class="comment">// whether to use user specified algorithm<br />
&nbsp; </span><span class="default">$mode </span><span class="keyword">= </span><span class="default">in_array</span><span class="keyword">(</span><span class="default">$algorithm</span><span class="keyword">, </span><span class="default">hash_algos</span><span class="keyword">());<br />
&nbsp; </span><span class="comment">// generate random salt<br />
&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">uniqid</span><span class="keyword">(</span><span class="default">mt_rand</span><span class="keyword">(), </span><span class="default">true</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// hash it<br />
&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">$mode </span><span class="keyword">? </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$algorithm</span><span class="keyword">, </span><span class="default">$salt</span><span class="keyword">) : </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// get the length<br />
&nbsp; </span><span class="default">$slen </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// compute the actual length of salt we will use<br />
&nbsp; // 1/8 to 1/4 of the hash, with shorter passwords producing longer salts<br />
&nbsp; </span><span class="default">$slen </span><span class="keyword">= </span><span class="default">max</span><span class="keyword">(</span><span class="default">$slen </span><span class="keyword">&gt;&gt; </span><span class="default">3</span><span class="keyword">, (</span><span class="default">$slen </span><span class="keyword">&gt;&gt; </span><span class="default">2</span><span class="keyword">) - </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">));<br />
&nbsp; </span><span class="comment">// if we are checking password against a hash, harvest the actual salt from it, otherwise just cut the salt we already have to the proper size<br />
&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">$obscured </span><span class="keyword">? </span><span class="default">__harvest</span><span class="keyword">(</span><span class="default">$obscured</span><span class="keyword">, </span><span class="default">$slen</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">) : </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$slen</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// hash the password - this is maybe unnecessary<br />
&nbsp; </span><span class="default">$hash </span><span class="keyword">= </span><span class="default">$mode </span><span class="keyword">? </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$algorithm</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">) : </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// place the salt in it<br />
&nbsp; </span><span class="default">$hash </span><span class="keyword">= </span><span class="default">__scramble</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">, </span><span class="default">$salt</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// and hash it again<br />
&nbsp; </span><span class="default">$hash </span><span class="keyword">= </span><span class="default">$mode </span><span class="keyword">? </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$algorithm</span><span class="keyword">, </span><span class="default">$hash</span><span class="keyword">) : </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// cut the result so we can add salt and maintain the same length<br />
&nbsp; </span><span class="default">$hash </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">, </span><span class="default">$slen</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// ... do that<br />
&nbsp; </span><span class="default">$hash </span><span class="keyword">= </span><span class="default">__scramble</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">, </span><span class="default">$salt</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// and return the result<br />
&nbsp; </span><span class="keyword">return </span><span class="default">$obscured </span><span class="keyword">&amp;&amp; </span><span class="default">$obscured </span><span class="keyword">!== </span><span class="default">$hash </span><span class="keyword">? </span><span class="default">false </span><span class="keyword">: </span><span class="default">$hash</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
It uses a random, variable length salt, depending on the length of the password. The functions __scramble() and __harvest() are used to place salt into the hash or pull it out respectively. You can write your own, and of course the strength of the result greatly depends on them. They can be relatively simple yet still quite secure:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">__scramble</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">, </span><span class="default">$salt</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">)<br />
{<br />
&nbsp; return </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">)) . </span><span class="default">$salt </span><span class="keyword">. </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">, </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">));<br />
}<br />
<br />
function </span><span class="default">__harvest</span><span class="keyword">(</span><span class="default">$obscured</span><span class="keyword">, </span><span class="default">$slen</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">)<br />
{<br />
&nbsp; return </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$obscured</span><span class="keyword">, </span><span class="default">min</span><span class="keyword">(</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">), </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$obscured</span><span class="keyword">) - </span><span class="default">$slen</span><span class="keyword">), </span><span class="default">$slen</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Or they can be ridiculously complicated (my favourite kind):<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">__scramble</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">, </span><span class="default">$salt</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">)<br />
{<br />
&nbsp; </span><span class="default">$k </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">); </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$k </span><span class="keyword">= </span><span class="default">$k </span><span class="keyword">&gt; </span><span class="default">0 </span><span class="keyword">? </span><span class="default">$k </span><span class="keyword">: </span><span class="default">1</span><span class="keyword">; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$index </span><span class="keyword">= array(); </span><span class="default">$out </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">; </span><span class="default">$m </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$c </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$p</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">pow</span><span class="keyword">(</span><span class="default">$j </span><span class="keyword">+ (</span><span class="default">$c </span><span class="keyword">!== </span><span class="default">false </span><span class="keyword">? </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) : </span><span class="default">0</span><span class="keyword">), </span><span class="default">2</span><span class="keyword">) % (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">) + </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">array_key_exists</span><span class="keyword">(</span><span class="default">$j</span><span class="keyword">, </span><span class="default">$index</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= ++</span><span class="default">$j </span><span class="keyword">% (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">) + </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$index</span><span class="keyword">[</span><span class="default">$j</span><span class="keyword">] = </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= ++</span><span class="default">$p </span><span class="keyword">% </span><span class="default">$k</span><span class="keyword">;<br />
&nbsp; }<br />
&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$hash</span><span class="keyword">) + </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="default">array_key_exists</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">, </span><span class="default">$index</span><span class="keyword">) ? </span><span class="default">$salt</span><span class="keyword">[</span><span class="default">$index</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]] : </span><span class="default">$hash</span><span class="keyword">[</span><span class="default">$m</span><span class="keyword">++];<br />
&nbsp; return </span><span class="default">$out</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">__harvest</span><span class="keyword">(</span><span class="default">$obscured</span><span class="keyword">, </span><span class="default">$slen</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">)<br />
{<br />
&nbsp; </span><span class="default">$k </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">); </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$k </span><span class="keyword">= </span><span class="default">$k </span><span class="keyword">&gt; </span><span class="default">0 </span><span class="keyword">? </span><span class="default">$k </span><span class="keyword">: </span><span class="default">1</span><span class="keyword">; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$index </span><span class="keyword">= array(); </span><span class="default">$out </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;<br />
&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$slen</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$c </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$p</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">pow</span><span class="keyword">(</span><span class="default">$j </span><span class="keyword">+ (</span><span class="default">$c </span><span class="keyword">!== </span><span class="default">false </span><span class="keyword">? </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) : </span><span class="default">0</span><span class="keyword">), </span><span class="default">2</span><span class="keyword">) % </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$obscured</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">in_array</span><span class="keyword">(</span><span class="default">$j</span><span class="keyword">, </span><span class="default">$index</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= ++</span><span class="default">$j </span><span class="keyword">% </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$obscured</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$index</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="default">$j</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= ++</span><span class="default">$p </span><span class="keyword">% </span><span class="default">$k</span><span class="keyword">;<br />
&nbsp; }<br />
&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$slen</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="default">$obscured</span><span class="keyword">[</span><span class="default">$index</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]];<br />
&nbsp; return </span><span class="default">$out</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90301""></a>
  <div class="note">
   <strong class="user">paul</strong>
   <a href="#90301" class="date">15-Apr-2009 03:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I believe this offers best amount of protection using a random salt, that has to be stored so it can be used later for verification.
<br />

<br />
If no salt is given (which can be retrieved by halving the output and taking the first half), then it will generate a random salt, hash it, place it in a position relative to the length of password (between 0 and length of hash type(sha1? md5?)) within the hashed password, and then hash the complete string.
<br />

<br />
This results in a password hash using a salt that is dynamically placed dependant on password length. The salt used is then appended to the front of the finished hash so it can be retrieved later on for verifying.
<br />

<br />
Seeing as users will choose a typical password of between 5 and say 15 characters long, this gives them an extra 10 times the amount of dictionary attacks to try out with the hash as it could be placed in any position, because this is a random generated salt too, it means at least 10 dictionary attacks (with possiblity of upto 40) for each instance a password is created, to try and work out your sha1 encrypted password.
<br />

<br />
If you change your password say every month, even if someone gets a look in at your file through a local exploit, the amount of time to work out your password would far outweigh the frequency at which you change it.
<br />

<br />
Nothing is secure, but this should take them longer to work out then the time you change it. That is at least by todays technologies.
<br />

<br />
Paul
<br />

<br />
<span class="default">&lt;?php
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">createHash</span><span class="keyword">(</span><span class="default">$inText</span><span class="keyword">, </span><span class="default">$saltHash</span><span class="keyword">=</span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$mode</span><span class="keyword">=</span><span class="string">'sha1'</span><span class="keyword">){
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// hash the text //
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$textHash </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$mode</span><span class="keyword">, </span><span class="default">$inText</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// set where salt will appear in hash //
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$saltStart </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$inText</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// if no salt given create random one //
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">$saltHash </span><span class="keyword">== </span><span class="default">NULL</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$saltHash </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$mode</span><span class="keyword">, </span><span class="default">uniqid</span><span class="keyword">(</span><span class="default">rand</span><span class="keyword">(), </span><span class="default">true</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// add salt into text hash at pass length position and hash it //
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">$saltStart </span><span class="keyword">&gt; </span><span class="default">0 </span><span class="keyword">&amp;&amp; </span><span class="default">$saltStart </span><span class="keyword">&lt; </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$saltHash</span><span class="keyword">)) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$textHashStart </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$textHash</span><span class="keyword">,</span><span class="default">0</span><span class="keyword">,</span><span class="default">$saltStart</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$textHashEnd </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$textHash</span><span class="keyword">,</span><span class="default">$saltStart</span><span class="keyword">,</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$saltHash</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$outHash </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$mode</span><span class="keyword">, </span><span class="default">$textHashEnd</span><span class="keyword">.</span><span class="default">$saltHash</span><span class="keyword">.</span><span class="default">$textHashStart</span><span class="keyword">); 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } elseif(</span><span class="default">$saltStart </span><span class="keyword">&gt; (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$saltHash</span><span class="keyword">)-</span><span class="default">1</span><span class="keyword">)) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$outHash </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$mode</span><span class="keyword">, </span><span class="default">$textHash</span><span class="keyword">.</span><span class="default">$saltHash</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$outHash </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$mode</span><span class="keyword">, </span><span class="default">$saltHash</span><span class="keyword">.</span><span class="default">$textHash</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// put salt at front of hash //
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$output </span><span class="keyword">= </span><span class="default">$saltHash</span><span class="keyword">.</span><span class="default">$outHash</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$output</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="88057""></a>
  <div class="note">
   <strong class="user">mVamer</strong>
   <a href="#88057" class="date">08-Jan-2009 02:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If I correctly understand what ranko84 is on about, this would be a simpler function with roughly the same result.
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">obscure</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$algorythm </span><span class="keyword">= </span><span class="string">"sha1"</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Get some random salt, or verify a salt.
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // Added by (grosbedo AT gmail DOT com)
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$salt </span><span class="keyword">== </span><span class="default">NULL</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$algorythm</span><span class="keyword">, </span><span class="default">uniqid</span><span class="keyword">(</span><span class="default">rand</span><span class="keyword">(), </span><span class="default">true</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Determine the length of the hash.
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hash_length </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Determine the length of the password.
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$password_length </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Determine the maximum length of password. This is only needed if
<br />
&nbsp;&nbsp;&nbsp; // the user enters a very long password. In any case, the salt will
<br />
&nbsp;&nbsp;&nbsp; // be a maximum of half the end result. The longer the hash, the
<br />
&nbsp;&nbsp;&nbsp; // longer the password/salt can be. 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$password_max_length </span><span class="keyword">= </span><span class="default">$hash_length </span><span class="keyword">/ </span><span class="default">2</span><span class="keyword">;
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Shorten the salt based on the length of the password.
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$password_length </span><span class="keyword">&gt;= </span><span class="default">$password_max_length</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$password_max_length</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; else
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$salt </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$password_length</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; }
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Determine the length of the salt.
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$salt_length </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$salt</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Determine the salted hashed password.
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$salted_password </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$algorythm</span><span class="keyword">, </span><span class="default">$salt </span><span class="keyword">. </span><span class="default">$password</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// If we add the salt to the hashed password, we would get a hash that
<br />
&nbsp;&nbsp;&nbsp; // is longer than a normally hashed password. We don't want that; it
<br />
&nbsp;&nbsp;&nbsp; // would give away hints to an attacker. Because the password and the
<br />
&nbsp;&nbsp;&nbsp; // length of the password are known, we can just throw away the first
<br />
&nbsp;&nbsp;&nbsp; // couple of characters of the salted password. That way the salt and
<br />
&nbsp;&nbsp;&nbsp; // the salted password together are the same length as a normally
<br />
&nbsp;&nbsp;&nbsp; // hashed password without salt.
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$used_chars </span><span class="keyword">= (</span><span class="default">$hash_length </span><span class="keyword">- </span><span class="default">$salt_length</span><span class="keyword">) * -</span><span class="default">1</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$final_result </span><span class="keyword">= </span><span class="default">$salt </span><span class="keyword">. </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$salted_password</span><span class="keyword">, </span><span class="default">$used_chars</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$final_result</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87692""></a>
  <div class="note">
   <strong class="user">ranko84 at gmail dot com</strong>
   <a href="#87692" class="date">17-Dec-2008 05:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Small update..., well more like fix to the obscure function, replace<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if (</span><span class="default">$keepLength </span><span class="keyword">!= </span><span class="default">NULL</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$hSLength </span><span class="keyword">!= </span><span class="default">0</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hPassHash </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hPassHash</span><span class="keyword">, </span><span class="default">$hLPosition</span><span class="keyword">, -</span><span class="default">$hRPosition</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
with<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if (</span><span class="default">$keepLength </span><span class="keyword">!= </span><span class="default">NULL</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$hSLength </span><span class="keyword">!= </span><span class="default">0</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$hRPosition </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hPassHash </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hPassHash</span><span class="keyword">, </span><span class="default">$hLPosition</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hPassHash </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hPassHash</span><span class="keyword">, </span><span class="default">$hLPosition</span><span class="keyword">, -</span><span class="default">$hRPosition</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
I've been getting few requests to explain how it's used so, this might be little long.<br />
<br />
Problems:<br />
1. In most solutions with hash and salt, you were bound to have one extra row in your database that would state, preferably random, salt for that hashed data. If attacker would manage to get drop of your database he would get hashed data and salt that is used with plain data to make it obscure, and then cracking that hashed data would be same as if you didn't add any salt to it.<br />
2. I stumbled upon some functions that would hash data, then input salt into random places in hash and store it in database, but they would still have to write down random parameter used to scramble salt so they could reuse it when validating data. Getting simple database drop wouldn't help much here, but if they would manage to get their hands on obscuring function too, they could easily see what is salt and what hash.<br />
<br />
Solutions:<br />
1. Why use extra row to store salt when you can input it in hash. I'm not sure how attackers determine what type of hash are they facing, but I guess it has connection to hash length. In that case, why make attackers job easier and store in database data_hash+salt where they could assume just by it's length it has salt in there.<br />
Reason behind $keepLength. If it's set to 1, strlen of hashed data plus salt would be equal to strlen of hashed data leading attacker to believe there is no salt.<br />
If you leave $keepLength on NULL, strlen of final result would be strlen(used_hash_algorithm)+$hSLength.<br />
$minhPass is there to reserve enough place for string that has to be hashed, so someone using this function wouldn't accidentally delete it by setting too high salt length ($hSLength), for example... if you set it 30000 it will keep working normal.<br />
<br />
2. If you think about it, constant, but variable value when making input would be same data that is being input.<br />
In case we're trying to hash password, and have user A with password "notme", password strlen equals to 5, and if we use default parameters of the function, with $keepLength set to 1, process would be:<br />
random salt, hash it, add first 5 characters of hashed_salt at beginning of plain password, add last 5 characters of hashed_salt at end of plain password, hash it. Replace first 5 characters of hashed_password with first 5 character of hashed_salt, do same with last 5 characters of hashed_password, return hashed_password.<br />
In case that string is longer than 10 characters function would use simple mathematics to reduce it to numbers lower than 10, well... lower than number that is stated in $hSLength.<br />
And good thing is that every time user enters correct password it has same length so it's not necessary to write it anywhere.<br />
<br />
So what is achieved in the end?<br />
1. Attacker might not know that hash is salted, and you don't have that extra row in your database stating THIS IS SALT FOR THIS HASH.<br />
2. If he does find out that it is, he wouldn't know what is hashed password and what is salt.<br />
3. If he manages to get access to obscure function, only thing that might help him is value of $hSLength, where if $hSLength is set to 10 he would have to crack 10 variations of hashed string since he doesn't know how long password of user he's trying to crack is.<br />
For example first variation would be hashed_password without last 10 characters, second variation would be hashed_password without first character and last 9 characters...<br />
4. Even in case he has enough power to crack all 10 variations, resulting string that he might get doesn't necessarily has to be exactly long as password of original user in which case, attacker fails again.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="86239""></a>
  <div class="note">
   <strong class="user">Andre D</strong>
   <a href="#86239" class="date">09-Oct-2008 03:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a better version of the getDigestNotation() function I posted earlier. (The first version had a bug in the argument checking.)<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">getDigestNotation</span><span class="keyword">(</span><span class="default">$rawDigest</span><span class="keyword">, </span><span class="default">$bitsPerCharacter</span><span class="keyword">, </span><span class="default">$chars </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$chars </span><span class="keyword">=== </span><span class="default">NULL </span><span class="keyword">|| </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">) &lt; </span><span class="default">2</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$chars </span><span class="keyword">= </span><span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-,'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$bitsPerCharacter </span><span class="keyword">&lt; </span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// $bitsPerCharacter must be at least 1<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsPerCharacter </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; } elseif (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">) &lt; </span><span class="default">pow</span><span class="keyword">(</span><span class="default">2</span><span class="keyword">, </span><span class="default">$bitsPerCharacter</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Character length of $chars is too small for $bitsPerCharacter<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // Set $bitsPerCharacter to greatest value allowed by length of $chars<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsPerCharacter </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$minCharLength </span><span class="keyword">= </span><span class="default">2</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; while (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">) &gt;= (</span><span class="default">$minCharLength </span><span class="keyword">*= </span><span class="default">2</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsPerCharacter</span><span class="keyword">++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; unset(</span><span class="default">$minCharLength</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'C*'</span><span class="keyword">, </span><span class="default">$rawDigest</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$byteCount </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$byte </span><span class="keyword">= </span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bitsRead </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$byteCount </span><span class="keyword">* </span><span class="default">8 </span><span class="keyword">/ </span><span class="default">$bitsPerCharacter</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$bitsRead </span><span class="keyword">+ </span><span class="default">$bitsPerCharacter </span><span class="keyword">&gt; </span><span class="default">8</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Not enough bits remain in this byte for the current character<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Get remaining bits and get next byte<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldBits </span><span class="keyword">= </span><span class="default">$byte </span><span class="keyword">- (</span><span class="default">$byte </span><span class="keyword">&gt;&gt; </span><span class="default">8 </span><span class="keyword">- </span><span class="default">$bitsRead </span><span class="keyword">&lt;&lt; </span><span class="default">8 </span><span class="keyword">- </span><span class="default">$bitsRead</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">) == </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Last bits; match final character and exit loop<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="default">$chars</span><span class="keyword">[</span><span class="default">$oldBits</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldBitCount </span><span class="keyword">= </span><span class="default">8 </span><span class="keyword">- </span><span class="default">$bitsRead</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$byte </span><span class="keyword">= </span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsRead </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldBitCount </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Read only the needed bits from this byte<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bits </span><span class="keyword">= </span><span class="default">$byte </span><span class="keyword">&gt;&gt; </span><span class="default">8 </span><span class="keyword">- (</span><span class="default">$bitsRead </span><span class="keyword">+ (</span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bits </span><span class="keyword">= </span><span class="default">$bits </span><span class="keyword">- (</span><span class="default">$bits </span><span class="keyword">&gt;&gt; </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount </span><span class="keyword">&lt;&lt; </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsRead </span><span class="keyword">+= </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$oldBitCount </span><span class="keyword">&gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Bits come from seperate bytes, add $oldBits to $bits<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bits </span><span class="keyword">= (</span><span class="default">$oldBits </span><span class="keyword">&lt;&lt; </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">) | </span><span class="default">$bits</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="default">$chars</span><span class="keyword">[</span><span class="default">$bits</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$out</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="86172""></a>
  <div class="note">
   <strong class="user">Andr D</strong>
   <a href="#86172" class="date">06-Oct-2008 09:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Sometimes you want the digest in both readable notation (such as hexadecimal) and raw binary. At other times you want the digest in a notation other than hexadecimal.<br />
<br />
The following getDigestNotation() function takes a binary string and returns it in base 2, 4, 8, 16, 32, or 64 notation. It works with sha1(), md5(), hash(), or anything else that can output a raw binary string.<br />
<br />
It works similar to the session.hash_bits_per_character php.ini configuration option.<br />
<br />
You can specify which characters to use for each position, or use the default, which matches session.hash_bits_per_character (0-9, a-z, A-Z, "-", ","). The practical range of bits to use per character ($bitsPerCharacter) is 1 to 6; you may use more, but you will have to provide your own base character string ($chars) that is at least pow(2, $bitsPerCharacter) characters long. So even with 7 bits per character you need to specify a value for $chars that is 128 characters long, which exceeds the number of printable ASCII characters.<br />
<br />
The output's radix relates to the value of $bitsPerCharacter as follows:<br />
1: base-2 (binary)<br />
2: base-4<br />
3: base-8 (octal)<br />
4: base-16 (hexadecimal)<br />
5: base-32<br />
6: base-64<br />
<br />
<span class="default">&lt;?php<br />
$raw </span><span class="keyword">= </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">uniqid</span><span class="keyword">(</span><span class="default">mt_rand</span><span class="keyword">(), </span><span class="default">TRUE</span><span class="keyword">), </span><span class="default">TRUE</span><span class="keyword">);<br />
<br />
echo </span><span class="default">getDigestNotation</span><span class="keyword">(</span><span class="default">$raw</span><span class="keyword">, </span><span class="default">6</span><span class="keyword">);<br />
<br />
function </span><span class="default">getDigestNotation</span><span class="keyword">(</span><span class="default">$rawDigest</span><span class="keyword">, </span><span class="default">$bitsPerCharacter</span><span class="keyword">, </span><span class="default">$chars </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$chars </span><span class="keyword">=== </span><span class="default">NULL </span><span class="keyword">|| </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">) &lt; </span><span class="default">2</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$chars </span><span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-,'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$bitsPerCharacter </span><span class="keyword">&lt; </span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// $bitsPerCharacter must be at least 1<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsPerCharacter </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; } elseif (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">) &lt; </span><span class="default">pow</span><span class="keyword">(</span><span class="default">2</span><span class="keyword">, </span><span class="default">$bitsPerCharacter</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Character length of $chars is too small for $bitsPerCharacter<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // Set $bitsPerCharacter to greatest value allowed by length of $chars<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsPerCharacter </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; do {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsPerCharacter</span><span class="keyword">++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } while (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$chars</span><span class="keyword">) &gt; </span><span class="default">pow</span><span class="keyword">(</span><span class="default">2</span><span class="keyword">, </span><span class="default">$bitsPerCharacter</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'C*'</span><span class="keyword">, </span><span class="default">$rawDigest</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$byteCount </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$byte </span><span class="keyword">= </span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bitsRead </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$byteCount </span><span class="keyword">* </span><span class="default">8 </span><span class="keyword">/ </span><span class="default">$bitsPerCharacter</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$bitsRead </span><span class="keyword">+ </span><span class="default">$bitsPerCharacter </span><span class="keyword">&gt; </span><span class="default">8</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Not enough bits remain in this byte for the current character<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Get remaining bits and get next byte<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldBits </span><span class="keyword">= </span><span class="default">$byte </span><span class="keyword">- (</span><span class="default">$byte </span><span class="keyword">&gt;&gt; </span><span class="default">8 </span><span class="keyword">- </span><span class="default">$bitsRead </span><span class="keyword">&lt;&lt; </span><span class="default">8 </span><span class="keyword">- </span><span class="default">$bitsRead</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">) == </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Last bits; match final character and exit loop<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="default">$chars</span><span class="keyword">[</span><span class="default">$oldBits</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldBitCount </span><span class="keyword">= </span><span class="default">8 </span><span class="keyword">- </span><span class="default">$bitsRead</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$byte </span><span class="keyword">= </span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$bytes</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsRead </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldBitCount </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Read only the needed bits from this byte<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bits </span><span class="keyword">= </span><span class="default">$byte </span><span class="keyword">&gt;&gt; </span><span class="default">8 </span><span class="keyword">- (</span><span class="default">$bitsRead </span><span class="keyword">+ (</span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bits </span><span class="keyword">= </span><span class="default">$bits </span><span class="keyword">- (</span><span class="default">$bits </span><span class="keyword">&gt;&gt; </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount </span><span class="keyword">&lt;&lt; </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bitsRead </span><span class="keyword">+= </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$oldBitCount </span><span class="keyword">&gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Bits come from seperate bytes, add $oldBits to $bits<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$bits </span><span class="keyword">= (</span><span class="default">$oldBits </span><span class="keyword">&lt;&lt; </span><span class="default">$bitsPerCharacter </span><span class="keyword">- </span><span class="default">$oldBitCount</span><span class="keyword">) | </span><span class="default">$bits</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$out </span><span class="keyword">.= </span><span class="default">$chars</span><span class="keyword">[</span><span class="default">$bits</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$out</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Lastly, depending on the digest length, there may be fewer bits remaining for the last character than $bitsPerCharacter, so the last character will be smaller. The same thing happens with PHP's session ID generator, when 5 or 6 is used for session.hash_bits_per_character.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83079""></a>
  <div class="note">
   <strong class="user">ranko84 at gmail dot com</strong>
   <a href="#83079" class="date">09-May-2008 04:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Thanks for the feedback. This should do the trick, I hope.<br />
I think that I haven't understood this sentence completely "In this case you will need the salt to reside in the database along with the username and password." As in, were you refering to previous method, this method or this function.<br />
Salt already resides in database along with username, password, or any string you decide to hash. This function just scrambles it depending on length of string (password) user enters so that attacker has trouble finding out what is salt and what is hash, if attacker even suspects that there is salt (reasons behind $keepLength, or defining $hSLength where you could set it to 24 leading attacker to believe he's facing sha256, not sha1).<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">obscure </span><span class="keyword">(</span><span class="default">$hString</span><span class="keyword">, </span><span class="default">$hDecode </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$hSLength </span><span class="keyword">= </span><span class="default">10</span><span class="keyword">, </span><span class="default">$keepLength </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$minhPass </span><span class="keyword">= </span><span class="default">10</span><span class="keyword">, </span><span class="default">$hMethod </span><span class="keyword">= </span><span class="default">sha1</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$hDecode </span><span class="keyword">== </span><span class="default">NULL</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">16</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hSalt </span><span class="keyword">= </span><span class="default">rand</span><span class="keyword">(</span><span class="default">33</span><span class="keyword">, </span><span class="default">255</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hRandomSalt </span><span class="keyword">.= </span><span class="default">chr</span><span class="keyword">(</span><span class="default">$hSalt</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hRandomSalt </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$hMethod</span><span class="keyword">, </span><span class="default">$hRandomSalt</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hRandomSalt </span><span class="keyword">= </span><span class="default">$hDecode</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$keepLength </span><span class="keyword">!= </span><span class="default">NULL</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$hSLength </span><span class="keyword">&gt; (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$hRandomSalt</span><span class="keyword">) - </span><span class="default">$minhPass</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hSLength </span><span class="keyword">= (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$hRandomSalt</span><span class="keyword">) - </span><span class="default">$minhPass</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else if (</span><span class="default">$hSLength </span><span class="keyword">&lt; </span><span class="default">0</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hSLength </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hLPosition </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$hString</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">$hLPosition </span><span class="keyword">&gt; </span><span class="default">$hSLength</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hNumber </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hLPosition</span><span class="keyword">, -</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hLPosition </span><span class="keyword">= </span><span class="default">$hLPosition </span><span class="keyword">* (</span><span class="default">$hNumber</span><span class="keyword">/</span><span class="default">10</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hLPosition </span><span class="keyword">= (integer)</span><span class="default">$hLPosition</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hRPosition </span><span class="keyword">= </span><span class="default">$hSLength </span><span class="keyword">- </span><span class="default">$hLPosition</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hFSalt </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hRandomSalt</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$hLPosition</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hLSalt </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hRandomSalt</span><span class="keyword">, -</span><span class="default">$hRPosition</span><span class="keyword">, </span><span class="default">$hRPosition</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$hPassHash </span><span class="keyword">= </span><span class="default">hash</span><span class="keyword">(</span><span class="default">$hMethod</span><span class="keyword">, (</span><span class="default">$hLSalt </span><span class="keyword">. </span><span class="default">$hString </span><span class="keyword">. </span><span class="default">$hFSalt</span><span class="keyword">));<br />
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$keepLength </span><span class="keyword">!= </span><span class="default">NULL</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$hSLength </span><span class="keyword">!= </span><span class="default">0</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hPassHash </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$hPassHash</span><span class="keyword">, </span><span class="default">$hLPosition</span><span class="keyword">, -</span><span class="default">$hRPosition</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$hFSalt </span><span class="keyword">. </span><span class="default">$hPassHash </span><span class="keyword">. </span><span class="default">$hLSalt</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81388""></a>
  <div class="note">
   <strong class="user">nathan</strong>
   <a href="#81388" class="date">26-Feb-2008 05:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The suggestion below to double-hash your password is not a good idea.&nbsp; You are much much better off adding a variable salt to passwords before hashing (such as the username or other field that is dissimilar for every account).<br />
<br />
Double hashing is *worse* security than a regular hash.&nbsp; What you're actually doing is taking some input $passwd, converting it to a string of exactly 32 characters containing only the characters [0-9][A-F], and then hashing *that*. You have just *greatly* increased the odds of a hash collision (ie. the odds that I can guess a phrase that will hash to the same value as your password).<br />
<br />
sha1(md5($pass)) makes even less sense, since you're feeding in 128-bits of information to generate a 256-bit hash, so 50% of the resulting data is redundant.&nbsp; You have not increased security at all.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81007""></a>
  <div class="note">
   <strong class="user">ERASEthemasterswordsman at gmail dot com</strong>
   <a href="#81007" class="date">11-Feb-2008 03:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that hashing a has is not completely secure, but can be used as an extra precaution (but not recommended):<br />
<br />
<span class="default">&lt;?php<br />
<br />
sha1</span><span class="keyword">(</span><span class="default">md5</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">));<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77817""></a>
  <div class="note">
   <strong class="user">NoName</strong>
   <a href="#77817" class="date">14-Sep-2007 12:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Regarding the twistSTR - the problem is that currently it is relatively easy to generate a collision for any alphanumeric plaintext of a given, short length via e.g. a rainbow table. You're bettter off using a sufficiently lengthy and random salt.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71449""></a>
  <div class="note">
   <strong class="user">novum123 at ribbonbazaar dot com</strong>
   <a href="#71449" class="date">29-Nov-2006 05:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
So far as the dictionary attacks are concerned, I thought up the following function:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">twistSTR</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">){<br />
&nbsp; </span><span class="default">$twisted</span><span class="keyword">=</span><span class="string">""</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$array_strlen</span><span class="keyword">=array();<br />
<br />
&nbsp; foreach (</span><span class="default">$array </span><span class="keyword">as </span><span class="default">$element</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array_strlen</span><span class="keyword">[]=</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$element</span><span class="keyword">);<br />
&nbsp; }<br />
<br />
&nbsp; for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">max</span><span class="keyword">(</span><span class="default">$array_strlen</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$array </span><span class="keyword">as </span><span class="default">$element</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp;&nbsp; if (</span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$element</span><span class="keyword">)){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$twisted</span><span class="keyword">=</span><span class="default">$twisted</span><span class="keyword">.</span><span class="default">$element</span><span class="keyword">{</span><span class="default">$i</span><span class="keyword">};<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
<br />
&nbsp; return </span><span class="default">$twisted</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
The twistSTR function basically takes an array input of strings and alternates each character of each string among all the other strings.&nbsp; For example:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">echo </span><span class="default">twistSTR</span><span class="keyword">(array(</span><span class="string">"this"</span><span class="keyword">,</span><span class="string">"and"</span><span class="keyword">,</span><span class="string">"that"</span><span class="keyword">));</span><span class="comment">//output: tathnhidast<br />
</span><span class="default">?&gt;<br />
</span><br />
It can be applied in the following manner:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if (</span><span class="default">$un</span><span class="keyword">===</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"username"</span><span class="keyword">] &amp;&amp; </span><span class="default">$pwd</span><span class="keyword">===</span><span class="default">sha1</span><span class="keyword">(</span><span class="default">twistSTR</span><span class="keyword">(array(</span><span class="default">$salt</span><span class="keyword">,</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"password"</span><span class="keyword">])))){<br />
</span><span class="default">?&gt;<br />
</span><br />
It's not amazingly difficult to reverse engineer the actual output, but then again, that's not the point.&nbsp; The point is that when a password is entered into one of those databases, they are going to enter for example "thisandthat", not "tathnhidast".</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70474""></a>
  <div class="note">
   <strong class="user">Gregory Boshoff</strong>
   <a href="#70474" class="date">18-Oct-2006 01:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that the sha1 algorithm has been compromised and is no longer being used by government agencies.<br />
<br />
As of PHP 5.1.2 a new set of hashing functions are available.<br />
<br />
<a href="http://www.php.net/manual/en/function.hash.php" rel="nofollow" target="_blank">http://www.php.net/manual/en/function.hash.php</a><br />
<br />
The new function hash() supports a new range of hashing methods.<br />
<br />
echo hash('sha256', 'The quick brown fox jumped over the lazy dog.');<br />
<br />
It is recommended that developers start to future proof their applications by using the stronger sha-2, hashing methods such as sha256, sha384, sha512 or better.<br />
<br />
As of PHP 5.1.2 hash_algos() returns an array of system specific or registered hashing algorithms methods that are available to PHP.<br />
<br />
print_r(hash_algos());</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="66239""></a>
  <div class="note">
   <strong class="user">erling dot westenvik at gmail dot com</strong>
   <a href="#66239" class="date">17-May-2006 03:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Regarding php at REMOVEMEkennel17 dot co dot uk's note below:<br />
<br />
The phrase: "To get the correct behaviour", would perhaps be better off if it read: "To get the wanted (but not recommended) behaviour".<br />
<br />
Always honor the expected data types for functions: sha1 expects a string as input, and returns a string on exit. NULL, TRUE and FALSE are not string data types. The string "" is a string as good as "any". By following the "logic" that sha1("") should return "", then what should sha1("a") return? "b"? "c"?<br />
<br />
An authentication system that allows for blank passwords is not really an authentication system in the first place. What you are describing is merely a way to tell the application that you want to see data in some specific context, like sorted by user name, etc. Create other tools for this purpose and leave the authentication system to deal with what it is supposed to do: Granting users access to restricted data and blocking other users from seeing the same data.<br />
<br />
Don't store passwords in clear text, but salt and encrypt them. That way it makes perfect sense having <span class="default">&lt;?php $sStoredPwd </span><span class="keyword">=== </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$sStoredSalt </span><span class="keyword">. </span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"sTypedPwd"</span><span class="keyword">]); </span><span class="default">?&gt;</span>, even with a blank "password". No other person than the user itself, not even the programmer, should know the password or be able to guess it. If the user forgets the password, a new one must be generated.<br />
<br />
Regards,<br />
Erling</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56941""></a>
  <div class="note">
   <strong class="user">php at REMOVEMEkennel17 dot co dot uk</strong>
   <a href="#56941" class="date">20-Sep-2005 03:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It should be noted that sha1("") does not return an empty string.&nbsp; This means that if you are running a system that does not require users to have a password, the following code will not work as expected:<br />
<br />
<span class="default">&lt;?php <br />
</span><span class="keyword">if (</span><span class="default">$StoredPassword </span><span class="keyword">== </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$NewPassword</span><span class="keyword">)) <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Password good<br />
</span><span class="default">?&gt;</span> <br />
<br />
If $StoredPassword and $NewPassword are both blank, then the password should be treated as good, but because sha1("") != "" it will be treated as bad. To get the correct behaviour you need to use:<br />
<br />
<span class="default">&lt;?php <br />
</span><span class="keyword">if ((</span><span class="default">$StoredPassword </span><span class="keyword">== </span><span class="string">"" </span><span class="keyword">&amp;&amp; </span><span class="default">$NewPassword </span><span class="keyword">== </span><span class="string">""</span><span class="keyword">) || (</span><span class="default">$StoredPassword </span><span class="keyword">== </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$NewPassword</span><span class="keyword">)))<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Password good<br />
</span><span class="default">?&gt;</span> <br />
<br />
(Note: I use a custom IsBlank() function instead of comparison against the empty string, so NULL values are also matched.)<br />
<br />
For reference, here are a couple of special values put through sha1().&nbsp; Note that sha1("") == sha1(NULL) == sha1(false), and also that sha1(0) != sha1(false)<br />
<br />
"" -&gt; da39a3ee5e6b4b0d3255bfef95601890afd80709<br />
NULL -&gt; da39a3ee5e6b4b0d3255bfef95601890afd80709<br />
0 -&gt; b6589fc6ab0dc82cf12099d1c2d40ab994e8410c<br />
1 -&gt; 356a192b7913b04c54574d18c28d46e6395428ab<br />
false -&gt; da39a3ee5e6b4b0d3255bfef95601890afd80709<br />
true -&gt; 356a192b7913b04c54574d18c28d46e6395428ab</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56503""></a>
  <div class="note">
   <strong class="user">Dan</strong>
   <a href="#56503" class="date">05-Sep-2005 07:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've noticed websites are now starting to require passwords of a certain length that MUST contain at least 1 non-alphanumeric character. This in itself makes dictionary attacks kind of useless. My web site requires that as well. It uses md5, and appends a site code into the md5 as well. And the include file that contains that site key is outside the public folders. I sure hope I've done enough to keep the bad boys out.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55435""></a>
  <div class="note">
   <strong class="user">WTM</strong>
   <a href="#55435" class="date">03-Aug-2005 04:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Actually, the post by Helpful Harry won't improve your security except for the most simple break in attempts.&nbsp; Since the random seed is attached to the end of the password hash, if you steal the hashed password, you steal the seed.<br />
<br />
That means you can write a simple php program to call the pw_check function Harry included from a loop, feeding it dictionary words or random characters.<br />
<br />
Of course, if you modified the program to use the seed in a more complicated way, "they" would have to know the new function's operation.&nbsp; But then again, if someone can steal your password database, they can probably steal your website code (or guess it).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="54509""></a>
  <div class="note">
   <strong class="user">Helpful Harry</strong>
   <a href="#54509" class="date">06-Jul-2005 07:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
check out these randomized sha1 password storage functions, they output a string of 50 characters, the first 40 characters being a sha1 output based on the last 10 characters - those being a random seed<br />
<br />
to encode a password run pw_encode with the password, it'll return a different pseudo-random string every time - store this value.<br />
<br />
to check a password run pw_check with the password attempt and the stored value, it'll return true on a match and false otherwise<br />
<br />
these functions eliminate the pesky problem of dictionary matches being run on your password lists<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">pw_encode</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt;= </span><span class="default">10</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">$seed </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="string">'0123456789abcdef'</span><span class="keyword">, </span><span class="default">rand</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">,</span><span class="default">15</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; return </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$seed</span><span class="keyword">.</span><span class="default">$password</span><span class="keyword">.</span><span class="default">$seed</span><span class="keyword">).</span><span class="default">$seed</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">pw_check</span><span class="keyword">(</span><span class="default">$password</span><span class="keyword">, </span><span class="default">$stored_value</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp; if (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$stored_value</span><span class="keyword">) != </span><span class="default">50</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">FALSE</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$stored_seed </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$stored_value</span><span class="keyword">,</span><span class="default">40</span><span class="keyword">,</span><span class="default">10</span><span class="keyword">);<br />
&nbsp;&nbsp; if (</span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$stored_seed</span><span class="keyword">.</span><span class="default">$password</span><span class="keyword">.</span><span class="default">$stored_seed</span><span class="keyword">).</span><span class="default">$stored_seed </span><span class="keyword">== </span><span class="default">$stored_value</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; return </span><span class="default">TRUE</span><span class="keyword">;<br />
&nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; return </span><span class="default">FALSE</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52372""></a>
  <div class="note">
   <strong class="user">alex at milivojevic dot org</strong>
   <a href="#52372" class="date">28-Apr-2005 11:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Regarding my previous comment, if you want to be on the safe side and use only ASCII printable seeds (shouldn't matter for SSHA seeds), something like this could be used:<br />
<br />
<span class="default">&lt;?php<br />
$salt </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">(</span><span class="string">"H*"</span><span class="keyword">, </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">mt_rand</span><span class="keyword">()))), </span><span class="default">0</span><span class="keyword">, </span><span class="default">4</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50169""></a>
  <div class="note">
   <strong class="user">svn at datapirate dot de</strong>
   <a href="#50169" class="date">20-Feb-2005 02:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Wanna use SHA-2 algorithm? Try this:<br />
<br />
Download Tar-Ball from <a href="http://www.adg.us/computers/sha.html" rel="nofollow" target="_blank">http://www.adg.us/computers/sha.html</a><br />
Compile (may occur some warnings) and test it:<br />
<br />
cc -O2 -DSHA2_UNROLL_TRANSFORM -Wall -o sha2 sha2prog.c sha2.c<br />
./sha2test.pl<br />
<br />
Copy it to /usr/local/bin/ (don't forget to check permissions)<br />
<br />
Here are two functions that could be used with:<br />
<br />
function sha2($bits, $string){<br />
&nbsp;&nbsp;&nbsp; $sha2bin="/usr/local/bin/sha2";<br />
&nbsp;&nbsp;&nbsp; $echocmd="echo";<br />
&nbsp;&nbsp;&nbsp; if(!in_array($bits, array(256, 384, 512)))return(false);<br />
&nbsp;&nbsp;&nbsp; $r=exec($echocmd." ".escapeshellarg($string)."|".$sha2bin." -q -".$bits, $sha2);<br />
&nbsp;&nbsp;&nbsp; return($sha2[0]);<br />
}<br />
<br />
function sha2_file($bits, $filename){<br />
&nbsp;&nbsp;&nbsp; $sha2bin="/usr/local/bin/sha2";<br />
&nbsp;&nbsp;&nbsp; if(!in_array($bits, array(256, 384, 512)))return(false);<br />
&nbsp;&nbsp;&nbsp; if(!file_exists($filename)||!is_readable($filename))return(false);<br />
&nbsp;&nbsp;&nbsp; $r=exec($sha2bin." -q -".$bits." ".escapeshellarg($filename), $sha2);<br />
&nbsp;&nbsp;&nbsp; return($sha2[0]);<br />
}<br />
<br />
and use it like below:<br />
<br />
<span class="default">&lt;?php<br />
$str </span><span class="keyword">= </span><span class="string">'apple'</span><span class="keyword">;<br />
if (</span><span class="default">sha2</span><span class="keyword">(</span><span class="default">256</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">) === </span><span class="string">'303980bcb9e9e6cdec515230791af8b0ab1aaa244b58a8d99152673aa22197d0'</span><span class="keyword">) {<br />
&nbsp;&nbsp; echo </span><span class="string">"Would you like a green or red apple?"</span><span class="keyword">;<br />
&nbsp;&nbsp; exit;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47609""></a>
  <div class="note">
   <strong class="user">sinatosk at gmail dot com</strong>
   <a href="#47609" class="date">22-Nov-2004 09:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Heres an SHA1 function that will work on it's own completely. This is for users who are using below PHP 4.3.0. it works same as PHP5 ( being able to return raw output ).<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">/*<br />
** Date modified: 1st October 2004 20:09 GMT<br />
*<br />
** PHP implementation of the Secure Hash Algorithm ( SHA-1 )<br />
*<br />
** This code is available under the GNU Lesser General Public License:<br />
** <a href="http://www.gnu.org/licenses/lgpl.txt" rel="nofollow" target="_blank">http://www.gnu.org/licenses/lgpl.txt</a><br />
*<br />
** Based on the PHP implementation by Marcus Campbell<br />
** <a href="http://www.tecknik.net/sha-1/" rel="nofollow" target="_blank">http://www.tecknik.net/sha-1/</a><br />
*<br />
** This is a slightly modified version by me Jerome Clarke ( sinatosk@gmail.com )<br />
** because I feel more comfortable with this<br />
*/<br />
<br />
</span><span class="keyword">function </span><span class="default">sha1_str2blks_SHA1</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$strlen_str </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$nblk </span><span class="keyword">= ((</span><span class="default">$strlen_str </span><span class="keyword">+ </span><span class="default">8</span><span class="keyword">) &gt;&gt; </span><span class="default">6</span><span class="keyword">) + </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$nblk </span><span class="keyword">* </span><span class="default">16</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) </span><span class="default">$blks</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$strlen_str</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$blks</span><span class="keyword">[</span><span class="default">$i </span><span class="keyword">&gt;&gt; </span><span class="default">2</span><span class="keyword">] |= </span><span class="default">ord</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">)) &lt;&lt; (</span><span class="default">24 </span><span class="keyword">- (</span><span class="default">$i </span><span class="keyword">% </span><span class="default">4</span><span class="keyword">) * </span><span class="default">8</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$blks</span><span class="keyword">[</span><span class="default">$i </span><span class="keyword">&gt;&gt; </span><span class="default">2</span><span class="keyword">] |= </span><span class="default">0x80 </span><span class="keyword">&lt;&lt; (</span><span class="default">24 </span><span class="keyword">- (</span><span class="default">$i </span><span class="keyword">% </span><span class="default">4</span><span class="keyword">) * </span><span class="default">8</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$blks</span><span class="keyword">[</span><span class="default">$nblk </span><span class="keyword">* </span><span class="default">16 </span><span class="keyword">- </span><span class="default">1</span><span class="keyword">] = </span><span class="default">$strlen_str </span><span class="keyword">* </span><span class="default">8</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$blks</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">$x</span><span class="keyword">, </span><span class="default">$y</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$lsw </span><span class="keyword">= (</span><span class="default">$x </span><span class="keyword">&amp; </span><span class="default">0xFFFF</span><span class="keyword">) + (</span><span class="default">$y </span><span class="keyword">&amp; </span><span class="default">0xFFFF</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$msw </span><span class="keyword">= (</span><span class="default">$x </span><span class="keyword">&gt;&gt; </span><span class="default">16</span><span class="keyword">) + (</span><span class="default">$y </span><span class="keyword">&gt;&gt; </span><span class="default">16</span><span class="keyword">) + (</span><span class="default">$lsw </span><span class="keyword">&gt;&gt; </span><span class="default">16</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return (</span><span class="default">$msw </span><span class="keyword">&lt;&lt; </span><span class="default">16</span><span class="keyword">) | (</span><span class="default">$lsw </span><span class="keyword">&amp; </span><span class="default">0xFFFF</span><span class="keyword">);<br />
}<br />
<br />
function </span><span class="default">sha1_rol</span><span class="keyword">(</span><span class="default">$num</span><span class="keyword">, </span><span class="default">$cnt</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; return (</span><span class="default">$num </span><span class="keyword">&lt;&lt; </span><span class="default">$cnt</span><span class="keyword">) | </span><span class="default">sha1_zeroFill</span><span class="keyword">(</span><span class="default">$num</span><span class="keyword">, </span><span class="default">32 </span><span class="keyword">- </span><span class="default">$cnt</span><span class="keyword">);&nbsp; &nbsp; <br />
}<br />
<br />
function </span><span class="default">sha1_zeroFill</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bin </span><span class="keyword">= </span><span class="default">decbin</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$strlen_bin </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bin </span><span class="keyword">= </span><span class="default">$strlen_bin </span><span class="keyword">&lt; </span><span class="default">$b </span><span class="keyword">? </span><span class="default">0 </span><span class="keyword">: </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$strlen_bin </span><span class="keyword">- </span><span class="default">$b</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$b</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) </span><span class="default">$bin </span><span class="keyword">= </span><span class="string">'0'</span><span class="keyword">.</span><span class="default">$bin</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">bindec</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">);<br />
}<br />
<br />
function </span><span class="default">sha1_ft</span><span class="keyword">(</span><span class="default">$t</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">, </span><span class="default">$c</span><span class="keyword">, </span><span class="default">$d</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$t </span><span class="keyword">&lt; </span><span class="default">20</span><span class="keyword">) return (</span><span class="default">$b </span><span class="keyword">&amp; </span><span class="default">$c</span><span class="keyword">) | ((~</span><span class="default">$b</span><span class="keyword">) &amp; </span><span class="default">$d</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$t </span><span class="keyword">&lt; </span><span class="default">40</span><span class="keyword">) return </span><span class="default">$b </span><span class="keyword">^ </span><span class="default">$c </span><span class="keyword">^ </span><span class="default">$d</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$t </span><span class="keyword">&lt; </span><span class="default">60</span><span class="keyword">) return (</span><span class="default">$b </span><span class="keyword">&amp; </span><span class="default">$c</span><span class="keyword">) | (</span><span class="default">$b </span><span class="keyword">&amp; </span><span class="default">$d</span><span class="keyword">) | (</span><span class="default">$c </span><span class="keyword">&amp; </span><span class="default">$d</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$b </span><span class="keyword">^ </span><span class="default">$c </span><span class="keyword">^ </span><span class="default">$d</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">sha1_kt</span><span class="keyword">(</span><span class="default">$t</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$t </span><span class="keyword">&lt; </span><span class="default">20</span><span class="keyword">) return </span><span class="default">1518500249</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$t </span><span class="keyword">&lt; </span><span class="default">40</span><span class="keyword">) return </span><span class="default">1859775393</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$t </span><span class="keyword">&lt; </span><span class="default">60</span><span class="keyword">) return -</span><span class="default">1894007588</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return -</span><span class="default">899497514</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$raw_output</span><span class="keyword">=</span><span class="default">FALSE</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if ( </span><span class="default">$raw_output </span><span class="keyword">=== </span><span class="default">TRUE </span><span class="keyword">) return </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">, </span><span class="default">sha1</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">FALSE</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$x </span><span class="keyword">= </span><span class="default">sha1_str2blks_SHA1</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">=&nbsp; </span><span class="default">1732584193</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$b </span><span class="keyword">= -</span><span class="default">271733879</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$c </span><span class="keyword">= -</span><span class="default">1732584194</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$d </span><span class="keyword">=&nbsp; </span><span class="default">271733878</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">= -</span><span class="default">1009589776</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$x_count </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$x</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$x_count</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">16</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$olda </span><span class="keyword">= </span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldb </span><span class="keyword">= </span><span class="default">$b</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldc </span><span class="keyword">= </span><span class="default">$c</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$oldd </span><span class="keyword">= </span><span class="default">$d</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$olde </span><span class="keyword">= </span><span class="default">$e</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for (</span><span class="default">$j </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$j </span><span class="keyword">&lt; </span><span class="default">80</span><span class="keyword">; </span><span class="default">$j</span><span class="keyword">++)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$w</span><span class="keyword">[</span><span class="default">$j</span><span class="keyword">] = (</span><span class="default">$j </span><span class="keyword">&lt; </span><span class="default">16</span><span class="keyword">) ? </span><span class="default">$x</span><span class="keyword">[</span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$j</span><span class="keyword">] : </span><span class="default">sha1_rol</span><span class="keyword">(</span><span class="default">$w</span><span class="keyword">[</span><span class="default">$j </span><span class="keyword">- </span><span class="default">3</span><span class="keyword">] ^ </span><span class="default">$w</span><span class="keyword">[</span><span class="default">$j </span><span class="keyword">- </span><span class="default">8</span><span class="keyword">] ^ </span><span class="default">$w</span><span class="keyword">[</span><span class="default">$j </span><span class="keyword">- </span><span class="default">14</span><span class="keyword">] ^ </span><span class="default">$w</span><span class="keyword">[</span><span class="default">$j </span><span class="keyword">- </span><span class="default">16</span><span class="keyword">], </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">sha1_rol</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">5</span><span class="keyword">), </span><span class="default">sha1_ft</span><span class="keyword">(</span><span class="default">$j</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">, </span><span class="default">$c</span><span class="keyword">, </span><span class="default">$d</span><span class="keyword">)), </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">$e</span><span class="keyword">, </span><span class="default">$w</span><span class="keyword">[</span><span class="default">$j</span><span class="keyword">]), </span><span class="default">sha1_kt</span><span class="keyword">(</span><span class="default">$j</span><span class="keyword">)));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">= </span><span class="default">$d</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$d </span><span class="keyword">= </span><span class="default">$c</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$c </span><span class="keyword">= </span><span class="default">sha1_rol</span><span class="keyword">(</span><span class="default">$b</span><span class="keyword">, </span><span class="default">30</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$b </span><span class="keyword">= </span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">$t</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$olda</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$b </span><span class="keyword">= </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">$b</span><span class="keyword">, </span><span class="default">$oldb</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$c </span><span class="keyword">= </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">, </span><span class="default">$oldc</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$d </span><span class="keyword">= </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">$d</span><span class="keyword">, </span><span class="default">$oldd</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">= </span><span class="default">sha1_safe_add</span><span class="keyword">(</span><span class="default">$e</span><span class="keyword">, </span><span class="default">$olde</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">sprintf</span><span class="keyword">(</span><span class="string">'%08x%08x%08x%08x%08x'</span><span class="keyword">, </span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">, </span><span class="default">$c</span><span class="keyword">, </span><span class="default">$d</span><span class="keyword">, </span><span class="default">$e</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47097""></a>
  <div class="note">
   <strong class="user">rsemirag at yahoo dot com</strong>
   <a href="#47097" class="date">02-Nov-2004 07:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you're struggling to generate an SHA encoded password for LDAP (PHP &lt; 5.0), what you end up needing is this:<br />
<br />
$userpassword = base64_encode(pack("H*", sha1($pass)));<br />
<br />
I found this in the OpenLDAP FAQ (many thanks to Google and Ace), though I'm using the iPlanet LDAP server.<br />
<br />
Ray Semiraglio</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="40226""></a>
  <div class="note">
   <strong class="user">brian_bisaillon at rogers dot com</strong>
   <a href="#40226" class="date">26-Feb-2004 05:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Source code to create SSHA passwords...<br />
<br />
public function HashPassword($password)<br />
{<br />
&nbsp; mt_srand((double)microtime()*1000000);<br />
&nbsp; $salt = mhash_keygen_s2k(MHASH_SHA1, $password, substr(pack('h*', md5(mt_rand())), 0, 8), 4);<br />
&nbsp; $hash = "{SSHA}".base64_encode(mhash(MHASH_SHA1, $password.$salt).$salt);<br />
&nbsp; return $hash;<br />
}<br />
<br />
Source code to validate SSHA passwords...<br />
<br />
public function ValidatePassword($password, $hash)<br />
{<br />
&nbsp; $hash = base64_decode(substr($hash, 6));<br />
&nbsp; $original_hash = substr($hash, 0, 20);<br />
&nbsp; $salt = substr($hash, 20);<br />
&nbsp; $new_hash = mhash(MHASH_SHA1, $password . $salt);<br />
&nbsp;&nbsp; if (strcmp($original_hash, $new_hash) == 0)<br />
&nbsp;&nbsp; &nbsp; ... do something because your password is valid ...<br />
&nbsp; else<br />
&nbsp;&nbsp;&nbsp; echo 'Unauthorized: Authorization has been refused for the credentials you provided. Please login with a valid username and password.';<br />
&nbsp;&nbsp;&nbsp; ... be sure to clear your session data ...<br />
}<br />
<br />
Note: The format is compatible with OpenLDAP's SSHA scheme if I'm not mistaken.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="39492""></a>
  <div class="note">
   <strong class="user">mark at  dot BANSPAM dot pronexus dot nl</strong>
   <a href="#39492" class="date">30-Jan-2004 03:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Looking for a simple function to implement HMAC-SHA1 but don't want to use the entire PEAR Message lib?<br />
<br />
//Calculate HMAC-SHA1 according to RFC2104<br />
// <a href="http://www.ietf.org/rfc/rfc2104.txt" rel="nofollow" target="_blank">http://www.ietf.org/rfc/rfc2104.txt</a><br />
function hmacsha1($key,$data) {<br />
&nbsp;&nbsp;&nbsp; $blocksize=64;<br />
&nbsp;&nbsp;&nbsp; $hashfunc='sha1';<br />
&nbsp;&nbsp;&nbsp; if (strlen($key)&gt;$blocksize)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $key=pack('H*', $hashfunc($key));<br />
&nbsp;&nbsp;&nbsp; $key=str_pad($key,$blocksize,chr(0x00));<br />
&nbsp;&nbsp;&nbsp; $ipad=str_repeat(chr(0x36),$blocksize);<br />
&nbsp;&nbsp;&nbsp; $opad=str_repeat(chr(0x5c),$blocksize);<br />
&nbsp;&nbsp;&nbsp; $hmac = pack(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 'H*',$hashfunc(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ($key^$opad).pack(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 'H*',$hashfunc(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ($key^$ipad).$data<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; );<br />
&nbsp;&nbsp;&nbsp; return bin2hex($hmac);<br />
}<br />
<br />
It is very useful for client-authentication. see also <a href="http://cookies.lcs.mit.edu/pubs/webauth:tr.pdf" rel="nofollow" target="_blank">http://cookies.lcs.mit.edu/pubs/webauth:tr.pdf</a><br />
Optionally you can change $hashfunc to 'md5' to make this an HMAC-MD5 function ;-)<br />
If you want raw or base64 output instead of hexadecimal, just change the last return line.<br />
<br />
Cheers,<br />
Mark<br />
<br />
p.s. the "$hmac =" line used to be 1 line but I had to cut it up in order to fit it here ;)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37442""></a>
  <div class="note">
   <strong class="user">labarks</strong>
   <a href="#37442" class="date">15-Nov-2003 12:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Append this to the your sha1lib file to make it more portable.&nbsp; If your version of php does support sha1() then it will try to use Mhash or else it will use the sha1lib.&nbsp; Use $sha1 if you want to display which is being used.<br />
<br />
if ( function_exists('sha1') )<br />
&nbsp;&nbsp;&nbsp; $sha1 = "sha1";<br />
<br />
if ( !function_exists('sha1') &amp;&amp; function_exists('mhash'))<br />
{<br />
&nbsp;&nbsp;&nbsp; function sha1($hash_source) <br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $hash = mhash(MHASH_SHA1, $hash_source);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $hex_hash = bin2hex($hash);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $hex_hash;<br />
&nbsp;&nbsp;&nbsp; } <br />
&nbsp;&nbsp;&nbsp; $sha1 = "Mhash";<br />
}<br />
if ( !function_exists('sha1') &amp;&amp; !function_exists('mhash'))<br />
{<br />
&nbsp;&nbsp;&nbsp; function sha1( $string, $raw_output = false )<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $library = new Sha1Lib();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $raw_output ? $library-&gt;str_sha1($string) : $library-&gt;hex_sha1($string);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; $sha1 = "sha1lib";<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31479""></a>
  <div class="note">
   <strong class="user">bobm at hp dot com</strong>
   <a href="#31479" class="date">23-Apr-2003 06:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To achieve raw binary format prior to PHP5, you can do this...<br />
<br />
$raw = pack("H*", sha1($str));<br />
<br />
Regards,<br />
<br />
Bob Mader</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
