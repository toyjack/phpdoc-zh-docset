<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>建立字符数据处理器</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.xml-parser-set-option.html">? xml_parser_set_option</a></li>
      <li style="float: right;"><a href="function.xml-set-default-handler.html">xml_set_default_handler ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.xml.html">XML 解析器函数</a></li>
    <li>建立字符数据处理器</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.xml-set-character-data-handler" class="refentry">
   <div class="refnamediv">
    <h1 class="refname">xml_set_character_data_handler</h1>
    <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">xml_set_character_data_handler</span> &mdash; <span class="dc-title">建立字符数据处理器</span></p>

   </div>
   
 <div class="refsect1 description" id="refsect1-function.xml-set-character-data-handler-description">
  <h3 class="title">说明</h3>
    <div class="methodsynopsis dc-description">
     <span class="type">bool</span> <span class="methodname"><strong>xml_set_character_data_handler</strong></span>
      ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$parser</code></span>
   , <span class="methodparam"><span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span> <code class="parameter">$handler</code></span>
     )</div>

    <p class="para rdfs-comment">
     为 <code class="parameter">parser</code> 变量指向的 XML 解析器指定字符数据处理函数。
    </p>
   </div>


 <div class="refsect1 parameters" id="refsect1-function.xml-set-character-data-handler-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">parser</code></dt>

     <dd>

      <p class="para">
       XML 解析器的引用，用于建立字符数据处理器。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">handler</code></dt>

     <dd>

      <p class="para">
       <code class="parameter">handler</code> 为表示一个函数名称的字符串，该函数必须在为 <code class="parameter">parser</code> 指定的解析器调用 <span class="function"><a href="function.xml-parse.html" class="function">xml_parse()</a></span> 函数时已存在。
      </p>
      <p class="para">
        由 <code class="parameter">handler</code> 参数命名的函数名必须接受两个参数：
       <div class="methodsynopsis dc-description">
        <span class="methodname"><span class="replaceable">handler</span></span>
         ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$parser</code></span>
        , <span class="methodparam"><span class="type">string</span> <code class="parameter">$data</code></span>
        )</div>

       <dl>

        
         <dt>
<code class="parameter">parser</code></dt>

         <dd>

          <span class="simpara">
            第一个参数 <span class="replaceable">parser</span> 为指向要调用处理器的 XML 解析器的指针。
          </span>
         </dd>

        
        
         <dt>
<code class="parameter">data</code></dt>

         <dd>

          <span class="simpara">
           第二个参数 <code class="parameter">data</code> 为包含有字符数据的字符串。
          </span>
         </dd>

        
       </dl>

      </p>
      <p class="para">
       Character data handler is called for every piece of a text in the XML
       document. It can be called multiple times inside each fragment (e.g.
       for non-ASCII strings).
      </p>
      <p class="para">
       如果处理器函数名被设置为空字符串或者 <strong><code>FALSE</code></strong>，则该有问题的处理器将被屏蔽。
      </p>
      <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara">除了函数名，含有对象引用的数组和方法名也可以作为参数。</span></p></blockquote>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.xml-set-character-data-handler-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   成功时返回 <strong><code>TRUE</code></strong>， 或者在失败时返回 <strong><code>FALSE</code></strong>。
  </p>
 </div>

  </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="100335""></a>
  <div class="note">
   <strong class="user">svanegmond at tinyplanet dot ca</strong>
   <a href="#100335" class="date">08-Oct-2010 09:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For those who are having their character entities eaten by this function (e.g. &amp;amp; &amp;lt; and so forth):
<br />

<br />
You will notice that your callback gets called several times.
<br />

<br />
input: Give me some beans &amp;amp; rice. &amp;#032;
<br />

<br />
call 1: Give me some beans
<br />
call 2: amp; and rice
<br />
call 3: #032;
<br />

<br />
There is an obvious workaround. This is not perfect:
<br />

<br />
<span class="default">&lt;?php
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $text </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/^([a-z]+;)/'</span><span class="keyword">,</span><span class="string">'&amp;\1'</span><span class="keyword">, </span><span class="default">$text</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$text </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/^(#[0-9]+;)/'</span><span class="keyword">, </span><span class="string">'&amp;\1'</span><span class="keyword">, </span><span class="default">$text</span><span class="keyword">);
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85415""></a>
  <div class="note">
   <strong class="user">jhill at live dot com</strong>
   <a href="#85415" class="date">29-Aug-2008 04:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To detect that concatenation of data is taking place, you can keep track of whether the last function call was to the data processing function.
<br />
e.g. using $this-&gt;inside_data variable below:
<br />

<br />
<span class="default">&lt;?php
<br />
xml_set_element_handler</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">parser</span><span class="keyword">, </span><span class="string">"start_tag"</span><span class="keyword">, </span><span class="string">"end_tag"</span><span class="keyword">);
<br />
</span><span class="default">xml_set_character_data_handler</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">parser</span><span class="keyword">, </span><span class="string">"contents"</span><span class="keyword">);
<br />

<br />
protected function </span><span class="default">contents</span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; switch (</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">current_tag</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"name"</span><span class="keyword">:
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">.= </span><span class="default">$data</span><span class="keyword">; </span><span class="comment">// need to concatenate data
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">else
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ...
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data </span><span class="keyword">= </span><span class="default">true</span><span class="keyword">;
<br />
}
<br />

<br />
protected function </span><span class="default">start_tag</span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$name</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">current_tag </span><span class="keyword">= </span><span class="default">$name</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;
<br />
}
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 
<br />
protected function </span><span class="default">end_tag</span><span class="keyword">() {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">current_tag </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60326""></a>
  <div class="note">
   <strong class="user">unspammable-iain at iaindooley dot com</strong>
   <a href="#60326" class="date">03-Jan-2006 10:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
re: jason at omegavortex dot com below, another way to deal with whitespace issues is:<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function charData($parser,$data)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $char_data = trim($data);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if($char_data)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $char_data = preg_replace('/&nbsp; */',' ',$data);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $this-&gt;cdata .= $char_data;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
This means that:<br />
<br />
&nbsp;&nbsp;&nbsp; &lt;p&gt;here is my text &lt;a href="something"&gt;my text&lt;/a&gt; <br />
&nbsp;&nbsp;&nbsp; and here is some more after some spaces at the<br />
&nbsp;&nbsp;&nbsp; beginning of the line&lt;/p&gt;<br />
<br />
comes out properly. You could do further replacements if you want to deal with tabs in your files. i only ever use spaces. if you only use trim() then you would lose the space before the &lt;a&gt; tag above, but trim() is a good way to check for completely empty char data, then just replace more than one space with a single space. this will preserve a single space at the beginning and end of the cdata.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59446""></a>
  <div class="note">
   <strong class="user">jason at omegavortex dot com</strong>
   <a href="#59446" class="date">07-Dec-2005 08:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I don't believe the problem has been addressed, but if you're parsing an XML file and run into the line break (or tab) problem I believe this function may help:<br />
<br />
if (!preg_match("/((\r|)\n)/i", $data) || preg_match("/\\t+/i", $data)) {<br />
(Code Here)<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56067""></a>
  <div class="note">
   <strong class="user">wako057 at gmx dot fr</strong>
   <a href="#56067" class="date">22-Aug-2005 06:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
That give an example about the note.<br />
When you are creating a class and you need to use a method of your class to the function xml_set_character_data_handler that is the way to point give the method:<br />
<br />
class example<br />
{<br />
&nbsp;&nbsp; function example()<br />
&nbsp;&nbsp; {<br />
&nbsp;&nbsp; }<br />
<br />
&nbsp; function data($parseur, $texte)<br />
&nbsp; {<br />
&nbsp;&nbsp; &nbsp;&nbsp; switch ($this-&gt;derniereBaliseRencontree) <br />
&nbsp;&nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; case "TITLE":<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -----<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; case "LINK"<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -----<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case "DESCRIPTION":<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -----<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; }<br />
&nbsp; }<br />
<br />
&nbsp; function fetchOpen($parseur, $nomBalise, $tableauAttributs)<br />
&nbsp; {<br />
&nbsp;&nbsp; &nbsp; ----------------<br />
&nbsp; }<br />
<br />
&nbsp; function fetchClose($parseur, $nomBalise)<br />
&nbsp; {<br />
&nbsp;&nbsp; &nbsp; ----------------<br />
&nbsp; }<br />
<br />
&nbsp; function ZZZ()<br />
&nbsp; {<br />
&nbsp;&nbsp; &nbsp;&nbsp; $parseurXML = xml_parser_create();<br />
&nbsp;&nbsp; &nbsp; &nbsp; xml_set_element_handler($parseurXML, Array(&amp;$this, 'fetchOpen'),&nbsp;&nbsp; Array(&amp;$this, 'fetchClose'));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ---------------- &lt;IMPORTANT&gt; --------------------------<br />
&nbsp;&nbsp; &nbsp; &nbsp; xml_set_character_data_handler($parseurXML, Array(&amp;$this, 'data'));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ---------------- &lt;/IMPORTANT&gt; --------------------------<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55527""></a>
  <div class="note">
   <strong class="user">ben at removethis emediastudios dotcom</strong>
   <a href="#55527" class="date">06-Aug-2005 12:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I too love the undocumented "splitting" functionality :-p.<br />
<br />
Rather than concatinating the data based on whether or not the current tag name has changed from the previous tag name I suggest always concatinating like the following with the $catData variable being unset in the endElement function:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">endElement </span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp; global </span><span class="default">$catData</span><span class="keyword">;<br />
<br />
&nbsp; </span><span class="comment">// Because we are at an element end we know any splitting is finished<br />
&nbsp; </span><span class="keyword">unset(</span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="string">'catData'</span><span class="keyword">]);<br />
}<br />
<br />
function </span><span class="default">characterData </span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp; global </span><span class="default">$catData</span><span class="keyword">;<br />
<br />
&nbsp; </span><span class="comment">// Concatinate data in case splitting is taking place<br />
&nbsp; </span><span class="default">$catData</span><span class="keyword">.=</span><span class="default">$data</span><span class="keyword">;<br />
<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
This got me around a problem with data like the following where, because characterData is not called for empty tags, the previous and current tag names were the same even though splitting was not taking place.<br />
<br />
&lt;companydept&gt;<br />
&lt;companydeptID&gt;&lt;/companydeptID&gt;<br />
&lt;companyID&gt;1&lt;/companyID&gt;<br />
&lt;companydeptName&gt;&lt;/companydeptName&gt;<br />
&lt;/companydept&gt;<br />
&lt;companydept&gt;<br />
&lt;companydeptID&gt;&lt;/companydeptID&gt;<br />
&lt;companyID&gt;2&lt;/companyID&gt;<br />
&lt;companydeptName&gt;&lt;/companydeptName&gt;<br />
&lt;/companydept&gt;<br />
&lt;companydept&gt;<br />
&lt;companydeptID&gt;&lt;/companydeptID&gt;<br />
&lt;companyID&gt;3&lt;/companyID&gt;<br />
&lt;companydeptName&gt;&lt;/companydeptName&gt;<br />
&lt;/companydept&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52233""></a>
  <div class="note">
   <strong class="user">yaroukh at email dot cz</strong>
   <a href="#52233" class="date">25-Apr-2005 05:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It would be nice if someone could complete documentation of this function. I think that the "splitting" behaviour should (at least) be mentioned within the documentation, if not explained (please!). I'm not quite sure whether the cut comes after each 1024bytes/chars of data.<br />
<br />
My experience looks as follows:<br />
[xmlFile]<br />
...<br />
&nbsp;&nbsp;&nbsp; &lt;label&gt;slo|?ka&lt;/label&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;comment&gt;koment|?&amp;#345; slo?ky&lt;/comment&gt;<br />
...<br />
[/xmlFile]<br />
(Places where the character-data got splitted are marked with pipes. Plus there was latin small letter 'r' with caron instead of &amp;#345;.)<br />
<br />
Since the splitting is not mentioned in documentation one could assume that it is a bug; especially when you work with UTF-8 and the cuts come right before some special characters.<br />
(Should the concatenating of $cData be considered to be the proper &amp; 'final' way of processing character-data?)<br />
<br />
Also I'd suggest to add another line in "Description" when fc has an alternate usage (instead of hiding it within the "Note" :o); in this particular case I'd prefer this:<br />
<br />
Description:<br />
bool xml_set_character_data_handler ( resource parser, callback handler )<br />
bool xml_set_character_data_handler ( resource parser, object reference, method name )<br />
<br />
... there are dozens of functions ofcourse where documentation works this way (I mean not mentioning the alternate usage in the "Description" part).<br />
<br />
Have a nice day<br />
&nbsp; Yaroukh</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49943""></a>
  <div class="note">
   <strong class="user">flobee</strong>
   <a href="#49943" class="date">13-Feb-2005 06:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
re. to Philippe Marc , and&nbsp; karuna_gadde examples<br />
<br />
i found out that the xml_set_character_data_handler call back&nbsp; function can be called more often for the same element in particular the content is just a few chars long (happen on windows)<br />
<br />
so a check up can give you the answer an may be for long strings too.<br />
eg:<br />
<span class="default">&lt;?php<br />
xml_set_character_data_handler</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">parser</span><span class="keyword">, </span><span class="string">"cdata"</span><span class="keyword">);<br />
</span><span class="comment">//...<br />
</span><span class="keyword">function </span><span class="default">cdata</span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$cdata</span><span class="keyword">) {<br />
</span><span class="comment">// ...<br />
</span><span class="keyword">if(isset(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">data</span><span class="keyword">[</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentItem</span><span class="keyword">][</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentField</span><span class="keyword">])) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">data</span><span class="keyword">[</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentItem</span><span class="keyword">][</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentField</span><span class="keyword">] .= </span><span class="default">$cdata</span><span class="keyword">;<br />
} else {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">data</span><span class="keyword">[</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentItem</span><span class="keyword">][</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentField</span><span class="keyword">] = </span><span class="default">$cdata</span><span class="keyword">;<br />
}&nbsp; &nbsp; &nbsp; <br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46948""></a>
  <div class="note">
   <strong class="user">Philippe Marc</strong>
   <a href="#46948" class="date">28-Oct-2004 04:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
How to overide the 1024 characters limitation of xml_set_character_data_handler.<br />
Took me some time to find out how to deal with that!<br />
<br />
When calling a basic XML parser: <br />
$parseurXML = xml_parser_create();<br />
xml_set_element_handler($parseurXML, "opentagfunction", "closetagfunction");<br />
xml_set_character_data_handler($parseurXML, "textfunction");<br />
<br />
The textfunction only receive 1024 characters at once, even if the text is 4000 characters long. In facts, the parser seems to split the data in pieces of 1024 characters. The way to handle that is to concatenate them.<br />
<br />
example:<br />
If you have an XML tag called UNIPROT_ABSTRACT containing a 4000 characters protein description:<br />
function textfunction($parser, $text)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; if ($last_tag_read=='UNIPROT_ABSTRACT') $uniprot.=$text;<br />
&nbsp;&nbsp;&nbsp; }<br />
The function is called 4 times and receives 1024+1024+1024+928 characters that will be concatenated in the $uniprot variable using the ".=" concatenation fonction.<br />
<br />
Easy to do, but not documented!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43992""></a>
  <div class="note">
   <strong class="user">Brad dot Harrison at griffith dot edu dot au</strong>
   <a href="#43992" class="date">12-Jul-2004 07:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need to trim the white space for HTML code and don't rely on spaces for formatting text (if you are then it is time to use Style Sheets) then this code will come in very useful.<br />
<br />
&nbsp;$data=eregi_replace("&gt;"."[[:space:]]+"."&lt;","&gt;&lt;",$data);<br />
&nbsp;$data=eregi_replace("&gt;"."[[:space:]]+","&gt;",$data);<br />
&nbsp;$data=eregi_replace("[[:space:]]+"."&lt;","&lt;",$data);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42729""></a>
  <div class="note">
   <strong class="user">karuna_gadde at yahoo dot com</strong>
   <a href="#42729" class="date">27-May-2004 04:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
&lt;?<br />
class Parser {<br />
<br />
var $att;<br />
var $id;<br />
var $title;<br />
var $content;<br />
var $index=-1;<br />
var $xml_parser;<br />
var $tagname;<br />
<br />
function parser()<br />
{<br />
$file = "data.xml";<br />
$this-&gt;xml_parser = xml_parser_create();<br />
xml_set_object($this-&gt;xml_parser,$this);<br />
xml_set_element_handler($this-&gt;xml_parser, "startElement", "endElement");<br />
xml_set_character_data_handler($this-&gt;xml_parser, 'elementContent');<br />
if (!($fp = fopen($file, "r"))) {<br />
die("could not open XML input");<br />
}<br />
<br />
while ($data = fread($fp, 4096)) {<br />
&nbsp;&nbsp;&nbsp; $data=eregi_replace("&gt;"."[[:space:]]+"."&lt;","&gt;&lt;",$data);<br />
if (!xml_parse($this-&gt;xml_parser, $data, feof($fp))) {<br />
die(sprintf("XML error: %s at line %d",<br />
xml_error_string(xml_get_error_code($this-&gt;xml_parser)),<br />
xml_get_current_line_number($this-&gt;xml_parser)));<br />
}<br />
}<br />
xml_parser_free($this-&gt;xml_parser);<br />
}<br />
<br />
function startElement($parser, $name, $attrs) {<br />
if (($name=="TREE") or ($name=="NODE") or ($name=="LEAFNODE"))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;index++;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;att[$this-&gt;index]=$name;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; $this-&gt;tagname=$name;<br />
}<br />
<br />
function elementContent($parser, $data) {<br />
switch ($this-&gt;tagname)<br />
{<br />
&nbsp;&nbsp; &nbsp; case 'ID':<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;id[$this-&gt;index]=trim($data);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />
&nbsp;&nbsp; &nbsp; case 'TITLE' :<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;title[$this-&gt;index]=trim($data);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //echo $data;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />
&nbsp;&nbsp; &nbsp; case 'CONTENT'&nbsp; &nbsp; :<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;content[$this-&gt;index]=trim($data);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
}<br />
}<br />
function endElement($parser, $name){<br />
$this-&gt;tagname=="";<br />
}<br />
}<br />
?&gt;<br />
<br />
I thought this class is more help full to know about xml_parser with no white spaces</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="40475""></a>
  <div class="note">
   <strong class="user">michael dot stilson at wmich dot edu</strong>
   <a href="#40475" class="date">04-Mar-2004 09:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hello,<br />
<br />
This is an addition to the note posted by:<br />
wiart at yahoo dot com<br />
22-Aug-2003 05:31<br />
Which is located below.<br />
<br />
I had similar problems manually creating XML docs and adding new-lines within my node data, e.g.<br />
<br />
&lt;root&gt;<br />
&nbsp;&nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; &lt;node attribute="something"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Here is some data. There is a lot of data, and I want to<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; be able to read the data from a terminal window, so I add<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; newlines to fit everything within 80 columns.<br />
&nbsp;&nbsp;&nbsp; &lt;/node&gt;<br />
&nbsp;&nbsp;&nbsp; ...<br />
&lt;/root&gt;<br />
<br />
So, given the above example, my data handler gets called 3 times and the result left in my variable is:<br />
<br />
"newlines to fit everything within 80 columns."<br />
<br />
Instead of all of the data within "node", which I was expecting.<br />
<br />
By using the concatenation operator; however, as suggested by the mentioned note, I was able to get what I needed. Which is of course:<br />
<br />
"Here is some data. There is a lot of data, and I want to be able to read the data from a terminal window, so I add newlines to fit everything within 80 columns."</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37902""></a>
  <div class="note">
   <strong class="user">dan30odd08 at hotmail dot com</strong>
   <a href="#37902" class="date">02-Dec-2003 01:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I just want to mention that i ran into a problem when parsing an xml file using the character data handler. If you happen to have a string which is also an internal php function stored in your xml data file and you want to output it as a string the parser dosent seem to recognize it.<br />
&nbsp;&nbsp; I found a way around this problem. In my case i was storing a string with the value read. This would not allow me to output the data so to work around this problem i added a backslash for every character in the data element.<br />
<br />
&nbsp;&nbsp; e.g.&nbsp; &nbsp; &nbsp; &lt;xml&gt;<br />
&nbsp;&nbsp;&nbsp; from&nbsp; &nbsp; &lt;element&gt;read&lt;/element&gt;<br />
&nbsp;&nbsp;&nbsp; to&nbsp; &nbsp; &nbsp;&nbsp; &lt;element&gt;////read&lt;/element&gt;<br />
<br />
i dont know if anyone has ran into this problem or not but i thought i would just put it here just so in case someone is getting stuck with this.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35177""></a>
  <div class="note">
   <strong class="user">wiart at yahoo dot com</strong>
   <a href="#35177" class="date">22-Aug-2003 02:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
WARNING !!!<br />
Always use concatenation for getting the content of a XML tag when you write the function that will deal with the Character Data handling<br />
<br />
Example:<br />
&nbsp;<br />
$mycontent = '';<br />
$xml_parser = xml_parser_create ();<br />
xml_set_character_data_handler($xml_parser, "_characterdata");<br />
<br />
function _characterdata($parser, $data){<br />
&nbsp; global $mycontent;<br />
&nbsp; //HERE: use .= and not = <br />
&nbsp; $mycontent .= $data;<br />
}<br />
<br />
...<br />
<br />
while ($data = fread($fp, 4096)) {<br />
&nbsp;&nbsp;&nbsp; xml_parse($xml_parser, $data, feof($fp));<br />
}<br />
<br />
I had the following problem with the use of '=$data' :<br />
<br />
In one of my XML documents, the parsing stopped in the middle of a character data :<br />
<br />
In original document:<br />
&lt;prop name="nbres"&gt;100&lt;/prop&gt;<br />
<br />
What happened:<br />
&lt;prop name="nbres"&gt;10[parsing stopped here in chunck of 4096bytes]0&lt;/prop&gt;<br />
<br />
As I did not use the concatenation, when I displayed the value of the 'nbres' property, the value was 0 instead of 100 because the first time the function characterdata was called :<br />
$mycontent = 10;<br />
<br />
and the second time:<br />
$mycontent = 0;&nbsp; &nbsp; &nbsp; //!!!!!!!!!!!!! HO HO !! some problem occured ...<br />
<br />
Instead of $mycontent = 100;&nbsp; &nbsp; <br />
<br />
CONCLUSION:<br />
IN YOUR CHARACTER DATA HANDLER FUNCTIONS, NEVER FORGET THE . (concatenation operator) !!!!! IF YOU DON'T WANT TO HAVE WEIRD BUGS SOME TIMES</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35065""></a>
  <div class="note">
   <strong class="user">morris_hirsch at hotmail dot com</strong>
   <a href="#35065" class="date">18-Aug-2003 06:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Thanks to Christian Stocker for clearing up my entity issues,&nbsp; where some entities are parsed correctly and others not.<br />
<br />
The problem is the ''wide'' entities that have a large numeric code simply can not fit in a single byte, which is the default encoding for both source input to the parser and data output from the parser.&nbsp; So the parser puts out a ''?'' to say it could not store the code value. One could argue that if the input has a &amp;1234; the output should simply copy it as &amp;1234; instead of the ''?'' but that would still mean the&nbsp; parser behaves two different ways according to the code values, and anyway they don't do it.<br />
<br />
So, we need utf8 encoding for the output, and the slightly not obvious way to say so is<br />
<br />
&nbsp; $xml_parser = xml_parser_create ("UTF-8");<br />
<br />
which means BOTH source input and data output are utf8.<br />
Remember that utf8 is a superset of basic ASCII but not of extended ASCII, so your input can contain e.g. &amp;eacute;<br />
spelled out, but a native eacute character is wrong here.<br />
Just utf8_encode your input to be sure.<br />
<br />
That should do it, and thanks again for the help.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="34786""></a>
  <div class="note">
   <strong class="user">morris_hirsch at hotmail dot com</strong>
   <a href="#34786" class="date">06-Aug-2003 09:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here are two ways to deal with named entities in the XML.<br />
<br />
1. Put a list of named entities at the front so the parser knows what they all mean<br />
<br />
&nbsp; $decl = '&lt;!DOCTYPE rootname [<br />
<br />
&lt;!ENTITY frac12&nbsp; "&amp;#x00BD;" &gt;<br />
&lt;!ENTITY frac14&nbsp; "&amp;#x00BC;" &gt;<br />
&lt;!ENTITY frac34&nbsp; "&amp;#x00BE;" &gt;<br />
&lt;!ENTITY frac18&nbsp; "&amp;#x215B;" &gt;<br />
&lt;!ENTITY frac38&nbsp; "&amp;#x215C;" &gt;<br />
&lt;!ENTITY frac58&nbsp; "&amp;#x215D;" &gt;<br />
&lt;!ENTITY frac78&nbsp; "&amp;#x215E;" &gt;<br />
&lt;!ENTITY frac13&nbsp; "&amp;#x2153;" &gt;<br />
&lt;!ENTITY frac23&nbsp; "&amp;#x2154;" &gt;<br />
&lt;!ENTITY frac15&nbsp; "&amp;#x2155;" &gt;<br />
&lt;!ENTITY frac25&nbsp; "&amp;#x2156;" &gt;<br />
&lt;!ENTITY frac35&nbsp; "&amp;#x2157;" &gt;<br />
&lt;!ENTITY frac45&nbsp; "&amp;#x2158;" &gt;<br />
&lt;!ENTITY frac16&nbsp; "&amp;#x2159;" &gt;<br />
&lt;!ENTITY frac56&nbsp; "&amp;#x215A;" &gt;<br />
<br />
&lt;!ENTITY mdash&nbsp; "&amp;#x2014;" &gt;<br />
<br />
&nbsp;..... lots of others<br />
<br />
&lt;!ENTITY uuml&nbsp; &nbsp; "&amp;#252;" &gt;<br />
&lt;!ENTITY yacute&nbsp; "&amp;#253;" &gt;<br />
&lt;!ENTITY thorn&nbsp;&nbsp; "&amp;#254;" &gt;<br />
&lt;!ENTITY yuml&nbsp; &nbsp; "&amp;#255;" &gt;<br />
<br />
]&gt;';<br />
<br />
$parseThis = $decl . "&lt;rootname&gt; ..... &lt;/rootname&gt;";<br />
<br />
This works fine for all the single-byte (European) codes,<br />
but not the wide codes like emdash or frac18.<br />
They seem to be trashed when the character data handler gets them.&nbsp; They all echo as "?"<br />
<br />
There may be a way to make them work, but until I find it,<br />
or a newer release takes care of it, here is a work-around that does work.<br />
<br />
2. Rewrite every ampersand as &amp;amp; in the input stream<br />
<br />
&nbsp;$ampXML = str_replace ("&amp;", "&amp;amp;", $sourceXML);<br />
<br />
Now the parser will see &amp;amp;foo; instead of &amp;foo;<br />
<br />
It does not try to decode it, so wide (two byte) values are not a problem, and no list of names is needed.<br />
<br />
When you write that to your output you have &amp;foo;<br />
<br />
which is usually fine for the next stage of your process.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="32204""></a>
  <div class="note">
   <strong class="user">www.PhoC.de</strong>
   <a href="#32204" class="date">20-May-2003 04:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In some cases it's better to avoid storing data which is not needed. In these cases the function <br />
<br />
chop()&nbsp; ( =&gt; Alias of function rtrim() )<br />
<br />
could be usefull to prevent data like<br />
<br />
"\t"<br />
"\r"<br />
"\o"<br />
"\n"<br />
"\x0B"<br />
" "<br />
<br />
to be stored in a array or a string or something like this.<br />
<br />
Example: (storing data in a string)<br />
________________<br />
$filename="xyz.xml";<br />
<br />
if(!($fp=fopen($filename,"r"))){<br />
&nbsp;&nbsp; die("Cannot open $filename ");<br />
}<br />
<br />
while (!feof($fp)) <br />
{<br />
&nbsp;&nbsp; $data .= chop(fgets($fp, 4096));<br />
}<br />
<br />
fclose($fp);<br />
________________<br />
<br />
Have a look at the documentation of rtrim() <a href="http://www.php.net/manual/en/function.rtrim.php." rel="nofollow" target="_blank">http://www.php.net/manual/en/function.rtrim.php.</a><br />
<br />
Greetz<br />
PhoC</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19659""></a>
  <div class="note">
   <strong class="user">waldo at wh-e dot com</strong>
   <a href="#19659" class="date">07-Mar-2002 06:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a way to strip all the spaces between tags in an xml document.<br />
<br />
//strip white space between tags<br />
$data=eregi_replace("&gt;"."[[:space:]]+"."&lt;","&gt;&lt;",$data);<br />
<br />
So this:<br />
<br />
&lt;house&gt;<br />
&nbsp; &lt;garage&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;car&gt;Waldo&lt;/car&gt;<br />
&nbsp; &lt;/garage&gt;<br />
&lt;/house&gt;<br />
<br />
would be changed to:<br />
<br />
&lt;house&gt;&lt;garage&gt;&lt;car&gt;Waldo&lt;/car&gt;&lt;/garage&gt;&lt;/house&gt;<br />
<br />
It was useful to me. Maybe you too?</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="18609""></a>
  <div class="note">
   <strong class="user">ken at positive-edge dot com</strong>
   <a href="#18609" class="date">29-Jan-2002 05:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
the function handler is called several times when it parses the character data.&nbsp; It doesn't return the entire string as it suggests.&nbsp; There are special exceptions that will always force the parser to stop scanning and call the character data handler.&nbsp; This is when:<br />
<br />
- The parser runs into an Entity Declaration, such as &amp;amp; (&amp;) or &amp;apos; (?)<br />
- The parser finishes parsing an entity<br />
- The parser runs into the new-line character (\n)<br />
- The parser runs into a series of tab characters (\t)<br />
<br />
And perhaps others.<br />
<br />
For instance, if we have this xml content:<br />
<br />
&lt;mytag name=?Ken Egervari? title=?Chief Technology Officer?&gt;<br />
&nbsp;&nbsp;&nbsp; Ken has been Positive Edge&amp;apos;s Chief Technology Officer for 2 years.<br />
&lt;/mytag&gt;<br />
<br />
The parser will call the character data handler 6 times.&nbsp; This is what will happen:<br />
<br />
1&nbsp; &nbsp; \n<br />
2&nbsp; &nbsp; \t<br />
3&nbsp; &nbsp; Ken has been Positive Edge<br />
4&nbsp; &nbsp; ?<br />
5&nbsp; &nbsp; s Chief Technology Officer for 2 years.<br />
6&nbsp; &nbsp; \n<br />
<br />
I hope that helps people out.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="16301""></a>
  <div class="note">
   <strong class="user">mogmios at mlug dot missouri dot edu</strong>
   <a href="#16301" class="date">24-Oct-2001 01:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to strip unwanted whitespace in an HTML-like manner then there are two steps.
<br />

<br />
The first you need to strip consecutive whitespaces from all you input data like this:&nbsp; $data = eregi_replace ( "[[:space:]]+", " ", $data );
<br />

<br />
Then in your cdata handler make a check to see if it's blank space. An easy way is like this: if ( trim ( $cdata ) ) { work on cdata }
<br />

<br />
That should take care of any whitespace issues you might have.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="14552""></a>
  <div class="note">
   <strong class="user">annies at cs dot tu-berlin dot de</strong>
   <a href="#14552" class="date">03-Aug-2001 07:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The maximum size of the second parmeter $data seems to be 1024. Is there more character data&nbsp; in the XML text the handler is called again immediately with the next portion.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
