<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>Prepares a statement for execution and returns a statement object</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="pdo.lastinsertid.html">? PDO::lastInsertId</a></li>
      <li style="float: right;"><a href="pdo.query.html">PDO::query ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="class.pdo.html">PDO</a></li>
    <li>Prepares a statement for execution and returns a statement object</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="pdo.prepare" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">PDO::prepare</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.1.0, PHP 7, PECL pdo &gt;= 0.1.0)</p><p class="refpurpose"><span class="refname">PDO::prepare</span> &mdash; <span class="dc-title">
   Prepares a statement for execution and returns a statement object
  </span></p>

 </div>
 <div class="refsect1 description" id="refsect1-pdo.prepare-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="modifier">public</span> <span class="type"><a href="class.pdostatement.html" class="type PDOStatement">PDOStatement</a></span> <span class="methodname"><strong>PDO::prepare</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$statement</code></span>
   [, <span class="methodparam"><span class="type">array</span> <code class="parameter">$driver_options</code><span class="initializer"> = array()</span></span>
  ] )</div>


  <p class="para rdfs-comment">
   Prepares an SQL statement to be executed by the
   <span class="function"><a href="pdostatement.execute.html" class="function">PDOStatement::execute()</a></span> method. The SQL statement can
   contain zero or more named (:name) or question mark (?) parameter markers
   for which real values will be substituted when the statement is executed.
   You cannot use both named and question mark parameter markers within the same
   SQL statement; pick one or the other parameter style.
   Use these parameters to bind any user-input, do not include the user-input
   directly in the query.
  </p>
  <p class="para">
   You must include a unique parameter marker for each value you wish to pass
   in to the statement when you call <span class="function"><a href="pdostatement.execute.html" class="function">PDOStatement::execute()</a></span>.
   You cannot use a named parameter marker of the same name more than once in a prepared
   statement, unless emulation mode is on.
  </p>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    Parameter markers can represent a complete data literal only.
    Neither part of literal, nor keyword, nor identifier, nor whatever arbitrary query 
    part can be bound using parameters. For example, you cannot bind multiple values 
    to a single parameter in the IN() clause of an SQL statement.
   </p>
  </p></blockquote>
  <p class="para">
   Calling <span class="function"><strong>PDO::prepare()</strong></span> and
   <span class="function"><a href="pdostatement.execute.html" class="function">PDOStatement::execute()</a></span> for statements that will be
   issued multiple times with different parameter values optimizes the
   performance of your application by allowing the driver to negotiate
   client and/or server side caching of the query plan and meta information,
   and helps to prevent SQL injection attacks by eliminating the need to
   manually quote the parameters.
  </p>
  <p class="para">
   PDO will emulate prepared statements/bound parameters for drivers that do
   not natively support them, and can also rewrite named or question mark
   style parameter markers to something more appropriate, if the driver
   supports one style but not the other.
  </p>
 </div>

 <div class="refsect1 parameters" id="refsect1-pdo.prepare-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">statement</code></dt>

     <dd>

      <p class="para">
       This must be a valid SQL statement template for the target database server.
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">driver_options</code></dt>

     <dd>

      <p class="para">
       This array holds one or more key=&gt;value pairs to set
       attribute values for the PDOStatement object that this method
       returns. You would most commonly use this to set the
       <em>PDO::ATTR_CURSOR</em> value to
       <em>PDO::CURSOR_SCROLL</em> to request a scrollable cursor.
       Some drivers have driver specific options that may be set at
       prepare-time.
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-pdo.prepare-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   If the database server successfully prepares the statement,
   <span class="function"><strong>PDO::prepare()</strong></span> returns a
   <a href="class.pdostatement.html" class="classname">PDOStatement</a> object.
   If the database server cannot successfully prepare the statement,
   <span class="function"><strong>PDO::prepare()</strong></span> returns <strong><code>FALSE</code></strong> or emits
   <a href="class.pdoexception.html" class="classname">PDOException</a> (depending on <a href="pdo.error-handling.html" class="link">error handling</a>).
  </p>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    Emulated prepared statements does not communicate with the database server
    so <span class="function"><strong>PDO::prepare()</strong></span> does not check the statement.
   </p>
  </p></blockquote>
 </div>


 <div class="refsect1 examples" id="refsect1-pdo.prepare-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-989"><p><strong>Example #1 Prepare an SQL statement with named parameters</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">/*&nbsp;Execute&nbsp;a&nbsp;prepared&nbsp;statement&nbsp;by&nbsp;passing&nbsp;an&nbsp;array&nbsp;of&nbsp;values&nbsp;*/<br /></span><span style="color: #0000BB">$sql&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'SELECT&nbsp;name,&nbsp;colour,&nbsp;calories<br />&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;fruit<br />&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;calories&nbsp;&lt;&nbsp;:calories&nbsp;AND&nbsp;colour&nbsp;=&nbsp;:colour'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$sth&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$dbh</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">prepare</span><span style="color: #007700">(</span><span style="color: #0000BB">$sql</span><span style="color: #007700">,&nbsp;array(</span><span style="color: #0000BB">PDO</span><span style="color: #007700">::</span><span style="color: #0000BB">ATTR_CURSOR&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #0000BB">PDO</span><span style="color: #007700">::</span><span style="color: #0000BB">CURSOR_FWDONLY</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #DD0000">':calories'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #0000BB">150</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">':colour'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #DD0000">'red'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$red&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #DD0000">':calories'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #0000BB">175</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">':colour'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #DD0000">'yellow'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$yellow&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
   <div class="example" id="example-990">
    <p><strong>Example #2 Prepare an SQL statement with question mark parameters</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">/*&nbsp;Execute&nbsp;a&nbsp;prepared&nbsp;statement&nbsp;by&nbsp;passing&nbsp;an&nbsp;array&nbsp;of&nbsp;values&nbsp;*/<br /></span><span style="color: #0000BB">$sth&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$dbh</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">prepare</span><span style="color: #007700">(</span><span style="color: #DD0000">'SELECT&nbsp;name,&nbsp;colour,&nbsp;calories<br />&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;fruit<br />&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;calories&nbsp;&lt;&nbsp;?&nbsp;AND&nbsp;colour&nbsp;=&nbsp;?'</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #0000BB">150</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'red'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$red&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #0000BB">175</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'yellow'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$yellow&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-pdo.prepare-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="pdo.exec.html" class="function" rel="rdfs-seeAlso">PDO::exec()</a> - 执行一条 SQL 语句，并返回受影响的行数</span></li>
    <li class="member"><span class="function"><a href="pdo.query.html" class="function" rel="rdfs-seeAlso">PDO::query()</a> - Executes an SQL statement, returning a result set as a PDOStatement object</span></li>
    <li class="member"><span class="function"><a href="pdostatement.execute.html" class="function" rel="rdfs-seeAlso">PDOStatement::execute()</a> - 执行一条预处理语句</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="116859""></a>
  <div class="note">
   <strong class="user">chatelain dot cedric dot pro at gmail dot com</strong>
   <a href="#116859" class="date">11-Mar-2015 08:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
you can't use CREATE DATABASE with prepared statement.<br />
<br />
$sql = $conn-&gt;prepare("DROP DATABASE IF EXISTS :dbname ;", <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; array(PDO::ATTR_CURSOR =&gt; PDO::CURSOR_FWDONLY));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $sql-&gt;execute(array(':dbname' =&gt; $dbname));<br />
<br />
This will not work.<br />
Anyone has an explanation ?</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="116220""></a>
  <div class="note">
   <strong class="user">jesse dot chisholm at gmail dot com</strong>
   <a href="#116220" class="date">25-Nov-2014 01:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
@Simon Le Pine<br />
<br />
Be aware that:<br />
<br />
$search = "user";<br />
$sth = db-&gt;prepare("SELECT * FROM users WHERE $search=:email");<br />
<br />
and<br />
<br />
$search = "email";<br />
$sth = db-&gt;prepare("SELECT * FROM users WHERE $search=:email");<br />
<br />
will produce two totally different prepared statements.<br />
<br />
Doing this _will not work_:<br />
<br />
$search = "user";<br />
$sth = db-&gt;prepare("SELECT * FROM users WHERE $search=:email");<br />
$sth-&gt;execute(array(email=&gt;"yada"));<br />
$search = "email";<br />
$sth-&gt;execute(array(email=&gt;"yada@ya.da"));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114616""></a>
  <div class="note">
   <strong class="user">bg at enativ dot com</strong>
   <a href="#114616" class="date">13-Mar-2014 12:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if you run queries in a loop, don't include $pdo-&gt;prepare() inside the loop, it will save you some resources (and time).<br />
<br />
prepare statement inside loop:<br />
for($i=0; $i&lt;1000; $i++) {<br />
&nbsp;&nbsp;&nbsp; $rs = $pdo-&gt;prepare("SELECT `id` FROM `admins` WHERE `groupID` = :groupID AND `id` &lt;&gt; :id");<br />
&nbsp;&nbsp;&nbsp; $rs-&gt;execute([':groupID' =&gt; $group, ':id' =&gt; $id]);<br />
}<br />
<br />
// took 0.066626071929932 microseconds<br />
<br />
prepare statement outside loop:<br />
$rs = $pdo-&gt;prepare("SELECT `id` FROM `admins` WHERE `groupID` = :groupID AND `id` &lt;&gt; :id");<br />
for($i=0; $i&lt;1000; $i++) {<br />
&nbsp;&nbsp;&nbsp; $rs-&gt;execute([':groupID' =&gt; $group, ':id' =&gt; $id]);<br />
}<br />
<br />
// took 0.064448118209839 microseconds<br />
<br />
for 1,000 (simple) queries it took 0.002 microseconds less.<br />
not much, but it worth mention.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114251""></a>
  <div class="note">
   <strong class="user">pbakhuis</strong>
   <a href="#114251" class="date">30-Jan-2014 12:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Noteworthy in my opinion is that if you prepare a statement but do not bind a value to the markers it will insert null by default. e.g.<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/** @var PDO $db */<br />
</span><span class="default">$prep </span><span class="keyword">= </span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">'INSERT INTO item(title, link) VALUES(:title, :link)'</span><span class="keyword">);<br />
</span><span class="default">$prep</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span>Will attempt to insert null, null into the item table.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112626""></a>
  <div class="note">
   <strong class="user">php dot chaska at xoxy dot net</strong>
   <a href="#112626" class="date">06-Jul-2013 05:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that for Postgres, even though Postgres does support prepared statements, PHP's PDO driver NEVER sends the prepared statement to the Postgres server in advance of the call to PDO::execute().&nbsp; <br />
<br />
Therefore, PDO::prepare() will never throw an error for things like faulty SQL syntax.&nbsp; <br />
<br />
It also means the server will not parse and plan the SQL until the first time PDO::execute() is called, which may or may not adversely affect your optimization plans.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112277""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#112277" class="date">27-May-2013 10:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is possible to prepare in advance several statements against a single connection. As long as that connection remains open the statements can be executed and fetched from as often as you like in any order; their "prepare-execute-fetch" steps can be interleaved in whichever way is best.<br />
<br />
So if you're likely to be using several statements often (perhaps within a loop of transactions), you may like to consider preparing all the statements you'll be using up front.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111977""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#111977" class="date">19-Apr-2013 02:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To those wondering why adding quotes to around a placeholder is wrong, and why you can't use placeholders for table or column names:<br />
<br />
There is a common misconception about how the placeholders in prepared statements work: they are not simply substituted in as (escaped) strings, and the resulting SQL executed. Instead, a DBMS asked to "prepare" a statement comes up with a complete query plan for how it would execute that query, including which tables and indexes it would use, which will be the same regardless of how you fill in the placeholders.<br />
<br />
The plan for "SELECT name FROM my_table WHERE id = :value" will be the same whatever you substitute for ":value", but the seemingly similar "SELECT name FROM :table WHERE id = :value" cannot be planned, because the DBMS has no idea what table you're actually going to select from.<br />
<br />
Even when using "emulated prepares", PDO cannot let you use placeholders anywhere, because it would have to work out what you meant: does "Select :foo From some_table" mean ":foo" is going to be a column reference, or a literal string?<br />
<br />
When your query is using a dynamic column reference, you should be explicitly white-listing the columns you know to exist on the table, e.g. using a switch statement with an exception thrown in the default: clause.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111798""></a>
  <div class="note">
   <strong class="user">Kjetil H</strong>
   <a href="#111798" class="date">29-Mar-2013 06:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that the correct internal method signature is:<br />
<span class="default">&lt;?php </span><span class="keyword">public function </span><span class="default">prepare </span><span class="keyword">(</span><span class="default">$statement</span><span class="keyword">, </span><span class="default">$driver_options </span><span class="keyword">= array()) </span><span class="default">?&gt;</span> <br />
<br />
and NOT:<br />
<span class="default">&lt;?php </span><span class="keyword">public function </span><span class="default">prepare </span><span class="keyword">(</span><span class="default">$statement</span><span class="keyword">, array </span><span class="default">$driver_options </span><span class="keyword">= array()) </span><span class="default">?&gt;</span>.<br />
<br />
Redeclaring the method using the latter method signature throws a Stricts Standards error.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111458""></a>
  <div class="note">
   <strong class="user">Simon Le Pine</strong>
   <a href="#111458" class="date">22-Feb-2013 02:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi All,<br />
<br />
First time posting to php.net, a little nervous.<br />
<br />
After a bunch of searching I've learned 2 things about prepared statements:<br />
1.) It fails if you enclose in a single quote (')<br />
This fails: "SELECT * FROM users WHERE email=':email'"<br />
This works: "SELECT * FROM users WHERE email=:email"<br />
2.) You cannot search with a prepared statement<br />
This fails: "SELECT * FROM users WHERE :search=:email"<br />
This succeeds: "SELECT * FROM users WHERE $search=:email"<br />
<br />
In my case I allow the user to enter their username or email, determine which they've entered and set $search to "username" or "email". As this value is not entered by the user there is no potential for SQL injection and thus safe to use as I have done.<br />
<br />
Hope that saves someone else from a lot of searching.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108481""></a>
  <div class="note">
   <strong class="user">orrd101 at gmail dot com</strong>
   <a href="#108481" class="date">30-Apr-2012 09:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Don't just automatically use prepare() for all of your queries.<br />
<br />
If you are only submitting one query, using PDO::query() with PDO::quote() is much faster (about 3x faster in my test results with MySQL).&nbsp; A prepared query is only faster if you are submitting thousands of identical queries at once (with different data).<br />
<br />
If you Google for performance comparisons you will find that this is generally consistently the case, or you can write some code and do your own comparison for your particular configuration and query scenario. But generally PDO::query() will always be faster except when submitting a large number of identical queries.&nbsp; Prepared queries do have the advantage of escaping the data for you, so you have to be sure to use quote() when using query().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107811""></a>
  <div class="note">
   <strong class="user">public at grik dot net</strong>
   <a href="#107811" class="date">07-Mar-2012 09:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
With PDO_MYSQL you need to remember about the PDO::ATTR_EMULATE_PREPARES option.<br />
<br />
The default value is TRUE, like<br />
$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,true); <br />
<br />
This means that no prepared statement is created with $dbh-&gt;prepare() call. With exec() call PDO replaces the placeholders with values itself and sends MySQL a generic query string.<br />
<br />
The first consequence is that the call&nbsp; $dbh-&gt;prepare('garbage');<br />
reports no error. You will get an SQL error during the $dbh-&gt;exec() call.<br />
The second one is the SQL injection risk in special cases, like using a placeholder for the table name.<br />
<br />
The reason for emulation is a poor performance of MySQL with prepared statements. Emulation works significantly faster.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99697""></a>
  <div class="note">
   <strong class="user">pascal dot buguet at laposte dot net</strong>
   <a href="#99697" class="date">31-Aug-2010 02:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PDO::CURSOR_SCROLL is ok with MSS.<br />
You must install SQL Server Driver for PHP 2.0 CTP2 : SQLSRV20.EXE<br />
and&nbsp; the native client "Microsoft SQL Server 2008 R2 Native Client" : sqlncli.msi.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96544""></a>
  <div class="note">
   <strong class="user">Robin</strong>
   <a href="#96544" class="date">04-Mar-2010 02:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Use prepared statements to ensure integrity of binary data during storage and retrieval. Escaping/quoting by f.e. sqlite_escape_string() or PDO::quote() is NOT suited for binary data - only for strings of text.<br />
<br />
A simple test verifies perfect storage and retrieval with prepared statements:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$num_values </span><span class="keyword">= </span><span class="default">10000</span><span class="keyword">;<br />
<br />
</span><span class="default">$db </span><span class="keyword">= new </span><span class="default">pdo</span><span class="keyword">( </span><span class="string">'sqlite::memory:' </span><span class="keyword">);<br />
<br />
</span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">exec</span><span class="keyword">( </span><span class="string">'CREATE TABLE data (binary BLOB(512));' </span><span class="keyword">);<br />
<br />
</span><span class="comment">// generate plenty of troublesome, binary data<br />
</span><span class="keyword">for( </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$num_values</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++ )<br />
{<br />
&nbsp;&nbsp;&nbsp; for( </span><span class="default">$val </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">, </span><span class="default">$c </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$c </span><span class="keyword">&lt; </span><span class="default">512</span><span class="keyword">/</span><span class="default">16</span><span class="keyword">; </span><span class="default">$c</span><span class="keyword">++ )<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val </span><span class="keyword">.= </span><span class="default">md5</span><span class="keyword">( </span><span class="default">mt_rand</span><span class="keyword">(), </span><span class="default">true </span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; @</span><span class="default">$binary</span><span class="keyword">[] = </span><span class="default">$val</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">// insert each value by prepared statement<br />
</span><span class="keyword">for( </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$num_values</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++ )<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">( </span><span class="string">'INSERT INTO data VALUES (?);' </span><span class="keyword">)-&gt;</span><span class="default">execute</span><span class="keyword">( array(</span><span class="default">$binary</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]) );<br />
<br />
</span><span class="comment">// fetch the entire row<br />
</span><span class="default">$data </span><span class="keyword">= </span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">query</span><span class="keyword">( </span><span class="string">'SELECT binary FROM data;' </span><span class="keyword">)-&gt;</span><span class="default">fetchAll</span><span class="keyword">( </span><span class="default">PDO</span><span class="keyword">::</span><span class="default">FETCH_COLUMN </span><span class="keyword">);<br />
<br />
</span><span class="comment">// compare with original array, noting any mismatch<br />
</span><span class="keyword">for( </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$num_values</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++ )<br />
&nbsp;&nbsp;&nbsp; if( </span><span class="default">$data</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] != </span><span class="default">$binary</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] ) echo </span><span class="string">"[</span><span class="default">$i</span><span class="string">] mismatch\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">$db </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94354""></a>
  <div class="note">
   <strong class="user">sgirard at rossprint dot com</strong>
   <a href="#94354" class="date">30-Oct-2009 12:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Maybe everyone else already knows this but...<br />
<br />
If you have a routine that prepares/executes many insert or update statements for a sqlite db then you may want to make use of the pdo transactions. <br />
<br />
On some old hardware my query set went from 12 seconds to 1/3-1/2 second. <br />
<br />
-sean</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93469""></a>
  <div class="note">
   <strong class="user">richard at codevanilla.com</strong>
   <a href="#93469" class="date">11-Sep-2009 01:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
beware
<br />
PDO will emulate prepared statements/bound parameters for drivers that do not natively support them, and can also rewrite named or question mark style parameter markers to something more appropriate, if the driver supports one style but not the other.
<br />

<br />
This includes mySQL it seems so
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">try{ 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sth1 </span><span class="keyword">= </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">db1</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="default">$t1</span><span class="keyword">, array(</span><span class="default">PDO</span><span class="keyword">::</span><span class="default">ATTR_CURSOR </span><span class="keyword">=&gt; </span><span class="default">PDO</span><span class="keyword">::</span><span class="default">CURSOR_FWDONLY</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; catch(</span><span class="default">PDOException $e</span><span class="keyword">){
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pack</span><span class="keyword">(</span><span class="string">'dbError'</span><span class="keyword">, </span><span class="default">$e</span><span class="keyword">-&gt;</span><span class="default">getMessage</span><span class="keyword">());
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
does not and so will not throw the exception if your SQL is wrong.
<br />

<br />
You will need to check that $sth1 is not null.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91078""></a>
  <div class="note">
   <strong class="user">daniel dot egeberg at gmail dot com</strong>
   <a href="#91078" class="date">24-May-2009 10:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can also pass an array of values to PDOStatement::execute(). This is also secured against SQL injection. You don't necessarily have to use bindParam() or bindValue().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90209""></a>
  <div class="note">
   <strong class="user">admin at wdfa dot co dot uk</strong>
   <a href="#90209" class="date">10-Apr-2009 06:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note on the SQL injection properties of prepared statements.<br />
<br />
Prepared statements only project you from SQL injection IF you use the bindParam or bindValue option.<br />
<br />
For example if you have a table called users with two fields, username and email and someone updates their username you might run<br />
<br />
UPDATE `users` SET `user`='$var'<br />
<br />
where $var would be the user submitted text. <br />
<br />
Now if you did <br />
<span class="default">&lt;?php<br />
$a</span><span class="keyword">=new </span><span class="default">PDO</span><span class="keyword">(</span><span class="string">"mysql:host=localhost;dbname=database;"</span><span class="keyword">,</span><span class="string">"root"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">=</span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">"UPDATE `users` SET user='</span><span class="default">$var</span><span class="string">'"</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
and the user had entered&nbsp; User', email='test for a test the injection would occur and the email would be updated to test as well as the user being updated to User.<br />
<br />
Using bindParam as follows<br />
&nbsp;<span class="default">&lt;?php<br />
$var</span><span class="keyword">=</span><span class="string">"User', email='test"</span><span class="keyword">;<br />
</span><span class="default">$a</span><span class="keyword">=new </span><span class="default">PDO</span><span class="keyword">(</span><span class="string">"mysql:host=localhost;dbname=database;"</span><span class="keyword">,</span><span class="string">"root"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">=</span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">"UPDATE `users` SET user=:var"</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">bindParam</span><span class="keyword">(</span><span class="string">":var"</span><span class="keyword">,</span><span class="default">$var</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
The sql would be escaped and update the username to User', email='test'</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83281""></a>
  <div class="note">
   <strong class="user">ak_9jsz</strong>
   <a href="#83281" class="date">19-May-2008 07:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using cursors doesn't work with SQLite 3.5.9. I get an error message when it gets to the execute() method.<br />
<br />
Some of you might be saying "duh!" but i was surprised to see TRIGGER support in SQLite, so i had to try. :)<br />
<br />
I wanted to use Absolute referencing on a Scrollable cursor and i only wanted one column of data. So i used this instead of a cursor.<br />
<br />
<span class="default">&lt;?php<br />
<br />
$dbo </span><span class="keyword">= new </span><span class="default">PDO</span><span class="keyword">(</span><span class="string">'sqlite:tdb'</span><span class="keyword">);<br />
</span><span class="default">$sql </span><span class="keyword">= </span><span class="string">'SELECT F1, F2 FROM tblA WHERE F1 &lt;&gt; "A";'</span><span class="keyword">;<br />
</span><span class="default">$res </span><span class="keyword">= </span><span class="default">$dbo</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="default">$sql</span><span class="keyword">);<br />
</span><span class="default">$res</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">$resColumn </span><span class="keyword">= </span><span class="default">$res</span><span class="keyword">-&gt;</span><span class="default">fetchAll</span><span class="keyword">(</span><span class="default">PDO</span><span class="keyword">::</span><span class="default">FETCH_COLUMN</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">);<br />
<br />
for(</span><span class="default">$r</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$r</span><span class="keyword">&lt;=</span><span class="default">3</span><span class="keyword">;</span><span class="default">$r</span><span class="keyword">++)<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">'Row '</span><span class="keyword">. </span><span class="default">$r </span><span class="keyword">. </span><span class="string">' returned: ' </span><span class="keyword">. </span><span class="default">$resColumn</span><span class="keyword">[</span><span class="default">$r</span><span class="keyword">] . </span><span class="string">"\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">$dbo </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br />
</span><span class="default">$res </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79178""></a>
  <div class="note">
   <strong class="user">Stan</strong>
   <a href="#79178" class="date">14-Nov-2007 04:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using prepared SELECT statements on a MySQL database prior to MySQL 5.1.17 can lead to SERIOUS performance degradation.<br />
<br />
Quote from <a href="http://dev.mysql.com/doc/refman/5.1/en/query-cache.html :" rel="nofollow" target="_blank">http://dev.mysql.com/doc/refman/5.1/en/query-cache.html :</a><br />
<br />
&gt;&gt; The query cache is not used for server-side prepared statements before MySQL 5.1.17 &lt;&lt;<br />
<br />
The MySQL query cache buffers complete query results and is used to satisfy repeated identical queries if the underlying tables do not change in the meantime - just what happens all the time in a typical web application. It speeds up queries by a several hundred to a several thousand percent.<br />
<br />
Obviously, it doesn't make much sense to give up query caching for the relatively small performance benefit of prepared statements (i.e. the DBMS not having to parse and optimize the same query multiple times) - so using PDO-&gt;query() for SELECT statements is probably the better choice i you're connecting to MySQL &lt; 5.1.17.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74362""></a>
  <div class="note">
   <strong class="user">www.onphp5.com</strong>
   <a href="#74362" class="date">07-Apr-2007 03:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that the statement regarding driver_options is misleading:<br />
<br />
"This array holds one or more key=&gt;value pairs to set attribute values for the PDOStatement object that this method returns. You would most commonly use this to set the PDO::ATTR_CURSOR value to PDO::CURSOR_SCROLL to request a scrollable cursor. Some drivers have driver specific options that may be set at prepare-time"<br />
<br />
From this you might think that scrollable cursors work for all databases, but they don't! Check out this bug report:<br />
<a href="http://bugs.php.net/bug.php?id=34625" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=34625</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73421""></a>
  <div class="note">
   <strong class="user">johniskew</strong>
   <a href="#73421" class="date">22-Feb-2007 05:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need to create variable sql statements in a prepare statement...for example you may need to construct a sql query with zero, one, two, etc numbers of arguments...here is a way to do it without a lot of if/else statements needed to glue the sql together:<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">public function </span><span class="default">matchCriteria</span><span class="keyword">(</span><span class="default">$field1</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">,</span><span class="default">$field2</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">,</span><span class="default">$field3</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$db</span><span class="keyword">=</span><span class="default">DB</span><span class="keyword">::</span><span class="default">conn</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">=array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">=array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(!empty(</span><span class="default">$field1</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">[]=</span><span class="string">'field1=?'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">[]=</span><span class="default">$field1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(!empty(</span><span class="default">$field2</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">[]=</span><span class="string">'field2=?'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">[]=</span><span class="default">$field2</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(!empty(</span><span class="default">$field3</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">[]=</span><span class="string">'field3=?'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">[]=</span><span class="default">$field3</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$rs</span><span class="keyword">=</span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">'SELECT * FROM mytable'</span><span class="keyword">.(</span><span class="default">count</span><span class="keyword">(</span><span class="default">$paramArray</span><span class="keyword">)&gt;</span><span class="default">0 </span><span class="keyword">? </span><span class="string">' WHERE '</span><span class="keyword">.</span><span class="default">join</span><span class="keyword">(</span><span class="string">' AND '</span><span class="keyword">,</span><span class="default">$sql</span><span class="keyword">) : </span><span class="string">''</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result</span><span class="keyword">=</span><span class="default">$rs</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">(</span><span class="default">$paramArray</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$result</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$rs</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69335""></a>
  <div class="note">
   <strong class="user">william dot clarke at gmail dot com</strong>
   <a href="#69335" class="date">01-Sep-2006 12:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Surely if you want to use prepared statements that way you should use the syntax in the second example:<br />
<br />
eg. <br />
<br />
instead of:<br />
select id,name from demo_de where name LIKE :name OR name=:name <br />
<br />
use:<br />
select id,name from demo_de where name LIKE ? OR name=?<br />
<br />
I believe you are supposed to either use distinct named parameters (name, name1) OR anonymous parameters (?s)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69291""></a>
  <div class="note">
   <strong class="user">roth at egotec dot com</strong>
   <a href="#69291" class="date">30-Aug-2006 10:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Attention using MySQL and prepared statements.<br />
Using a placeholder multiple times inside a statement doesn't work. PDO just translates the first occurance und leaves the second one as is.<br />
<br />
select id,name from demo_de where name LIKE :name OR name=:name<br />
<br />
You have to use<br />
<br />
select id,name from demo_de where name LIKE :name OR name=:name2<br />
<br />
and bind name two times. I don't know if other databases (for example Oracle or MSSQL) support multiple occurances. If that's the fact, then the PDO behaviour for MySQL should be changed.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
