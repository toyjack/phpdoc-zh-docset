<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>范围解析操作符（::）</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="oop4.constructor.html">? 构造函数</a></li>
      <li style="float: right;"><a href="keyword.parent.html">parent ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="oop4.html">类与对象（PHP 4）</a></li>
    <li>范围解析操作符（::）</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="keyword.paamayim-nekudotayim" class="sect1">
   <h2 class="title">范围解析操作符（<em>::</em>）</h2>

   <div class="caution"><strong class="caution">Caution</strong>
    <p class="simpara">
     下列内容仅在 PHP 4 及以后版本中有效。
    </p>
   </div>

   <p class="para">
    有时，在没有声明任何实例的情况下访问类中的函数或者基类中的函数和变量很有用处。而
    :: 运算符即用于此情况。
   </p>

   <div class="informalexample">
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class&nbsp;</span><span style="color: #0000BB">A&nbsp;</span><span style="color: #007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;</span><span style="color: #0000BB">example</span><span style="color: #007700">()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">"I&nbsp;am&nbsp;the&nbsp;original&nbsp;function&nbsp;A::example().&lt;br&nbsp;/&gt;\n"</span><span style="color: #007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br />class&nbsp;</span><span style="color: #0000BB">B&nbsp;</span><span style="color: #007700">extends&nbsp;</span><span style="color: #0000BB">A&nbsp;</span><span style="color: #007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;</span><span style="color: #0000BB">example</span><span style="color: #007700">()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">"I&nbsp;am&nbsp;the&nbsp;redefined&nbsp;function&nbsp;B::example().&lt;br&nbsp;/&gt;\n"</span><span style="color: #007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000BB">A</span><span style="color: #007700">::</span><span style="color: #0000BB">example</span><span style="color: #007700">();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></span><span style="color: #FF8000">//&nbsp;A&nbsp;类没有对象，这将输出<br />//&nbsp;&nbsp;&nbsp;I&nbsp;am&nbsp;the&nbsp;original&nbsp;function&nbsp;A::example().&lt;br&nbsp;/&gt;<br /></span><span style="color: #0000BB">A</span><span style="color: #007700">::</span><span style="color: #0000BB">example</span><span style="color: #007700">();<br /><br /></span><span style="color: #FF8000">//&nbsp;建立一个&nbsp;B&nbsp;类的对象<br /></span><span style="color: #0000BB">$b&nbsp;</span><span style="color: #007700">=&nbsp;new&nbsp;</span><span style="color: #0000BB">B</span><span style="color: #007700">;<br /><br /></span><span style="color: #FF8000">//&nbsp;这将输出<br />//&nbsp;&nbsp;&nbsp;I&nbsp;am&nbsp;the&nbsp;redefined&nbsp;function&nbsp;B::example().&lt;br&nbsp;/&gt;<br />//&nbsp;&nbsp;&nbsp;I&nbsp;am&nbsp;the&nbsp;original&nbsp;function&nbsp;A::example().&lt;br&nbsp;/&gt;<br /></span><span style="color: #0000BB">$b</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">example</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>

   <p class="para">
    上面的例子调用了 A 类的函数 example()，但是这里并不存在 A
    类的对象，因此不能这样用 $a-&gt;example() 或者类似的方法调用
    example()。反而我们将 example()
    作为一个类函数来调用，也就是说，作为一个类自身的函数来调用，而不是这个类的任何对象。
   </p>

   <p class="para">
    这里有类函数，但没有类的变量。实际上，在调用函数时完全没有任何对象。因而一个类的函数可以不使用任何对象（但可以使用局部或者全局变量），并且可以根本不使用
    <var class="varname"><var class="varname">$this</var></var> 变量。
   </p>

   <p class="para">
    上面的例子中，类 B 重新定义了函数 example()。A
    类中原始定义的函数 example()
    将被屏蔽并且不再生效，除非使用 ::
    运算符来访问 A 类中的 example() 函数。如：A::example()（实际上，应该写为
    parent::example()，下一章介绍该内容）。
   </p>

   <p class="para">
    就此而论，对于当前对象，它可能有对象变量。因此可以在对象函数的内部使用
    <var class="varname"><var class="varname">$this</var></var> 和对象变量。
   </p>

 </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="84629""></a>
  <div class="note">
   <strong class="user">singh206 at gmail dot com</strong>
   <a href="#84629" class="date">22-Jul-2008 08:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using PHP 4, I was unable to see an easy method for retrieving static constants in a library, as well as static functions.&nbsp; There was no need to set variables, as the library is final, used for Configuration settings.
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">class </span><span class="default">StaticLibrary
<br />
</span><span class="keyword">{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//static constants are set here
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">finalConstants</span><span class="keyword">(&amp;</span><span class="default">$Vars</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$Vars</span><span class="keyword">[</span><span class="string">'someVar'</span><span class="keyword">]&nbsp; &nbsp; &nbsp; &nbsp; = </span><span class="string">'Hello'</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$Vars</span><span class="keyword">[</span><span class="string">'anotherVar'</span><span class="keyword">]&nbsp; &nbsp;&nbsp; = </span><span class="string">'World'</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$Vars</span><span class="keyword">[</span><span class="string">'moreVars'</span><span class="keyword">]&nbsp; &nbsp; &nbsp;&nbsp; = </span><span class="string">'Keep It Coming'</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//usage: StaticLibrary::vars('someVar')
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">vars</span><span class="keyword">(</span><span class="default">$v</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; {&nbsp; &nbsp; 
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; static </span><span class="default">$Vars</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$Vars</span><span class="keyword">)) { </span><span class="default">$Vars </span><span class="keyword">= array(); </span><span class="default">StaticLibrary</span><span class="keyword">::</span><span class="default">finalConstants</span><span class="keyword">(</span><span class="default">$Vars</span><span class="keyword">); } </span><span class="comment">//setup access to the static contants in our Final library
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">return(</span><span class="default">$Vars</span><span class="keyword">[</span><span class="default">$v</span><span class="keyword">]); </span><span class="comment">//return some var
<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">}
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//usage: StaticLibrary::staticFunction('Some string and I want to ')&nbsp; &nbsp; 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">staticFunction</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">.= </span><span class="string">'freak that string!'</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$str</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
&nbsp; I appreciate the ideas below!!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79727""></a>
  <div class="note">
   <strong class="user">philipp dot feigl at gmail dot com</strong>
   <a href="#79727" class="date">10-Dec-2007 03:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As already pointed out in a previous comment, there is no way to statically access variables, i wrote this small workaround<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">A </span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; var </span><span class="default">$MY_VIRTUAL_CONST </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">MY_VIRTUAL_CONST</span><span class="keyword">() { </span><span class="default">$vars </span><span class="keyword">= </span><span class="default">get_class_vars</span><span class="keyword">(</span><span class="default">__CLASS__</span><span class="keyword">); return </span><span class="default">$vars</span><span class="keyword">[</span><span class="default">strToUpper</span><span class="keyword">(</span><span class="default">__FUNCTION__</span><span class="keyword">)]; }<br />
}<br />
<br />
echo </span><span class="default">A</span><span class="keyword">::</span><span class="default">MY_VIRTUAL_CONST</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
This magically retrieves the correct value without creating an object instance and its easily copy &amp; pasteable, as the methods content is completly generic.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75968""></a>
  <div class="note">
   <strong class="user">Robert Chapin</strong>
   <a href="#75968" class="date">25-Jun-2007 04:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I revised this example to give a better feel for the scope and overloading rules in PHP 4.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">A </span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">example</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"I am the original function A::example().&lt;br /&gt;\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">other</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">other</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"I am the original function A::other().&lt;br /&gt;\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
class </span><span class="default">B </span><span class="keyword">extends </span><span class="default">A </span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">example</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"I am the redefined function B::example().&lt;br /&gt;\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">A</span><span class="keyword">::</span><span class="default">example</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">other</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"I am the redefined function B::other().&lt;br /&gt;\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
</span><span class="comment">// there is no object of class A.<br />
// this will print<br />
//&nbsp;&nbsp; I am the original function A::example().&lt;br /&gt;<br />
//&nbsp;&nbsp; PHP Fatal error:&nbsp; Call to a member function on a non-object in test.php on line 5<br />
</span><span class="default">A</span><span class="keyword">::</span><span class="default">example</span><span class="keyword">();<br />
<br />
</span><span class="comment">// create an object of class B.<br />
</span><span class="default">$b </span><span class="keyword">= new </span><span class="default">B</span><span class="keyword">;<br />
<br />
</span><span class="comment">// this will print<br />
//&nbsp;&nbsp; I am the redefined function B::example().&lt;br /&gt;<br />
//&nbsp;&nbsp; I am the original function A::example().&lt;br /&gt;<br />
//&nbsp;&nbsp; I am the redefined function B::other().&lt;br /&gt;<br />
</span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">example</span><span class="keyword">();<br />
</span><span class="default">?&gt;</span> <br />
<br />
Robert Chapin<br />
Chapin Information Services</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73037""></a>
  <div class="note">
   <strong class="user">deadimp at gmail dot com</strong>
   <a href="#73037" class="date">07-Feb-2007 06:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've noticed that you can't easily obtain a re-scoping of a function-to-object by external means, and it can only really be done by functions ["methods" to be proper] inside the class.<br />
I dub this phenomon "inability to externally modifiy scope resolution of class method", 'cause I don't really know the technical name. (Maybe something else along the lines of "inability to combine scope resolution and member selector operators".)<br />
Enough of this, on to the example:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">Base </span><span class="keyword">{<br />
&nbsp;var </span><span class="default">$a</span><span class="keyword">=</span><span class="default">5</span><span class="keyword">;<br />
&nbsp;function </span><span class="default">Func</span><span class="keyword">() {<br />
&nbsp; echo </span><span class="string">"Base::Func </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">a</span><span class="string">&lt;br&gt;"</span><span class="keyword">;<br />
&nbsp;}<br />
}<br />
class </span><span class="default">Child </span><span class="keyword">extends </span><span class="default">Base </span><span class="keyword">{<br />
&nbsp;function </span><span class="default">Func</span><span class="keyword">() {<br />
&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">a</span><span class="keyword">=</span><span class="default">35</span><span class="keyword">;<br />
&nbsp; </span><span class="default">Base</span><span class="keyword">::</span><span class="default">Func</span><span class="keyword">();<br />
&nbsp; </span><span class="comment">//$this-&gt;Base::Func(); //Won't work either<br />
&nbsp; </span><span class="keyword">echo </span><span class="string">"Child::Func </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">a</span><span class="string">&lt;br&gt;"</span><span class="keyword">;<br />
&nbsp;}<br />
}<br />
</span><span class="default">$obj</span><span class="keyword">=new </span><span class="default">Child</span><span class="keyword">;<br />
</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">Func</span><span class="keyword">(); </span><span class="comment">//That works, outputs as expected<br />
</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">Base</span><span class="keyword">::</span><span class="default">Func</span><span class="keyword">(); </span><span class="comment">//ERROR - See below<br />
</span><span class="default">?&gt;<br />
</span>As for the error, I get the Hebrew "double colon", as Shachar Shemesh mentioned: "parse error, unexpected T_PAAMAYIM_NEKUDOTAYIM"<br />
I find it odd that I can't do this, and using C++ (where you are able to do this), I feel restricted in this sense.<br />
And I can't think of any workarounds right now, aside from using this scope resolution in the class scope.<br />
<br />
NOTE: I'm using PHP 5.0.5 right now (used to be using 4.x, but might've switched it in xampp)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69537""></a>
  <div class="note">
   <strong class="user">Shachar Shemesh</strong>
   <a href="#69537" class="date">09-Sep-2006 09:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The PHP lexical analyzer gives this token the name "T_PAAMAYIM_NEKUDOTAYIM". It might as well have been written in Hebrew. Wait, it IS written in Hebrew. It means "double colon".<br />
<br />
I'm writing this comment mostly so that people who are searching the web for what the #(!(@*&amp;#$ errors such as "unexpected T_PAAMAYIM_NEKUDOTAYIM" or "missing T_PAAMAYIM_NEKUDOTAYIM" mean get to the right page in the PHP manual.<br />
<br />
Shachar</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68477""></a>
  <div class="note">
   <strong class="user">docey</strong>
   <a href="#68477" class="date">28-Jul-2006 08:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
after doing some research as the manual was somewhat<br />
vague, i found out that using $this in a class-function is<br />
not fatal as the manual implied, its not even a warning.<br />
<br />
it simply comes with a notice saying: $this is undefined.<br />
<br />
it appears the class-function is just as a global function.<br />
and as such the static keyword holds its value after scope<br />
changes. <br />
<br />
however it seems to also holds its value after the class<br />
gets instanced. take a simple counter function thats a <br />
member of a class. make a few calls to the counter to <br />
let it count to lets say 3. then instance the class and let<br />
it count it again 3 times. you think the score is now 3, <br />
infact its 6.<br />
<br />
so one simple way to find out if a function is called from<br />
a instanced class or not is to have the constructor set a<br />
class variable and then check for it using isset. since in<br />
the class-function scope the $this is unavailable isset <br />
will return false. but when the class has been instanced<br />
it will return true. <br />
<br />
btw, i tested it with php4.4.2CLI.<br />
<br />
hope this will clear somethings up.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58742""></a>
  <div class="note">
   <strong class="user">rudy at sandbenders dot ca</strong>
   <a href="#58742" class="date">14-Nov-2005 07:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
my last note is actually not 100% correct... as it is, trying to return a reference to an element of the class variables array won't work, even though the classVars function is declared as (possibly) returning a reference... the correct way to return a reference to one of your class variables would be<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">class </span><span class="default">theClass </span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; function &amp;</span><span class="default">classVars</span><span class="keyword">(</span><span class="default">$name </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">, ...) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; static </span><span class="default">$myClassVars</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ...<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$myRef </span><span class="keyword">=&amp; </span><span class="default">$myClassVars</span><span class="keyword">[</span><span class="default">$name</span><span class="keyword">];<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return(</span><span class="default">$myRef</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
which works as expected when you're looking for a reference. This should only be necessary when you're trying to return a reference to a piece of the array as opposed to the whole array itself. Simply doing this<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">return(</span><span class="default">$myClassVars</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
works as expected, ie: you can get a reference to the whole array without needing to explicitly create a reference to it before returning.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58724""></a>
  <div class="note">
   <strong class="user">rudy at sandbenders dot ca</strong>
   <a href="#58724" class="date">14-Nov-2005 07:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Since re-posting a simplified version of the peterjoel.com solution to class variables in php4 was kinda lame, here's the modified solution to give you one function (per class) that allows you to use any number of 'class' variables...<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">class </span><span class="default">theClass </span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; function &amp;</span><span class="default">classVars</span><span class="keyword">(</span><span class="default">$name </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$value </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">) {&nbsp; </span><span class="comment">// The classVars function is (possibly) returning a reference...<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">static </span><span class="default">$myClassVars</span><span class="keyword">;&nbsp; </span><span class="comment">// Define a static var to hold our 'class' vars...<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (!</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$myClassVars</span><span class="keyword">)) {&nbsp; </span><span class="comment">// Initialize the array if it isn't already...<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$myClassVars </span><span class="keyword">= array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (!</span><span class="default">is_null</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">) &amp;&amp; !</span><span class="default">is_null</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">)) {&nbsp; </span><span class="comment">// If we got two arguments, set the class var that was passed...<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$myClassVars</span><span class="keyword">[</span><span class="default">$name</span><span class="keyword">] = </span><span class="default">$value</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (!</span><span class="default">is_null</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">)) {&nbsp; </span><span class="comment">// If we got one argument, return the var it's referring to...<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">return(</span><span class="default">$myClassVars</span><span class="keyword">[</span><span class="default">$name</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return(</span><span class="default">NULL</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
</span><span class="comment">// Setting class variables...<br />
<br />
</span><span class="default">theClass</span><span class="keyword">::</span><span class="default">classVars</span><span class="keyword">(</span><span class="string">"varOne"</span><span class="keyword">, </span><span class="string">"valueOne"</span><span class="keyword">);<br />
</span><span class="default">theClass</span><span class="keyword">::</span><span class="default">classVars</span><span class="keyword">(</span><span class="string">"varTwo"</span><span class="keyword">, </span><span class="string">"valueTwo"</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Getting class variables...<br />
<br />
</span><span class="default">$myRef </span><span class="keyword">= &amp;</span><span class="default">theClass</span><span class="keyword">::</span><span class="default">classVars</span><span class="keyword">(</span><span class="string">"varOne"</span><span class="keyword">);<br />
echo </span><span class="default">theClass</span><span class="keyword">::</span><span class="default">classVars</span><span class="keyword">(</span><span class="string">"varTwo"</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
You should be able to store anything in your class vars this way, and depending on how you call the function, you can have either a copy or a reference to the class var returned (see manual on 'returning by reference'...) Again, hope this helps someone...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58723""></a>
  <div class="note">
   <strong class="user">rudy at sandbenders dot ca</strong>
   <a href="#58723" class="date">14-Nov-2005 06:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
'emulating' class variables in php4... peter at textstore dot c() dot il&nbsp; put me on the right track... I came up with the following and then before posting this realized that peterjoel.com has already posted almost the exact same thing... anyways, this is a little simpler and only involves one function instead of a getter/setter pair...<br />
<br />
class myClass {<br />
&nbsp;&nbsp;&nbsp; function &amp;myVar($arg = NULL) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; static $myClassVar;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (!is_null($arg)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $myClassVar = $arg;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return($myClassVar);<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
// Setting the 'class' var...<br />
<br />
myClass::myVar($myNewClassVar);<br />
<br />
// Getting the 'class' var...<br />
<br />
$classVarRef = &amp;myClass::myVar();<br />
<br />
This should let you set up 'class' vars that will hold anything you can reference... with a little creative array usage, you could modify this to allow any number of class vars without having to write the same above function for each one... hope someone finds it useful...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56356""></a>
  <div class="note">
   <strong class="user">JDS &lt;jeff at newtnotes dot com&gt;</strong>
   <a href="#56356" class="date">31-Aug-2005 04:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using an anonymous class instance via the scope resolution operator does not appear to call the constructor method of the class.&nbsp; Thus, any "stuff" set up within a constructor method (the method called when creating a new instance of a class) will not get set up using anonymous classes.<br />
<br />
So for example something like this<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">Class </span><span class="default">A</span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; var </span><span class="default">$thing</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">A</span><span class="keyword">(<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">thing </span><span class="keyword">= </span><span class="string">"hello"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; )<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">get </span><span class="keyword">(</span><span class="default">$var</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">$var</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
echo </span><span class="default">A</span><span class="keyword">::</span><span class="default">get</span><span class="keyword">(</span><span class="string">'thing'</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
will not print anything as A::thing does not get "set up" outside of the constructor.<br />
<br />
You would have to create an instance of class A to get any value for A::thing.<br />
<br />
For example:<br />
<span class="default">&lt;?php<br />
$a </span><span class="keyword">= new </span><span class="default">A</span><span class="keyword">();<br />
echo </span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">get</span><span class="keyword">(</span><span class="string">'thing'</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>(prints "hello")<br />
<br />
This is based on my observations and not from any official documentation.&nbsp; I may be wrong about the details.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56253""></a>
  <div class="note">
   <strong class="user">evert at collab dot nl</strong>
   <a href="#56253" class="date">28-Aug-2005 10:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A note to RichardBronosky's suggestion:<br />
<br />
This is a very insecure method, never unserialize user data because they might be able upload a totally different class.<br />
They can only specify properties, not methods but if they can research your code they might be able to do uninteded stuff or create a XSS attack.<br />
<br />
So only unserialize user-data when you are in a controlled safe enviroment.<br />
<br />
Evert</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52685""></a>
  <div class="note">
   <strong class="user">RichardBronosky (firstname at lastname dot com)</strong>
   <a href="#52685" class="date">09-May-2005 11:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reply to tim dot ward at stivesdirect dot com:<br />
I had a need to to do a very similar thing.&nbsp; I wrote a class that will be used to create an object which can serialize itself into a cookie and be used to recover itself from the cookie later.&nbsp; To do the recovery you must use the Scope Resolution Operator (::) to call a function as a class function (vs. and object function).&nbsp; The recovery is very simple to initiate because there is only one line of code to call (e.g. $the_object = the_class::the_function(); )&nbsp; But the function you call must do a ton of stuff, and call a few other functions within the class.&nbsp; This is where the problem lies.<br />
<br />
I would like to thank &lt;brooke at jump dot net&gt;, &lt;pollita at php dot net&gt;, and &lt;MagicalTux at FF.ST&gt; (from <a href="http://php.net/manual/en/function.get-class.php" rel="nofollow" target="_blank">http://php.net/manual/en/function.get-class.php</a>) for leading me to the solution.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">foo<br />
</span><span class="keyword">{<br />
&nbsp;&nbsp; function </span><span class="default">get_object_from_cookie</span><span class="keyword">(...)<br />
&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp;&nbsp; ...<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">unserialize</span><span class="keyword">(</span><span class="default">$decrypted_cookie_data</span><span class="keyword">);<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; function </span><span class="default">recover_from_cookie</span><span class="keyword">()<br />
&nbsp;&nbsp; {&nbsp; <br />
&nbsp;&nbsp; &nbsp;&nbsp; ...</span><span class="default">prepare to recover</span><span class="keyword">...<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="comment">// The next line is the tricky part.<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$o </span><span class="keyword">= </span><span class="default">call_user_func</span><span class="keyword">(array(</span><span class="default">__CLASS__</span><span class="keyword">, </span><span class="string">'get_object_from_cookie'</span><span class="keyword">), </span><span class="default">$encryption_secret</span><span class="keyword">, </span><span class="default">$cookie_name</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$temp </span><span class="keyword">= </span><span class="default">$o</span><span class="keyword">-&gt;</span><span class="default">get_stuff</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$o</span><span class="keyword">-&gt;</span><span class="default">other_stuff </span><span class="keyword">= </span><span class="default">$o</span><span class="keyword">-&gt;</span><span class="default">do_calculate</span><span class="keyword">(</span><span class="default">$temp</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$o</span><span class="keyword">-&gt;</span><span class="default">do_complicated_things</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">$o</span><span class="keyword">;<br />
&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">$bar </span><span class="keyword">= </span><span class="default">foo</span><span class="keyword">::</span><span class="default">recover_from_cookie</span><span class="keyword">();<br />
...<br />
</span><span class="default">?&gt;<br />
</span><br />
I hope that saves someone an hour.&nbsp; It sure would have saved me one.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50706""></a>
  <div class="note">
   <strong class="user">mark at branly dot com</strong>
   <a href="#50706" class="date">07-Mar-2005 11:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I didn't see where this issue was addressed so in regards to this post:<br />
<br />
\\-------\\//-------//<br />
when using "::" operator inside class functions, you can achieve quite interesting results. let's take this example:<br />
<br />
&nbsp; class cCat {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; function Miew(){<br />
&nbsp;&nbsp; &nbsp; // cCat does not have a member "kind", but cDog has, and we'll use it<br />
&nbsp;&nbsp; &nbsp; echo "I am ".$this-&gt;kind.", and I say MIEW\n";<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; // here things are even stranger: does cCat class<br />
&nbsp;&nbsp; &nbsp; // support WhoAmI function? guess again...<br />
&nbsp;&nbsp; &nbsp; $this-&gt;WhoAmI();<br />
&nbsp;&nbsp; }<br />
&nbsp; }<br />
&nbsp;<br />
&nbsp; class cDog {<br />
&nbsp;&nbsp; var $kind = "DOG";<br />
&nbsp;&nbsp; function Bark(){&nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; // let's make this dog act like a cat:)<br />
&nbsp;&nbsp; &nbsp; &nbsp; cCat::Miew();<br />
&nbsp;&nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp; <br />
&nbsp;&nbsp; function WhoAmI(){<br />
&nbsp;&nbsp; &nbsp; echo "Yes, I'm really ".$this-&gt;kind."!";<br />
&nbsp;&nbsp; }<br />
&nbsp; }<br />
<br />
&nbsp; $dog = new cDog();<br />
&nbsp; echo $dog-&gt;Bark();<br />
<br />
outputs:<br />
I am DOG, and I say MIEW<br />
Yes, I'm really DOG!<br />
<br />
The interesting thing here is that cDog is not descendant of cCat nor vice versa, but cCat was able to use cDog member variable and function. When calling cCat::Miew() function, your $this variable is passed to that function, remaining cDog instance!<br />
<br />
It looks like PHP doesn't check if some class is an ancestor of the class, calling function via '::'.<br />
<br />
//------//\\--------\\<br />
<br />
The problem here is not that PHP is not checking ancestry. The problem is that "$this" refers to the calling object $dog even though it is referenced inside the cCat class definition. Since a cCat is never instantiated, $this has not been scoped to it. <br />
<br />
To further illustrate the point, if you never instatiate dog (or any object for that matter), $this will never be set and when you statically call the miew function, you will get the following output:<br />
<br />
"I am , and I say MIEW"<br />
<br />
This flexibility of member handling, PHP does not afford to methods and as such the second line of the miew function will generate a fatal error reporting that the method has been called from a non object.<br />
<br />
If you did want to take it one step further in the whole ancestry guessing issue, try instatiating cCat and calling the miew function. You will get the same result as above *EXCEPT* the fatal error will inform you the function has not been defined. <br />
<br />
So, there you have it--PHP DOES NOT guess at inheritance.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50332""></a>
  <div class="note">
   <strong class="user">mark@thedarkside</strong>
   <a href="#50332" class="date">25-Feb-2005 12:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Carrying on from the previous note, it is possible to call a member function statically using a variable for the name of the class, i.e.:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">MyObject </span><span class="keyword">{<br />
&nbsp;&nbsp; function </span><span class="default">myfunc</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="string">"Hello! (</span><span class="default">$this</span><span class="string">)"</span><span class="keyword">;&nbsp; </span><span class="comment">// '$this' to determine whether it is being called statically<br />
&nbsp;&nbsp; </span><span class="keyword">}<br />
}<br />
<br />
</span><span class="default">$type </span><span class="keyword">= </span><span class="string">"MyObject"</span><span class="keyword">;<br />
</span><span class="default">$object </span><span class="keyword">= new </span><span class="default">$type</span><span class="keyword">();<br />
<br />
</span><span class="default">$message </span><span class="keyword">= </span><span class="default">$object</span><span class="keyword">-&gt;</span><span class="default">myfunc</span><span class="keyword">();<br />
</span><span class="default">$message </span><span class="keyword">= </span><span class="default">MyObject</span><span class="keyword">-&gt;</span><span class="default">myfunc</span><span class="keyword">();<br />
</span><span class="default">$message </span><span class="keyword">= </span><span class="default">call_user_func</span><span class="keyword">(array(&amp;</span><span class="default">$type</span><span class="keyword">, </span><span class="string">"myfunc"</span><span class="keyword">));<br />
<br />
</span><span class="default">O</span><span class="keyword">.</span><span class="default">K</span><span class="keyword">., </span><span class="default">so it</span><span class="string">'s not using the scope resolution operator, but it does what you want... it calls '</span><span class="default">myfunc</span><span class="string">' statically from the class named by $type.</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50310""></a>
  <div class="note">
   <strong class="user">Tom Wiltshire</strong>
   <a href="#50310" class="date">24-Feb-2005 01:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It's worth noting that you can't use a variable with this operator.<br />
The following is legal:<br />
<br />
&nbsp;&nbsp;&nbsp; class MyObject {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function myfunc() {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return "Hello!";<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; $type = "MyObject";<br />
&nbsp;&nbsp;&nbsp; $object = new $type();<br />
&nbsp;&nbsp;&nbsp; $message = $object-&gt;myfunc();<br />
<br />
(Puts "hello" in $message)<br />
<br />
You can also use the scope operator:<br />
<br />
&nbsp;&nbsp;&nbsp; $message = MyObject::myfunc();<br />
<br />
However, the following is NOT legal:<br />
<br />
&nbsp;&nbsp;&nbsp; $message = $type::myfunc();<br />
<br />
It's a pity, 'cos right now I've got a situation where it'd be really handy, but that's the way it goes!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43897""></a>
  <div class="note">
   <strong class="user">stefano at obliquid dot it</strong>
   <a href="#43897" class="date">08-Jul-2004 02:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
peter has a good point to suggest the use of static function variables instead of static class variables that PHP 4 does not support.<br />
<br />
Unfortunately, also the first sentence of the manual is misleading "... refer to functions and variables in base classes or to refer to functions in classes that have not yet any instances. The :: operator is being used for this.". <br />
<br />
You cannot use the :: operator on class variables since there are no static class variables. I lost some time trying to refer to class variable with this operator, so I think it may be useful to post a warning. <br />
<br />
<a href="http://dev.obliquid.com" rel="nofollow" target="_blank">http://dev.obliquid.com</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42174""></a>
  <div class="note">
   <strong class="user">tango23 at inbox dot lv</strong>
   <a href="#42174" class="date">06-May-2004 04:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
&gt;&gt; That's how to make class' static variable in PHP4. <br />
<br />
Note, that nobody seems to have a way of actually making a global static server-wide object in PHP.<br />
<br />
All the static/class var ways above work only within a single PHP page.<br />
<br />
If you want to do something like:<br />
<br />
class Logger <br />
{<br />
&nbsp;&nbsp; ...<br />
&nbsp;&nbsp; function Logger($filepath)<br />
&nbsp;&nbsp; ...<br />
}<br />
<br />
in some global include file:<br />
$logobj = new Logger("mylogfile");<br />
<br />
and then in all of your pages:<br />
<br />
$logobj-&gt;log("my message");<br />
<br />
and there is no way you can make this logobj static (such that all your pages can refer to without making unncecessary copies).<br />
<br />
Can't be done with using uninstantiated Logger::log() funcs either, because you are not setting the logfile filepath parameter anywhere persistent.<br />
<br />
The only kludge seems to be to use the filepath as a global variable and use Logger:: syntax.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="40783""></a>
  <div class="note">
   <strong class="user">altherac at yahoo dot fr</strong>
   <a href="#40783" class="date">14-Mar-2004 11:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using a class function is a good way to write a Singleton pattern in php 4 using a static variable.<br />
<br />
The sample code below shows the pattern in action : <br />
<br />
&lt;?<br />
&nbsp;&nbsp;&nbsp; class Singleton<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var $_info = null;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function Singleton() {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $this-&gt;_info = 'Original value';<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function getInfo() {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return $this-&gt;_info;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function setInfo($info) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $this-&gt;_info = $info;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function &amp;getInstance() {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; static $instance = null;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (is_null($instance)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $instance = new Singleton();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return $instance;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; $a = &amp; Singleton::getInstance();<br />
&nbsp;&nbsp;&nbsp; $b = &amp; Singleton::getInstance();<br />
&nbsp;&nbsp;&nbsp; $a-&gt;setInfo('Hi, my name is A');<br />
&nbsp;&nbsp;&nbsp; echo $b-&gt;getInfo();<br />
<br />
?&gt;<br />
<br />
I have seen some Singleton pattern implementations that were using an external function to instanciate the object, but I don't think it is the best way to implement the pattern.<br />
<br />
You may want to force the getInstance() function to be called in a static way with the :: operator by testing if $this is set and raising an error or returning a null value (depending on your design).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37271""></a>
  <div class="note">
   <strong class="user">Rami Kayyali (rami at bluecubex dot com)</strong>
   <a href="#37271" class="date">08-Nov-2003 05:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Regarding the note by "gk at proliberty dot com". No, eval() isn't superior to call_user_func(), eval() has security issues and performance overhead.<br />
To achieve the same results using your example with call_user_func, simply pass $this_class by reference. This is probably because call_user_func is passing a copy of $this_class.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">init</span><span class="keyword">(&amp;</span><span class="default">$this_class</span><span class="keyword">, </span><span class="default">$current_class</span><span class="keyword">, </span><span class="default">$params</span><span class="keyword">= </span><span class="default">NULL </span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this_class</span><span class="keyword">-&gt;</span><span class="default">classFiles</span><span class="keyword">[] = </span><span class="default">__FILE__</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parent_class</span><span class="keyword">=</span><span class="default">get_parent_class</span><span class="keyword">(</span><span class="default">$current_class</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if( !empty(</span><span class="default">$parent_class</span><span class="keyword">)){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// call_user_func() NOW DOES CORRECTLY UPDATE $this_class-&gt;classFiles :)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">call_user_func</span><span class="keyword">(array(</span><span class="default">$parent_class</span><span class="keyword">,</span><span class="string">'init'</span><span class="keyword">),<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &amp;</span><span class="default">$this_class</span><span class="keyword">,</span><span class="default">$parent_class</span><span class="keyword">,</span><span class="default">$params</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; <br />
} </span><span class="comment">// init()<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
But please note, call-time pass-by-reference has been deprecared, or at least, PHP 4.3.2 says so.<br />
<br />
Conclusion: Minimize using eval as much as possible, many projects had major security issues because they were using eval().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37232""></a>
  <div class="note">
   <strong class="user">brooke at jump dot net</strong>
   <a href="#37232" class="date">07-Nov-2003 12:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Someone mentioned that eval was better than call_user_func because the latter would not result in updates to the objects. I'm not sure this is the right place for such a debate, but if it is, then the right way is:<br />
<br />
call_user_func(array(&amp;this, $method), $arg1, $arg2);<br />
<br />
You put a reference to (instead of a copy of) this in the array which you pass on.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="33055""></a>
  <div class="note">
   <strong class="user">wikiz at studentas dot lt</strong>
   <a href="#33055" class="date">15-Jun-2003 02:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
when using "::" operator inside class functions, you can achieve quite interesting results. let's take this example:<br />
<br />
&nbsp; class cCat {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; function Miew(){<br />
&nbsp;&nbsp; &nbsp;&nbsp; // cCat does not have a member "kind", but cDog has, and we'll use it <br />
&nbsp;&nbsp; &nbsp;&nbsp; echo "I am ".$this-&gt;kind.", and I say MIEW\n";<br />
&nbsp;&nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp;&nbsp; // here things are even stranger: does cCat class <br />
&nbsp;&nbsp; &nbsp;&nbsp; // support WhoAmI function? guess again...<br />
&nbsp;&nbsp; &nbsp;&nbsp; $this-&gt;WhoAmI();<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
&nbsp; <br />
&nbsp; class cDog {<br />
&nbsp;&nbsp;&nbsp; var $kind = "DOG"; <br />
&nbsp;&nbsp;&nbsp; function Bark(){&nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; // let's make this dog act like a cat:)<br />
&nbsp;&nbsp; &nbsp; &nbsp; cCat::Miew();<br />
&nbsp;&nbsp;&nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; function WhoAmI(){<br />
&nbsp;&nbsp; &nbsp;&nbsp; echo "Yes, I'm really ".$this-&gt;kind."!";<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
<br />
&nbsp; $dog = new cDog();<br />
&nbsp; echo $dog-&gt;Bark();<br />
<br />
outputs:<br />
I am DOG, and I say MIEW<br />
Yes, I'm really DOG!<br />
<br />
The interesting thing here is that cDog is not descendant of cCat nor vice versa, but cCat was able to use cDog member variable and function. When calling cCat::Miew() function, your $this variable is passed to that function, remaining cDog instance!<br />
<br />
It looks like PHP doesn't check if some class is an ancestor of the class, calling function via '::'.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="32488""></a>
  <div class="note">
   <strong class="user">gk at proliberty dot com</strong>
   <a href="#32488" class="date">29-May-2003 03:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Contrary to the comment above, I have found that call_user_func() <br />
is inferior to eval() because call_user_func() does not correctly <br />
update objects passed by reference.<br />
<br />
In the example below, each of my subclasses calls init(), passing <br />
a reference to the current object, whose class variables are <br />
initialized by classes in the hierarchy. The class variable <br />
$this-&gt;classFiles contains the paths of each file for classes in <br />
the hierarchy. It is not updated correctly using call_user_func() <br />
but eval() works fine.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">///////////////////////////////////////////////////////<br />
/*<br />
&nbsp; xobj( );<br />
&nbsp;&nbsp;&nbsp; constructor<br />
&nbsp;&nbsp;&nbsp; SUBCLASSES MUST NOT have any constructors <br />
*/<br />
/////////////////////////////////////////////////////////<br />
</span><span class="keyword">function </span><span class="default">xobj</span><span class="keyword">( </span><span class="default">$params</span><span class="keyword">= </span><span class="default">NULL </span><span class="keyword">){ <br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$current_class</span><span class="keyword">=</span><span class="default">get_class</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">init</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">, </span><span class="default">$current_class</span><span class="keyword">, </span><span class="default">$params</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// $this-&gt;classFiles[0] is the file containing the final subclass<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">classFile</span><span class="keyword">=</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">classFiles</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">classFiles</span><span class="keyword">); exit;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">_init</span><span class="keyword">(</span><span class="default">$params</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="comment">///////////////////////////////////////////////////////<br />
/*<br />
&nbsp; void init(&amp;$this_class, $current_class, $params= NULL );<br />
&nbsp;&nbsp;&nbsp; initialization<br />
&nbsp;&nbsp;&nbsp; this class MUST be overridden to set $this-&gt;classFiles correctly:<br />
&nbsp;&nbsp;&nbsp; initialization requires __FILE__ to get the path of every class file<br />
*/<br />
/////////////////////////////////////////////////////////<br />
</span><span class="keyword">function </span><span class="default">init</span><span class="keyword">(&amp;</span><span class="default">$this_class</span><span class="keyword">, </span><span class="default">$current_class</span><span class="keyword">, </span><span class="default">$params</span><span class="keyword">= </span><span class="default">NULL </span><span class="keyword">){ <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this_class</span><span class="keyword">-&gt;</span><span class="default">classFiles</span><span class="keyword">[] = </span><span class="default">__FILE__</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parent_class</span><span class="keyword">=</span><span class="default">get_parent_class</span><span class="keyword">(</span><span class="default">$current_class</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if( !empty(</span><span class="default">$parent_class</span><span class="keyword">)){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; eval(</span><span class="string">"</span><span class="default">$parent_class</span><span class="string">::init(\$this_class, \$parent_class, \$params);"</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// call_user_func() DOES NOT CORRECTLY UPDATE $this_class-&gt;classFiles:<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //call_user_func(array($parent_class,'init'),<br />
</span><span class="default">$this_class</span><span class="keyword">,</span><span class="default">$parent_class</span><span class="keyword">,</span><span class="default">$params</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
} </span><span class="comment">// init()<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
RESULT, using eval():<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; /usr/local/apache/htdocs/common/php/xobj/xobj_subclass.php<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; /usr/local/apache/htdocs/common/php/xobj/xobj.php<br />
)<br />
<br />
RESULT, using call_user_func():<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; /usr/local/apache/htdocs/common/php/xobj/xobj_subclass.php<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="27999""></a>
  <div class="note">
   <strong class="user">pollita at php dot net</strong>
   <a href="#27999" class="date">29-Dec-2002 04:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
While the method described by robinv at ecosse dot net to call a method of an arbitrarily named function will work:<br />
<br />
eval("$classname::$methodname(\$param1,\$param2);");<br />
<br />
There is another way to do so without using eval():<br />
<br />
call_user_func(array($classname,$methodname),$param1,$param2);<br />
<br />
This will do the same thing without the performance hit of eval and without the added security concerns.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26922""></a>
  <div class="note">
   <strong class="user">peterjoel.com</strong>
   <a href="#26922" class="date">18-Nov-2002 05:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can implement a getter/setter pair to emulate a class variable. The syntax isn't so weird:<br />
<br />
&lt;?<br />
<br />
class A{<br />
&nbsp;&nbsp;&nbsp; function getVar($val=NULL){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; static $class_variable = 0;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if($val != NULL){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $class_variable = $val;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $class_variable;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; function setVar($val=0){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return A::getVar($val);<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
A::setVar(3);<br />
print A::getVar();<br />
<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26814""></a>
  <div class="note">
   <strong class="user">frederik at spam pandora dot be</strong>
   <a href="#26814" class="date">13-Nov-2002 11:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
My approach to using class constants is by making them functions.<br />
Instead of <br />
<br />
$var CONSTANT = 1;<br />
<br />
I use<br />
<br />
function CONSTANT { return 1; }<br />
<br />
Now, when using this:<br />
<br />
$i = ConstantClass::CONSTANT();<br />
<br />
You can do anything with it: comparing, addition, multiplication. The syntax is a bit weird, but it works perfectly.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25455""></a>
  <div class="note">
   <strong class="user">pierrick at hydromel_no_spam_ dot net</strong>
   <a href="#25455" class="date">24-Sep-2002 08:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It's possible to access class member variables:<br />
<br />
class Test {<br />
&nbsp;&nbsp;&nbsp; var $vA = "hello world";<br />
}<br />
<br />
$class_var = get_class_vars(Test);<br />
echo $class_var["vA"];<br />
<br />
It's sound to be an ellegant way to acces them, no ? ;)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="24772""></a>
  <div class="note">
   <strong class="user">steven at caltech dot co dot uk</strong>
   <a href="#24772" class="date">28-Aug-2002 03:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Re: jdominic@prodigy.net 08-Aug-2002 05:49<br />
<br />
While it would be nice to have static instance variables you can simply create a method with the same name which returns the value you require. This means you don't have to instantiate an object when you only need its static content. For example:<br />
<br />
class Colour {<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; function default () { return "black"; }<br />
}<br />
<br />
var $backgroundColour = Colour::default ();</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="24181""></a>
  <div class="note">
   <strong class="user">jdominic at prodigy dot net</strong>
   <a href="#24181" class="date">08-Aug-2002 09:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
According to the documentation, there is no way to have a class variable, only class functions. There should be class variables, because there's no way to implement CONSTANTS. Something like this won't work:<br />
<br />
&lt;?<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; class Employee {<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var $ACTIVE_EMPLOYEE = 1;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //etc..<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo Employee::ACTIVE_EMPLOYEE;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //Also tryed:<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo Employee::$ACTIVE_EMPLOYEE<br />
<br />
?&gt;<br />
<br />
returns:<br />
Parse error: parse error, unexpected ';', expecting '(' in /home/x/public_html/Test.php on line 9<br />
<br />
It forces you to create an instance of the class:<br />
<br />
$emp = new Employee();<br />
echo $emp-&gt;ACTIVE_EMPLOYEE;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19860""></a>
  <div class="note">
   <strong class="user">carl at thep.lu.se</strong>
   <a href="#19860" class="date">13-Mar-2002 06:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that if you have two classes, 'foo' and 'bar', and a function in foo called with $instance_of_foo-&gt;func() calls bar::func2(), $this will be defined in func2, and it will point at an object of class foo. In fact, you can redefine $this to point to an object of any class before calling bar::func2() to have $this to be a reference to that object. This means that you can't have functions that can be called either as static (::) or member(-&gt;), since you won't be able to tell the difference. This is a quite unfortunate consequence of the combination of references not containing any type information and it not being possible to call an explicitly chosen base class member function (that is, if x extends y there's no clean way to call y::f() on an object of class x (The unclean way is to assign $this to $instance_of_x, call y::f(), and reset $this to its old value.)).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="14389""></a>
  <div class="note">
   <strong class="user">peter at textstore dot c() dot il</strong>
   <a href="#14389" class="date">29-Jul-2001 01:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
And now, encapsulated in constructor. Isn't it nice? Ye, and it WILL work when&nbsp;&nbsp; more objects of class are serialized &amp; unserialized ONLY when serialized in array / hash by one serialize() call - as serialize() should be used. However, when unserialized, it doesn't affect actual instances' "static" variable - thus, there will be 2 or more static variables after unserialization... but you can still change __wakeup() and to access "real"(actual) class' static value's reference, thus you have to use special function for every static value, as in example above... Ye, PHP is good!@
<br />

<br />
&lt;?
<br />
&nbsp; class O {
<br />

<br />
&nbsp;&nbsp;&nbsp; function O() {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; static $statValue=0;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $this-&gt;statValue= &amp;$statValue;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp; }
<br />

<br />
&nbsp; $o1= &amp;new O;
<br />
&nbsp; $o2= &amp;new O;
<br />

<br />
&nbsp; echo "\$o1: ".$o1-&gt;statValue."&lt;br&gt;";
<br />
&nbsp; echo "\$o2: ".$o2-&gt;statValue."&lt;br&gt;";
<br />

<br />
&nbsp; $o1-&gt;statValue= 5;
<br />
&nbsp; $o2-&gt;statValue= 10;
<br />

<br />
&nbsp; echo "\$o1: ".$o1-&gt;statValue."&lt;br&gt;";
<br />
&nbsp; echo "\$o2: ".$o2-&gt;statValue."&lt;br&gt;";
<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="14388""></a>
  <div class="note">
   <strong class="user">peter at textstore dot c() dot il</strong>
   <a href="#14388" class="date">29-Jul-2001 01:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
That's how to make class' static variable in PHP4. That means reference returned by function value() is the same for all instances of class O, thus they can share common data. This reference is common just for instances on same PHP page, of course.
<br />

<br />
&lt;?&nbsp; class O {
<br />
&nbsp;&nbsp;&nbsp; function &amp;value() {
<br />
&nbsp;&nbsp; &nbsp; static $val=0;
<br />
&nbsp;&nbsp; &nbsp; return $val;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp; }
<br />

<br />
&nbsp; $o1= &amp;new O;
<br />
&nbsp; $o2= &amp;new O;
<br />

<br />
&nbsp; echo "\$o1: ".$o1-&gt;value()."&lt;b"."r&gt;";
<br />
&nbsp; echo "\$o2: ".$o2-&gt;value()."&lt;b"."r&gt;";
<br />

<br />
&nbsp; $ref1= &amp;$o1-&gt;value();
<br />
&nbsp; $ref1= 5;
<br />

<br />
&nbsp; $ref2= &amp;$o2-&gt;value();
<br />
&nbsp; $ref2= 10;
<br />

<br />
&nbsp; echo "\$o1: ".$o1-&gt;value()."&lt;b"."r&gt;";
<br />
&nbsp; echo "\$o2: ".$o2-&gt;value()."&lt;b"."r&gt;";
<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
