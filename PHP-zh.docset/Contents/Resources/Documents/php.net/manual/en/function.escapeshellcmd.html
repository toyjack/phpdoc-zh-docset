<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>shell 元字符转义</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.escapeshellarg.html">? escapeshellarg</a></li>
      <li style="float: right;"><a href="function.exec.html">exec ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.exec.html">程序执行 函数</a></li>
    <li>shell 元字符转义</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.escapeshellcmd" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">escapeshellcmd</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">escapeshellcmd</span> &mdash; <span class="dc-title">shell 元字符转义</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.escapeshellcmd-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>escapeshellcmd</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$command</code></span>
   )</div>

  <p class="para rdfs-comment">
   <span class="function"><strong>escapeshellcmd()</strong></span> 对字符串中可能会欺骗 
   shell 命令执行任意命令的字符进行转义。
   此函数保证用户输入的数据在传送到 
   <span class="function"><a href="function.exec.html" class="function">exec()</a></span> 或
   <span class="function"><a href="function.system.html" class="function">system()</a></span> 函数，或者 <a href="language.operators.execution.html" class="link">执行操作符</a> 之前进行转义。
  </p>
  <p class="para">
    反斜线（\）会在以下字符之前插入：
   <em>#&amp;;`|*?~&lt;&gt;^()[]{}$\</em>, <em>\x0A</em>
   和 <em>\xFF</em>。 <em>&#039;</em> 和 <em>&quot;</em>
   仅在不配对儿的时候被转义。
   在 Windows 平台上，所有这些字符以及 % 都会被空格代替。（译注：实际测试发现在 Windows 平台是前缀 ^ 来转义的。）
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.escapeshellcmd-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">command</code></dt>

     <dd>

      <p class="para">
        要转义的命令。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.escapeshellcmd-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   转义后的字符串。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.escapeshellcmd-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-3667">
    <p><strong>Example #1 <span class="function"><strong>escapeshellcmd()</strong></span> example</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//&nbsp;我们故意允许任意数量的参数<br /></span><span style="color: #0000BB">$command&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'./configure&nbsp;'</span><span style="color: #007700">.</span><span style="color: #0000BB">$_POST</span><span style="color: #007700">[</span><span style="color: #DD0000">'configure_options'</span><span style="color: #007700">];<br /><br /></span><span style="color: #0000BB">$escaped_command&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">escapeshellcmd</span><span style="color: #007700">(</span><span style="color: #0000BB">$command</span><span style="color: #007700">);<br />&nbsp;<br /></span><span style="color: #0000BB">system</span><span style="color: #007700">(</span><span style="color: #0000BB">$escaped_command</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.escapeshellcmd-notes">
   <div class="warning"><strong class="warning">Warning</strong>
    <p class="para">
     <span class="function"><strong>escapeshellcmd()</strong></span> 应被用在完整的命令字符串上。
     即使如此，攻击者还是可以传入任意数量的参数。
     请使用 <span class="function"><a href="function.escapeshellarg.html" class="function">escapeshellarg()</a></span> 函数
     对单个参数进行转义。
    </p>
   </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.escapeshellcmd-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.escapeshellarg.html" class="function" rel="rdfs-seeAlso">escapeshellarg()</a> - 把字符串转码为可以在 shell 命令里使用的参数</span></li>
    <li class="member"><span class="function"><a href="function.exec.html" class="function" rel="rdfs-seeAlso">exec()</a> - 执行一个外部程序</span></li>
    <li class="member"><span class="function"><a href="function.popen.html" class="function" rel="rdfs-seeAlso">popen()</a> - 打开进程文件指针</span></li>
    <li class="member"><span class="function"><a href="function.system.html" class="function" rel="rdfs-seeAlso">system()</a> - 执行外部程序，并且显示输出</span></li>
    <li class="member"><a href="language.operators.execution.html" class="link">执行运算符</a></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="108322""></a>
  <div class="note">
   <strong class="user">phpcomment at reversiblemaps dot ath dot cx</strong>
   <a href="#108322" class="date">17-Apr-2012 08:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
escaping strings for a shell is tricky.<br />
<br />
&nbsp; If your target system is windows give up now.&nbsp; windows isn't even self consisitent in how to escape stuff.<br />
<br />
&nbsp; if unix convert everything to octal - although this is hardest to implement it's the easiest to implement correctly - there are no special cases..<br />
.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102152""></a>
  <div class="note">
   <strong class="user">nicholas at nicholaswilson dot me dot uk</strong>
   <a href="#102152" class="date">30-Jan-2011 04:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is a quirk to be aware of regarding use of echo. If you have a command which you want to execute which takes input from STDIN, you would normally do:
<br />

<br />
<span class="default">&lt;?php $output </span><span class="keyword">= </span><span class="default">shell_exec</span><span class="keyword">(</span><span class="string">"echo </span><span class="default">$input</span><span class="string"> | /the/command"</span><span class="keyword">); </span><span class="default">?&gt;
<br />
</span>
<br />
Unfortunately, this is a *bad idea* and will make your script unportable, providing a very hard-to-trace bug on some systems. Depending on how the server is set up, /bin/sh will either call /bin/bash or /bin/dash, and these have very different versions of echo. Never use echo; use printf instead which is consistent. How do you escape for printf? Do this:
<br />

<br />
<span class="default">&lt;?php
<br />
$input </span><span class="keyword">= </span><span class="string">'string to be passed *exactly* to the command'</span><span class="keyword">;
<br />
</span><span class="comment">//Escape only what is needed to get by PHP's parser; we want
<br />
//the string data PHP is holding in its buffer to be passed
<br />
//exactly to stdin buffer of the command.
<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'\\'</span><span class="keyword">, </span><span class="string">'%'</span><span class="keyword">), array(</span><span class="string">'\\\\'</span><span class="keyword">, </span><span class="string">'%%'</span><span class="keyword">), </span><span class="default">$input</span><span class="keyword">);
<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$cmd</span><span class="keyword">);
<br />

<br />
</span><span class="default">$output </span><span class="keyword">= </span><span class="default">shell_exec</span><span class="keyword">(</span><span class="string">"printf </span><span class="default">$cmd</span><span class="string"> | /path/to/command"</span><span class="keyword">);
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
For the paranoid, this torture test verifies that both shell escaping and printf's own escaping are handled correctly. Use with confidence!
<br />

<br />
<span class="default">&lt;?php
<br />

<br />
$test </span><span class="keyword">= </span><span class="string">'stuff bash interprets, space: # &amp; ; ` | * ? ~ &lt; &gt; ^ ( ) [ ] { } $ \ \x0A \xFF. \' " %'</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'stuff bash interprets, no space: #&amp;;`|*?~&lt;&gt;^()[]{}$\\x0A\xFF.\'\"%'</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'stuff bash interprets, with leading backslash: \# \&amp; \; \` \| \* \? \~ \&lt; \&gt; \^ \( \) \[ \] \{ \} \$ \\\ \\\x0A \\\xFF. \\\' \" \%'</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'printf codes: % \ (used to form %.0#-*+d, or \\ \a \b \f \n \r \t \v \" \? \062 \0062 \x032 \u0032 and \U00000032)'</span><span class="keyword">;
<br />

<br />
echo </span><span class="string">"These are the strings we are testing with:"</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.</span><span class="default">$test</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">;
<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">$test</span><span class="keyword">;
<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'\\'</span><span class="keyword">, </span><span class="string">'%'</span><span class="keyword">), array(</span><span class="string">'\\\\'</span><span class="keyword">, </span><span class="string">'%%'</span><span class="keyword">), </span><span class="default">$test</span><span class="keyword">);
<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$cmd</span><span class="keyword">);
<br />

<br />
echo </span><span class="default">PHP_EOL</span><span class="keyword">.</span><span class="string">"This is the output using the escaping mechanism given:"</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">;
<br />
echo `</span><span class="string">printf </span><span class="default">$cmd</span><span class="string"> | cat</span><span class="keyword">`.</span><span class="default">PHP_EOL</span><span class="keyword">;
<br />

<br />
echo </span><span class="default">PHP_EOL</span><span class="keyword">.</span><span class="string">"They should match exactly"</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">;
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98580""></a>
  <div class="note">
   <strong class="user">carlos at wfmh dot org dot pl dot REMOVE dot COM</strong>
   <a href="#98580" class="date">24-Jun-2010 01:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Mind it does not escape ! (exclamation mark). So if you want to i.e. printf() commands for later use in shell (i.e. by pasting to the console) you need to escape all exclamation marks or shell will try to process ! as history reference. This approach shall suffice:
<br />

<br />
<span class="default">&lt;?php $scaped </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'!'</span><span class="keyword">, </span><span class="string">'\!'</span><span class="keyword">, </span><span class="default">escapeshellarg</span><span class="keyword">( </span><span class="default">$str </span><span class="keyword">) ); </span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80299""></a>
  <div class="note">
   <strong class="user">davidwhthomas</strong>
   <a href="#80299" class="date">08-Jan-2008 11:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To extract an archive file to a specific folder using exec() :<br />
<br />
<span class="default">&lt;?php<br />
$result </span><span class="keyword">= </span><span class="default">exec</span><span class="keyword">(</span><span class="default">escapeshellcmd</span><span class="keyword">(</span><span class="string">"tar -xvvf /path/to/archive.tar -C /path/to/extract/to/"</span><span class="keyword">));<br />
</span><span class="default">?&gt;<br />
</span><br />
escapeshellcmd() is used here because I am getting the file path via user input / upload.<br />
<br />
DT</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73169""></a>
  <div class="note">
   <strong class="user">Leon</strong>
   <a href="#73169" class="date">12-Feb-2007 01:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function is great -- except when you need to legitimately use an escaped character as part of your command.&nbsp; The code below leaves the parts of the command that are enclosed within single quotes alone, but escapes the rest eg:<br />
<br />
"echo Never use the '&lt;blink&gt;' tag ; cat /etc/passwd"<br />
becomes:<br />
"echo Never use the '&lt;blink&gt;' tag \; cat /etc/passwd"<br />
and not:<br />
"echo Never use the '\&lt;blink\&gt;' tag \; cat /etc/passwd"<br />
<br />
i.e, we really want the ';' escaped, but not the HTML tag.&nbsp; I really needed the code below in order to run the external ImageMagick's 'convert' command properly and safely...<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// Escape whole string<br />
</span><span class="default">$cmdQ </span><span class="keyword">= </span><span class="default">escapeshellcmd</span><span class="keyword">(</span><span class="default">$cmd</span><span class="keyword">);<br />
<br />
&nbsp;</span><span class="comment">// Build array of quoted parts, and the same escaped<br />
</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">'/\'[^\']+\'/'</span><span class="keyword">, </span><span class="default">$cmd</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
</span><span class="default">$matches </span><span class="keyword">= </span><span class="default">current</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">);<br />
</span><span class="default">$quoted </span><span class="keyword">= array();<br />
foreach( </span><span class="default">$matches </span><span class="keyword">as </span><span class="default">$match </span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$quoted</span><span class="keyword">[</span><span class="default">escapeshellcmd</span><span class="keyword">(</span><span class="default">$match</span><span class="keyword">)] = </span><span class="default">$match</span><span class="keyword">;<br />
<br />
</span><span class="comment">// Replace sections that were single quoted with original content<br />
</span><span class="keyword">foreach( </span><span class="default">$quoted </span><span class="keyword">as </span><span class="default">$search </span><span class="keyword">=&gt; </span><span class="default">$replace </span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$cmdQ </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">( </span><span class="default">$search</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$cmdQ </span><span class="keyword">);<br />
<br />
return </span><span class="default">$cmdQ</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="67811""></a>
  <div class="note">
   <strong class="user">abennett at clarku dot edu</strong>
   <a href="#67811" class="date">05-Jul-2006 08:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've got a php script that needs to pass a username and password via exec to a perl script.&nbsp; The problem is valid password characters were getting escaped...<br />
<br />
Here's a little perl function I wrote to fix it.<br />
<br />
sub unescape_string {<br />
&nbsp;&nbsp; &nbsp;&nbsp; my $string = shift;<br />
&nbsp;&nbsp; &nbsp;&nbsp; # all these interpolated regex's are slow, so if there's no<br />
&nbsp;&nbsp; &nbsp;&nbsp; # backslash in the string don't bother with it<br />
&nbsp;&nbsp; &nbsp;&nbsp; # index() is faster then a regex<br />
&nbsp;&nbsp; &nbsp;&nbsp; if ( ! index($string,'\\\\') ) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; return $string;<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; my @characters = ('#', '&amp;', ';', '`', '|', '*', '?', '~', '&lt;', '&gt;', '^', '(', ')',<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; '[', ']', '{', '}', '$', '\\', ',', ' ', '\x0A', '\xFF' );<br />
&nbsp;&nbsp; &nbsp;&nbsp; my $character;<br />
&nbsp;&nbsp; &nbsp;&nbsp; foreach $character (@characters) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $character = quotemeta($character);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; my $pattern = "\\\\(" . $character . ")";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $string =~ s/$pattern/$1/g;<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; return $string;<br />
}<br />
<br />
Hope this is useful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63179""></a>
  <div class="note">
   <strong class="user">ceejay at trashfactory dot de</strong>
   <a href="#63179" class="date">15-Mar-2006 01:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Well guys, i find it very hard that escapeshellarg and escapeshellcmd are forcely run when passing a command to exec, system or popen, when safe_mode is turned on.<br />
<br />
Right now, i did not find any working solution to pass commands like this:<br />
cmd -arg1 -arg2 "&lt;BLA varname=\"varvalue\" varname1=\"varvalue1\" /&gt;"<br />
<br />
it is just the case, that the parameter for arg2 which is a string that looks like an HTML-Tag with various attributes set, all attributes of the string in arg2 gets splitted by the whitespaces within. this wont happen with safe_mode turned off, so it must be one of the escapefunctions, that breaks functionality. <br />
<br />
In order to circumvent this, i have made a temporary solution, which dynamically creates a skriptfile (by fopen), which just contains the whole command with arguments, and then execute that skriptfile. i dont like that solution, but in the other hand, safe_mode cannot be easily turned off on that server.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56720""></a>
  <div class="note">
   <strong class="user">cast3r</strong>
   <a href="#56720" class="date">13-Sep-2005 02:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
"normal any user on linux can view almost any directory so:<br />
ls / -als will print a complete list of any file in the linux filesystem including its size, security and hidden files as well."<br />
ls / -alsR is the whole filesystem.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51827""></a>
  <div class="note">
   <strong class="user">docey</strong>
   <a href="#51827" class="date">12-Apr-2005 02:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
the main reason for quoting a command is that it not multiple&nbsp; command can be joined. i don't know for sure if this is the right syntax but remeber that this can do some nice security breaks. here's one way of how to know exactly what your trying to break into for.<br />
<br />
normal any user on linux can view almost any directory so:<br />
ls / -als will print a complete list of any file in the linux filesystem including its size, security and hidden files as well.<br />
<br />
now the output would only become known to php and never will the user be able to view this data unless the php script would actual start to print it out. like passtru does!! but a good php coder knows never to use passtru unless not otherwise possible. <br />
<br />
but what would happen if you can direct the output from ls also from that same commandline to a file in the webroot most webserver still default their base-webroot to /var/www/ so storing it there in text file to download it later and you can simply take coffee while checking wich files can be read by php security mode and then simply use the cp command to copy those to the webroot and download them to your own hard-disk. without a list of the files you can only guess where to copy from! and thats harder then guessing the root password. <br />
<br />
so if the first command was quoted it is not possible to attach another command because of a syntax error. think of all the thinks you can do once you got a complete list of every file on the filesystem. including mounted once via NFS and others. security starts at keeping the door hidden.<br />
<br />
also another nice command for hanging the webserver can be "php <span class="default">&lt;?php </span><span class="keyword">while(</span><span class="default">true</span><span class="keyword">){ </span><span class="default">exec</span><span class="keyword">(</span><span class="string">'ls / -als'</span><span class="keyword">); }; </span><span class="default">?&gt;</span>" this keeps creating a file list on the entire filesystem wich not only keeps the hard-disk(s) bussy but also memory and cpu&nbsp;&nbsp; wich must store the returned list. so keeping in mind not all command accepted from users can be used blind. <br />
<br />
actualy never accept any command from external sources only proven built-in predefined commands should be executed.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49527""></a>
  <div class="note">
   <strong class="user">trisk at earthling dot net</strong>
   <a href="#49527" class="date">31-Jan-2005 07:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function does not work as shown in the php.net examples.<br />
<br />
If you put your encoded filename into double-quotes as they suggest, then it will break on certain characters in filenames, such as ampersand.<br />
<br />
For example if you have a filename called "foo &amp; bar.jpg" and you use this function on it, your resulting filename when double-quoted will produce this and not be found:<br />
<br />
"foo \&amp; bar.jpg"<br />
<br />
If you need to have a single argument where spaces are included then do not use this function with added double-quotes, use escapeshellarg() which encloses the whole string in single quotes.<br />
<br />
I do not understand which purpose this particular function is intended for.&nbsp; I can't see any use for it, unless you pass it through another function and convert spaces " " to "\ ", which would allow you to use the string directly on the command line.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
