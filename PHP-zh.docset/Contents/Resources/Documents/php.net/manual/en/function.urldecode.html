<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>解码已编码的 URL 字符串</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.rawurlencode.html">? rawurlencode</a></li>
      <li style="float: right;"><a href="function.urlencode.html">urlencode ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.url.html">URL 函数</a></li>
    <li>解码已编码的 URL 字符串</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.urldecode" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">urldecode</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">urldecode</span> &mdash; <span class="dc-title">解码已编码的 URL 字符串</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.urldecode-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>urldecode</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$str</code></span>
   )</div>

  <p class="para rdfs-comment">
   解码给出的已编码字符串中的任何
   <em>%<span class="replaceable">##</span></em>。
   加号（&#039;<em>+</em>&#039;）被解码成一个空格字符。
   
  </p>
 </div>

 
 <div class="refsect1 parameters" id="refsect1-function.urldecode-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">str</code></dt>

     <dd>

      <p class="para">
       要解码的字符串。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


  <div class="refsect1 returnvalues" id="refsect1-function.urldecode-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回解码后的字符串。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.urldecode-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-4115">
    <p><strong>Example #1 <span class="function"><strong>urldecode()</strong></span> 示例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$query&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"my=apples&amp;are=green+and+red"</span><span style="color: #007700">;<br /><br />foreach&nbsp;(</span><span style="color: #0000BB">explode</span><span style="color: #007700">(</span><span style="color: #DD0000">'&amp;'</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$query</span><span style="color: #007700">)&nbsp;as&nbsp;</span><span style="color: #0000BB">$chunk</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000BB">$param&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">explode</span><span style="color: #007700">(</span><span style="color: #DD0000">"="</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$chunk</span><span style="color: #007700">);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(</span><span style="color: #0000BB">$param</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000BB">printf</span><span style="color: #007700">(</span><span style="color: #DD0000">"Value&nbsp;for&nbsp;parameter&nbsp;\"%s\"&nbsp;is&nbsp;\"%s\"&lt;br/&gt;\n"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">urldecode</span><span style="color: #007700">(</span><span style="color: #0000BB">$param</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">]),&nbsp;</span><span style="color: #0000BB">urldecode</span><span style="color: #007700">(</span><span style="color: #0000BB">$param</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">]));<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.urldecode-notes">
  <h3 class="title">注释</h3>
  <div class="warning"><strong class="warning">Warning</strong>
   <p class="para">
    超全局变量  <var class="varname"><var class="varname"><a href="reserved.variables.get.html" class="classname">$_GET</a></var></var> 和 <var class="varname"><var class="varname"><a href="reserved.variables.request.html" class="classname">$_REQUEST</a></var></var> 已经被解码了。对 <var class="varname"><var class="varname"><a href="reserved.variables.get.html" class="classname">$_GET</a></var></var> 或   <var class="varname"><var class="varname"><a href="reserved.variables.request.html" class="classname">$_REQUEST</a></var></var> 里的元素使用 <span class="function"><strong>urldecode()</strong></span> 将会导致不可预计和危险的结果。
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.urldecode-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.urlencode.html" class="function" rel="rdfs-seeAlso">urlencode()</a> - 编码 URL 字符串</span></li>
    <li class="member"><span class="function"><a href="function.rawurlencode.html" class="function" rel="rdfs-seeAlso">rawurlencode()</a> - 按照 RFC 1738 对 URL 进行编码</span></li>
    <li class="member"><span class="function"><a href="function.rawurldecode.html" class="function" rel="rdfs-seeAlso">rawurldecode()</a> - 对已编码的 URL 字符串进行解码</span></li>
    <li class="member"><a href="http://www.faqs.org/rfcs/rfc3986" class="link external" title="Link : http://www.faqs.org/rfcs/rfc3986">&raquo;&nbsp;RFC 3986</a></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="113119""></a>
  <div class="note">
   <strong class="user">aravind dot a dot padmanabhan at gmail dot com</strong>
   <a href="#113119" class="date">02-Sep-2013 07:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems that the $_REQUEST global parameter is automatically decoded only if the content type is application/x-www-form-urlencoded.<br />
<br />
if the content type is multipart/form-data. the data remains un-decoded. and we have to manually handle the decoding at our end</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101401""></a>
  <div class="note">
   <strong class="user">alejandro at devenet dot net</strong>
   <a href="#101401" class="date">15-Dec-2010 03:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When the client send Get data, utf-8 character encoding have a tiny problem with the urlencode.
<br />
Consider the "o" character. 
<br />
Some clients can send (as example)
<br />
foo.php?myvar=%BA
<br />
and another clients send
<br />
foo.php?myvar=%C2%BA (The "right" url encoding)
<br />

<br />
in this scenary, you assign the value into variable $x
<br />

<br />
<span class="default">&lt;?php
<br />
$x </span><span class="keyword">= </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">'myvar'</span><span class="keyword">];
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
$x store: in the first case "?" (bad) and in the second case "o" (good)
<br />

<br />
To fix that, you can use this function:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">to_utf8</span><span class="keyword">( </span><span class="default">$string </span><span class="keyword">) {
<br />
</span><span class="comment">// From <a href="http://w3.org/International/questions/qa-forms-utf-8.html" rel="nofollow" target="_blank">http://w3.org/International/questions/qa-forms-utf-8.html</a>
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if ( </span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'%^(?:
<br />
&nbsp;&nbsp; &nbsp;&nbsp; [\x09\x0A\x0D\x20-\x7E]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ASCII
<br />
&nbsp;&nbsp;&nbsp; | [\xC2-\xDF][\x80-\xBF]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; # non-overlong 2-byte
<br />
&nbsp;&nbsp;&nbsp; | \xE0[\xA0-\xBF][\x80-\xBF]&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; # excluding overlongs
<br />
&nbsp;&nbsp;&nbsp; | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}&nbsp; # straight 3-byte
<br />
&nbsp;&nbsp;&nbsp; | \xED[\x80-\x9F][\x80-\xBF]&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; # excluding surrogates
<br />
&nbsp;&nbsp;&nbsp; | \xF0[\x90-\xBF][\x80-\xBF]{2}&nbsp; &nbsp; &nbsp; # planes 1-3
<br />
&nbsp;&nbsp;&nbsp; | [\xF1-\xF3][\x80-\xBF]{3}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # planes 4-15
<br />
&nbsp;&nbsp;&nbsp; | \xF4[\x80-\x8F][\x80-\xBF]{2}&nbsp; &nbsp; &nbsp; # plane 16
<br />
)*$%xs'</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">) ) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$string</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; } else {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">iconv</span><span class="keyword">( </span><span class="string">'CP1252'</span><span class="keyword">, </span><span class="string">'UTF-8'</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; }
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
and assign in this way:
<br />

<br />
<span class="default">&lt;?php
<br />
$x </span><span class="keyword">= </span><span class="default">to_utf8</span><span class="keyword">( </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">'myvar'</span><span class="keyword">] );
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
$x store: in the first case "o" (good) and in the second case "o" (good)
<br />

<br />
Solve a lot of i18n problems.
<br />

<br />
Please fix the auto-urldecode of $_GET var in the next PHP version.
<br />

<br />
Bye.
<br />

<br />
Alejandro Salamanca</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90976""></a>
  <div class="note">
   <strong class="user">mail dot roliveira at gmail dot com</strong>
   <a href="#90976" class="date">19-May-2009 01:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Send json to PHP via AJAX (POST)
<br />

<br />
If you send json data via ajax, and encode it with encodeURIComponent in javascript, then on PHP side, you will have to do stripslashes on your $_POST['myVar'].
<br />

<br />
After this, you can do json_decode on your string.
<br />

<br />
Ex.:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="comment">// first use encodeURIComponent on javascript to encode the string
<br />
// receive json string and prepare it to json_decode
<br />
</span><span class="default">$jsonStr </span><span class="keyword">= </span><span class="default">stripslashes </span><span class="keyword">(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'action'</span><span class="keyword">]);
<br />
</span><span class="comment">// decode to php object
<br />
</span><span class="default">$json </span><span class="keyword">= </span><span class="default">json_decode </span><span class="keyword">(</span><span class="default">$jsonStr</span><span class="keyword">);
<br />

<br />
</span><span class="comment">// $json is now a php object
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83798""></a>
  <div class="note">
   <strong class="user">Jan Vratny</strong>
   <a href="#83798" class="date">12-Jun-2008 02:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
mkaganer at gmail dot com:<br />
<br />
try using encodeURI() instead of encode() in javascript. That worked for me, while your solution did not on __some__ national characters (at least in IE6).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82281""></a>
  <div class="note">
   <strong class="user">Joe</strong>
   <a href="#82281" class="date">03-Apr-2008 08:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It's worth pointing out that if you are using AJAX and need to encode strings that are being sent to a PHP application, you may not need to decode them in PHP.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">echo </span><span class="default">stripslashes</span><span class="keyword">(</span><span class="default">nl2br</span><span class="keyword">(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'message'</span><span class="keyword">]));<br />
</span><span class="default">?&gt;<br />
</span><br />
Will properly output a message sent with the javascript code if the message is encoded:<br />
<br />
message = encodeURIComponent(message)<br />
<br />
And is sent with an AJAX POST request with the header:<br />
ajaxVar.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79595""></a>
  <div class="note">
   <strong class="user">mkaganer at gmail dot com</strong>
   <a href="#79595" class="date">04-Dec-2007 11:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
B.H.<br />
<br />
I had troubles converting Unicode-encoded data in $_GET (like this: %u05D8%u05D1%u05E2) which is generated by JavaScript's escape() function to UTF8 for server-side processing.<br />
<br />
Finally, i've found a simple solution (only 3 lines of code) that does it (at least in my configuration):<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; </span><span class="keyword">function </span><span class="default">utf8_urldecode</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/%u([0-9a-f]{3,4})/i"</span><span class="keyword">,</span><span class="string">"&amp;#x\\1;"</span><span class="keyword">,</span><span class="default">urldecode</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">html_entity_decode</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">,</span><span class="default">null</span><span class="keyword">,</span><span class="string">'UTF-8'</span><span class="keyword">);;<br />
&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
note that documentation for html_entity_decode() states that "Support for multi-byte character sets was added at PHP 5.0.0" so this might not work for PHP 4</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70180""></a>
  <div class="note">
   <strong class="user">tikitiki at mybboard dot com</strong>
   <a href="#70180" class="date">06-Oct-2006 12:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is a rewritten example that does the same thing but runs cleaner.
<br />

<br />
<span class="default">&lt;?php
<br />
$a </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'&amp;'</span><span class="keyword">, </span><span class="default">$QUERY_STRING</span><span class="keyword">);
<br />

<br />
foreach(</span><span class="default">$a </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$b</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp; </span><span class="default">$b </span><span class="keyword">= </span><span class="default">split</span><span class="keyword">(</span><span class="string">'='</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">);
<br />
&nbsp;&nbsp; echo </span><span class="string">'Value for parameter '</span><span class="keyword">.</span><span class="default">htmlspecialchars</span><span class="keyword">(</span><span class="default">urldecode</span><span class="keyword">(</span><span class="default">$b</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">])).</span><span class="string">' is '</span><span class="keyword">.</span><span class="default">htmlspecialchars</span><span class="keyword">(</span><span class="default">urldecode</span><span class="keyword">(</span><span class="default">$b</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">])).</span><span class="string">"&lt;br /&gt;\n"</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="66301""></a>
  <div class="note">
   <strong class="user">Visual</strong>
   <a href="#66301" class="date">18-May-2006 09:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are escaping strings in javascript and want to decode them in PHP with urldecode (or want PHP to decode them automatically when you're putting them in the query string or post request), you should use the javascript function encodeURIComponent() instead of escape(). Then you won't need any of the fancy custom utf_urldecode functions from the previous comments.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="64676""></a>
  <div class="note">
   <strong class="user">rosty dot kerei at gmail dot com</strong>
   <a href="#64676" class="date">19-Apr-2006 06:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function doesn't decode unicode characters. I wrote a function that does.<br />
<br />
function unicode_urldecode($url)<br />
{<br />
&nbsp;&nbsp;&nbsp; preg_match_all('/%u([[:alnum:]]{4})/', $url, $a);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; foreach ($a[1] as $uniord)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $dec = hexdec($uniord);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $utf = '';<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if ($dec &lt; 128)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $utf = chr($dec); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if ($dec &lt; 2048)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; { <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $utf = chr(192 + (($dec - ($dec % 64)) / 64)); <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $utf .= chr(128 + ($dec % 64)); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; { <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $utf = chr(224 + (($dec - ($dec % 4096)) / 4096)); <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $utf .= chr(128 + ((($dec % 4096) - ($dec % 64)) / 64)); <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $utf .= chr(128 + ($dec % 64)); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $url = str_replace('%u'.$uniord, $utf, $url);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return urldecode($url);<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51630""></a>
  <div class="note">
   <strong class="user">spam at soiland dot no</strong>
   <a href="#51630" class="date">06-Apr-2005 02:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
About reg_var and "html reserved words"<br />
<br />
Do not add spaces as the user suggests.<br />
<br />
Instead, do what all HTML standards says and encode &amp; in URLs as &amp;amp; in your HTML. <br />
<br />
The reason why &amp; works "most of the time" is that browsers are forgiving and just decode the &amp; as the &amp;-sign. This breaks whenever you have a variable that matches an HTML entity, like "gt" or "copy" or whatever. &amp;copy in your URL will be interpreted as &amp;copy;&nbsp; (the ; is not mandatory in SGML as it is "implied". In XML it is mandatory.).&nbsp;&nbsp; The result will be the same as if you had inserted the actual character into your source code, for instance by pressing alt-0169 and actually inserted ? in your HTML.<br />
<br />
Ie, use:<br />
<br />
&lt;a href="?name=stain&amp;amp;fish=knott"&gt;mylink&lt;/a&gt;<br />
<br />
Note that the decoding of &amp;amp; to &amp; is done in the browser, and it's done right after splitting the HTML into tags, attributes and content, but it works both for attributes and content.<br />
<br />
This mean you should &amp;entitify all &amp;-s in any other HTML attributes as well, such as in a form with <br />
&lt;input name="fish" value="fish &amp;amp; fries" /&gt;.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="48481""></a>
  <div class="note">
   <strong class="user">Matt Johnson</strong>
   <a href="#48481" class="date">26-Dec-2004 01:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A reminder: if you are considering using urldecode() on a $_GET variable, DON'T!<br />
<br />
Evil PHP:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment"># BAD CODE! DO NOT USE!<br />
</span><span class="default">$term </span><span class="keyword">= </span><span class="default">urldecode</span><span class="keyword">(</span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">'sterm'</span><span class="keyword">]);<br />
</span><span class="default">?&gt;<br />
</span><br />
Good PHP:<br />
<br />
<span class="default">&lt;?php<br />
$term </span><span class="keyword">= </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">'sterm'</span><span class="keyword">];<br />
</span><span class="default">?&gt;<br />
</span><br />
The webserver will arrange for $_GET to have been urldecoded once already by the time it reaches you!<br />
<br />
Using urldecode() on $_GET can lead to extreme badness, PARTICULARLY when you are assuming "magic quotes" on GET is protecting you against quoting.<br />
<br />
Hint: script.php?sterm=%2527 [...]<br />
<br />
PHP "receives" this as %27, which your urldecode() will convert to "'" (the singlequote). This may be CATASTROPHIC when injecting into SQL or some PHP functions relying on escaped quotes -- magic quotes rightly cannot detect this and will not protect you!<br />
<br />
This "common error" is one of the underlying causes of the Santy.A worm which affects phpBB &lt; 2.0.11.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="36528""></a>
  <div class="note">
   <strong class="user">caribe at flash-brasil dot com dot br</strong>
   <a href="#36528" class="date">13-Oct-2003 10:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To allow urldecode to work with Brazilian characters as ? ? ? and other just place this header command :<br />
<br />
header('Content-type: text/html; CHARSET=gb2312');</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="36435""></a>
  <div class="note">
   
   <a href="#36435" class="date">09-Oct-2003 05:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
nataniel, your function needs to be corrected as follows:<br />
<br />
------------------------------------------------------------<br />
function unicode_decode($txt) {<br />
&nbsp; return ereg_replace('%u([[:alnum:]]{4})', '&amp;#x\1;',$txt);<br />
}<br />
------------------------------------------------------------<br />
<br />
since some codes does not begin with %u0.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="34280""></a>
  <div class="note">
   <strong class="user">tomas at penajaca dot com dot br</strong>
   <a href="#34280" class="date">21-Jul-2003 08:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
urldecode does not decode "%0"&nbsp; bypassing it. I can cause troble when you are working with fixed lenght strings.<br />
<br />
You can you the function below.<br />
<br />
function my_urldecode($string){<br />
<br />
&nbsp; $array = split ("%",$string);<br />
<br />
&nbsp; if (is_array($array)){<br />
&nbsp;&nbsp;&nbsp; while (list ($k,$v) = each ($array)){<br />
&nbsp;&nbsp; &nbsp; &nbsp; $ascii = base_convert ($v,16,10);<br />
&nbsp;&nbsp; &nbsp; &nbsp; $ret .= chr ($ascii);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;}<br />
&nbsp;return ("$ret");<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31494""></a>
  <div class="note">
   <strong class="user">regindk at hotmail dot com</strong>
   <a href="#31494" class="date">24-Apr-2003 03:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
About: bellani at upgrade4 dot it<br />
$str = "pippo.php?param1=&amp;reg_var";<br />
echo rawurldecode($str);<br />
Gives:<br />
pippo.php?param1=?_var<br />
Instead of using a space you should exchange &amp; with the correct W3C &amp;amp;<br />
Like this:<br />
$str = "pippo.php?param1=&amp;amp;reg_var";<br />
echo rawurldecode($str);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30225""></a>
  <div class="note">
   <strong class="user">bellani at upgrade4 dot it</strong>
   <a href="#30225" class="date">11-Mar-2003 07:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you have a "html reserved word" as variable name (i.e. "reg_var") and you pass it as an argument you will get&nbsp; a wrong url. i.e.<br />
<br />
&lt;a href="pippo.php?param1=&amp;reg_var="&gt;go&lt;/a&gt;<br />
<br />
you will get a wrong url like this <br />
<br />
"pippo.php?param1=?_var"<br />
<br />
Simply add a space between "&amp;" and "reg_var" and it will work!<br />
<br />
&lt;a href="pippo.php?param1=&amp; reg_var="&gt;go&lt;/a&gt;<br />
<br />
"pippo.php?param1=&amp;%20reg_var"<br />
<br />
Works!!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="29272""></a>
  <div class="note">
   <strong class="user">smolniy at mtu dot ru</strong>
   <a href="#29272" class="date">07-Feb-2003 11:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For compatibility of new and old brousers:<br />
<br />
%xx -&gt; char<br />
%u0xxxx -&gt; char<br />
<br />
function unicode_decode($txt) {<br />
&nbsp;$txt = ereg_replace('%u0([[:alnum:]]{3})', '&amp;#x\1;',$txt);<br />
&nbsp;$txt = ereg_replace('%([[:alnum:]]{2})', '&amp;#x\1;',$txt);<br />
&nbsp;return ($txt);<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="21547""></a>
  <div class="note">
   <strong class="user">igjav at cesga dot es</strong>
   <a href="#21547" class="date">16-May-2002 08:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This seems to decode correctly between most browsers and charater coding configurations. Specially indicated for direct parsing of URL as it comes on environment variables:<br />
<br />
function crossUrlDecode($source) {<br />
&nbsp;&nbsp;&nbsp; $decodedStr = '';<br />
&nbsp;&nbsp;&nbsp; $pos = 0;<br />
&nbsp;&nbsp;&nbsp; $len = strlen($source);<br />
<br />
&nbsp;&nbsp;&nbsp; while ($pos &lt; $len) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $charAt = substr ($source, $pos, 1);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if ($charAt == '?') {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $char2 = substr($source, $pos, 2);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $decodedStr .= htmlentities(utf8_decode($char2),ENT_QUOTES,'ISO-8859-1');<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pos += 2;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; elseif(ord($charAt) &gt; 127) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $decodedStr .= "&amp;#".ord($charAt).";";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pos++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; elseif($charAt == '%') {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pos++;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $hex2 = substr($source, $pos, 2);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $dechex = chr(hexdec($hex2));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if($dechex == '?') {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pos += 2;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(substr($source, $pos, 1) == '%') {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pos++;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $char2a = chr(hexdec(substr($source, $pos, 2)));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $decodedStr .= htmlentities(utf8_decode($dechex . $char2a),ENT_QUOTES,'ISO-8859-1');<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $decodedStr .= htmlentities(utf8_decode($dechex));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $decodedStr .= $dechex;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pos += 2;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $decodedStr .= $charAt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pos++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; return $decodedStr;<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
