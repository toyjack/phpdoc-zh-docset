<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>Fetch a particular section of the body of the message</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.imap-fetch-overview.html">? imap_fetch_overview</a></li>
      <li style="float: right;"><a href="function.imap-fetchheader.html">imap_fetchheader ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.imap.html">IMAP 函数</a></li>
    <li>Fetch a particular section of the body of the message</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.imap-fetchbody" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">imap_fetchbody</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7)</p><p class="refpurpose"><span class="refname">imap_fetchbody</span> &mdash; <span class="dc-title">Fetch a particular section of the body of the message</span></p>

 </div>
 <div class="refsect1 description" id="refsect1-function.imap-fetchbody-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>imap_fetchbody</strong></span>
    ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$imap_stream</code></span>
   , <span class="methodparam"><span class="type">int</span> <code class="parameter">$msg_number</code></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$section</code></span>
   [, <span class="methodparam"><span class="type">int</span> <code class="parameter">$options</code><span class="initializer"> = 0</span></span>
  ] )</div>

  <p class="para rdfs-comment">
   Fetch of a particular section of the body of the specified messages. 
   Body parts are not decoded by this function.
  </p>
 </div>

 <div class="refsect1 parameters" id="refsect1-function.imap-fetchbody-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    <dt>
<code class="parameter">
imap_stream</code></dt>
<dd>
<p class="para">由 <span class="function"><a href="function.imap-open.html" class="function">imap_open()</a></span> 返回的 IMAP 流。</p></dd>

    
     <dt>
<code class="parameter">msg_number</code></dt>

     <dd>

      <p class="para">
       The message number
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">section</code></dt>

     <dd>

      <p class="para">
       The part number. It is a string of integers delimited by period which
       index into a body part list as per the IMAP4 specification
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">options</code></dt>

     <dd>

      <p class="para">
       A bitmask with one or more of the following:
       <ul class="itemizedlist">
        <li class="listitem">
         <span class="simpara">
          <strong><code>FT_UID</code></strong> - The <code class="parameter">msg_number</code> is a UID
         </span>
        </li>
        <li class="listitem">
         <span class="simpara">
          <strong><code>FT_PEEK</code></strong> - Do not set the \Seen flag if
          not already set
         </span>
        </li>
        <li class="listitem">
         <span class="simpara">
          <strong><code>FT_INTERNAL</code></strong> - The return string is in
          internal format, will not canonicalize to CRLF.
         </span>
        </li>
       </ul>
      </p>
     </dd>

    
   </dl>

  </p>
 </div>

 <div class="refsect1 returnvalues" id="refsect1-function.imap-fetchbody-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   Returns a particular section of the body of the specified messages as a
   text string.
  </p>
 </div>

 <div class="refsect1 seealso" id="refsect1-function.imap-fetchbody-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.imap-savebody.html" class="function" rel="rdfs-seeAlso">imap_savebody()</a> - Save a specific body section to a file</span></li>
    <li class="member"><span class="function"><a href="function.imap-fetchstructure.html" class="function" rel="rdfs-seeAlso">imap_fetchstructure()</a> - Read the structure of a particular message</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="116428""></a>
  <div class="note">
   <strong class="user">mike at lathyrus dot net</strong>
   <a href="#116428" class="date">02-Jan-2015 01:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I spent hours religously thinking that<br />
<br />
imap_fetchbody($mbox,$email_number,1.2) <br />
<br />
would fetch the html body, and in many cases this did not work.&nbsp; It turns out that simple message can have a simple [parts] stucture so this became true:<br />
<br />
imap_fetchbody($mbox,$email_number,1) - PLAIN<br />
imap_fetchbody($inbox,$email_number,2) - HTML<br />
<br />
Check for empty string before using the latter.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115668""></a>
  <div class="note">
   <strong class="user">tabaccoandcoffee at gmail dot com</strong>
   <a href="#115668" class="date">05-Sep-2014 05:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Sorry for my English. <br />
Rather than quoted_printable_decode, you can use the function imap_qprint ($body)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111031""></a>
  <div class="note">
   <strong class="user">red dot ender at yahoo dot com</strong>
   <a href="#111031" class="date">08-Jan-2013 10:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had some problems with the german umlauts from a gmail fetched text. I lost an hour trying to find a solution. 
<br />

<br />
Hopefully this helps someone in need :)
<br />

<br />
<span class="default">&lt;?php
<br />
$text </span><span class="keyword">= </span><span class="default">trim</span><span class="keyword">( </span><span class="default">utf8_encode</span><span class="keyword">( </span><span class="default">quoted_printable_decode</span><span class="keyword">(
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">imap_fetchbody</span><span class="keyword">( </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inbox</span><span class="keyword">, </span><span class="default">$emailNo</span><span class="keyword">, </span><span class="default">$section </span><span class="keyword">) ) ) );
<br />

<br />
</span><span class="default">$section was previously defined</span><span class="keyword">:
<br />
</span><span class="default">$section </span><span class="keyword">= empty( </span><span class="default">$attachments </span><span class="keyword">) ? </span><span class="default">1 </span><span class="keyword">: </span><span class="default">1.1</span><span class="keyword">;
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109130""></a>
  <div class="note">
   <strong class="user">gesti at gmx dot com</strong>
   <a href="#109130" class="date">22-Jun-2012 08:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
How to give more then one option in the "options" parameter:<br />
It took me some time to realize how easy it is, so just in case some one else would be puzzled at this point:<br />
<span class="default">&lt;?php<br />
imap_fetchbody</span><span class="keyword">(</span><span class="default">$imap_stream</span><span class="keyword">, </span><span class="default">$msg_number</span><span class="keyword">, </span><span class="default">$section</span><span class="keyword">, </span><span class="default">FT_UID </span><span class="keyword">| </span><span class="default">FT_PEEK</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108884""></a>
  <div class="note">
   <strong class="user">caevan at amkd dot com dot au</strong>
   <a href="#108884" class="date">01-Jun-2012 11:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I tried using the function add_part_to_array below and noticed a few errors were thrown. If there are no 'parts' in the structure then if (sizeof($obj-&gt;parts) &gt; 0) will throw an error. As well $prefix is not defined here is the code I have updated. I have left the original lines commented out. I have tested reading emails from a gmail account and so far so good.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// Sub function for create_part_array(). Only called by create_part_array() and itself. <br />
</span><span class="keyword">function </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$obj</span><span class="keyword">, </span><span class="default">$partno</span><span class="keyword">, &amp; </span><span class="default">$part_array</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="default">$partno</span><span class="keyword">, </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$obj</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; if (</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">type </span><span class="keyword">== </span><span class="default">2</span><span class="keyword">) { </span><span class="comment">// Check to see if the part is an attached email message, as in the RFC-822 type<br />
//&nbsp; &nbsp; &nbsp; &nbsp; if (sizeof($obj-&gt;parts) &gt; 0) {&nbsp; &nbsp; // Check to see if the email has parts<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">array_key_exists</span><span class="keyword">(</span><span class="string">'parts'</span><span class="keyword">,</span><span class="default">$obj</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count </span><span class="keyword">=&gt; </span><span class="default">$part</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Iterate here again to compensate for the broken way that imap_fetchbody() handles attachments<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$part</span><span class="keyword">-&gt;</span><span class="default">parts</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$part</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count2 </span><span class="keyword">=&gt; </span><span class="default">$part2</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$part2</span><span class="keyword">, </span><span class="default">$partno</span><span class="keyword">.</span><span class="string">"."</span><span class="keyword">.(</span><span class="default">$count2</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="default">$part_array</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// Attached email does not have a seperate mime attachment for text<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="default">$partno</span><span class="keyword">.</span><span class="string">'.'</span><span class="keyword">.(</span><span class="default">$count</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$obj</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// Not sure if this is possible<br />
//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $part_array[] = array('part_number' =&gt; $prefix.'.1', 'part_object' =&gt; $obj);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="default">$partno</span><span class="keyword">.</span><span class="string">'.1'</span><span class="keyword">, </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$obj</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// If there are more sub-parts, expand them out.<br />
//&nbsp; &nbsp; &nbsp; &nbsp; if (sizeof($obj-&gt;parts) &gt; 0) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">array_key_exists</span><span class="keyword">(</span><span class="string">'parts'</span><span class="keyword">,</span><span class="default">$obj</span><span class="keyword">)){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count </span><span class="keyword">=&gt; </span><span class="default">$p</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$p</span><span class="keyword">, </span><span class="default">$partno</span><span class="keyword">.</span><span class="string">"."</span><span class="keyword">.(</span><span class="default">$count</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="default">$part_array</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93855""></a>
  <div class="note">
   <strong class="user">atamido at gmail dot remove dot com</strong>
   <a href="#93855" class="date">03-Oct-2009 08:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The previous post contains a copy/paste error and a little added complexity.&nbsp; The first function should look like this:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">create_part_array</span><span class="keyword">(</span><span class="default">$struct</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$struct</span><span class="keyword">-&gt;</span><span class="default">parts</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {&nbsp; &nbsp; </span><span class="comment">// There some sub parts<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach (</span><span class="default">$struct</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count </span><span class="keyword">=&gt; </span><span class="default">$part</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$part</span><span class="keyword">, (</span><span class="default">$count</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="default">$part_array</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// Email does not have a seperate mime attachment for text<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="string">'1'</span><span class="keyword">, </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$struct</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; return </span><span class="default">$part_array</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="89002""></a>
  <div class="note">
   <strong class="user">atamido at gmail dot remove dot com</strong>
   <a href="#89002" class="date">18-Feb-2009 07:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
imap-fetchbody() will decode attached email messages inline with the rest of the email parts, however the way it works when handling attached email messages is inconsistent with the main email message.<br />
<br />
With an email message that only has a text body and does not have any mime attachments, imap-fetchbody() will return the following for each requested part number:<br />
<br />
(empty) - Entire message<br />
0 - Message header<br />
1 - Body text<br />
<br />
With an email message that is a multi-part message in MIME format, and contains the message text in plain text and HTML, and has a file.ext attachment, imap-fetchbody() will return something like the following for each requested part number:<br />
<br />
(empty) - Entire message<br />
0 - Message header<br />
1 - MULTIPART/ALTERNATIVE<br />
1.1 - TEXT/PLAIN<br />
1.2 - TEXT/HTML<br />
2 - file.ext<br />
<br />
Now if you attach the above email to an email with the message text in plain text and HTML, imap_fetchbody() will use this type of part number system:<br />
<br />
(empty) - Entire message<br />
0 - Message header<br />
1 - MULTIPART/ALTERNATIVE<br />
1.1 - TEXT/PLAIN<br />
1.2 - TEXT/HTML<br />
2 - MESSAGE/RFC822 (entire attached message)<br />
2.0 - Attached message header<br />
2.1 - TEXT/PLAIN<br />
2.2 - TEXT/HTML<br />
2.3 - file.ext<br />
<br />
Note that the file.ext is on the same level now as the plain text and HTML, and that there is no way to access the MULTIPART/ALTERNATIVE in the attached message.<br />
<br />
Here is a modified version of some of the code from previous posts that will build an easily accessible array that includes accessible attached message parts and the message body if there aren't multipart mimes.&nbsp; The $structure variable is the output of the imap_fetchstructure() function.&nbsp; The returned $part_array has the field 'part_number' which contains the part number to be fed directly into the imap_fetchbody() function.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">create_part_array</span><span class="keyword">(</span><span class="default">$structure</span><span class="keyword">, </span><span class="default">$prefix</span><span class="keyword">=</span><span class="string">""</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//print_r($structure);<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">parts</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {&nbsp; &nbsp; </span><span class="comment">// There some sub parts<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach (</span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count </span><span class="keyword">=&gt; </span><span class="default">$part</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$part</span><span class="keyword">, </span><span class="default">$prefix</span><span class="keyword">.(</span><span class="default">$count</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="default">$part_array</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// Email does not have a seperate mime attachment for text<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="default">$prefix</span><span class="keyword">.</span><span class="string">'1'</span><span class="keyword">, </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$obj</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; return </span><span class="default">$part_array</span><span class="keyword">;<br />
}<br />
</span><span class="comment">// Sub function for create_part_array(). Only called by create_part_array() and itself. <br />
</span><span class="keyword">function </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$obj</span><span class="keyword">, </span><span class="default">$partno</span><span class="keyword">, &amp; </span><span class="default">$part_array</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="default">$partno</span><span class="keyword">, </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$obj</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">type </span><span class="keyword">== </span><span class="default">2</span><span class="keyword">) { </span><span class="comment">// Check to see if the part is an attached email message, as in the RFC-822 type<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //print_r($obj);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">parts</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {&nbsp; &nbsp; </span><span class="comment">// Check to see if the email has parts<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach (</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count </span><span class="keyword">=&gt; </span><span class="default">$part</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Iterate here again to compensate for the broken way that imap_fetchbody() handles attachments<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$part</span><span class="keyword">-&gt;</span><span class="default">parts</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$part</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count2 </span><span class="keyword">=&gt; </span><span class="default">$part2</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$part2</span><span class="keyword">, </span><span class="default">$partno</span><span class="keyword">.</span><span class="string">"."</span><span class="keyword">.(</span><span class="default">$count2</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="default">$part_array</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// Attached email does not have a seperate mime attachment for text<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="default">$partno</span><span class="keyword">.</span><span class="string">'.'</span><span class="keyword">.(</span><span class="default">$count</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$obj</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// Not sure if this is possible<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$part_array</span><span class="keyword">[] = array(</span><span class="string">'part_number' </span><span class="keyword">=&gt; </span><span class="default">$prefix</span><span class="keyword">.</span><span class="string">'.1'</span><span class="keyword">, </span><span class="string">'part_object' </span><span class="keyword">=&gt; </span><span class="default">$obj</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }else{&nbsp; &nbsp; </span><span class="comment">// If there are more sub-parts, expand them out.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">parts</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">parts </span><span class="keyword">as </span><span class="default">$count </span><span class="keyword">=&gt; </span><span class="default">$p</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">add_part_to_array</span><span class="keyword">(</span><span class="default">$p</span><span class="keyword">, </span><span class="default">$partno</span><span class="keyword">.</span><span class="string">"."</span><span class="keyword">.(</span><span class="default">$count</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">), </span><span class="default">$part_array</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="88662""></a>
  <div class="note">
   <strong class="user">atamido at gmail dot remove dot com</strong>
   <a href="#88662" class="date">02-Feb-2009 08:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you download an attachment labeled "winmail.dat" or "win.dat", or with the mime-type of "APPLICATION/MS-TNEF", this is a Microsoft Transport Neutral Encapsulation Format file.&nbsp; It is a proprietary method for encoding several files together in a single file.&nbsp; AFAIK only Outlook sends it with its default setting of sending emails in Rich Text Format.<br />
<br />
As of PHP 5.2 there is no internal method of breaking apart these attachments.<br />
<br />
There are external command line utilities that can be called from PHP.&nbsp; Alternately, it is possible to decode these files entirely in PHP.&nbsp; It appears that all current libraries are based on a plugin written by Graham Norbury for Squirrel Mail.&nbsp; The only ones I've seen are in IlohaMail, Telean, Horde-Imp, and NaSMail.&nbsp; The only one that I know that will also decode the RTF message is from NaSMail.<br />
<br />
To use the NaSMail code, download the "TNEF Attachment Decoder" plugin and extract it to <br />
plugins/attachment_tnef/<br />
<br />
Then use this bit of code:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">include_once(</span><span class="string">'plugins/attachment_tnef/constants.php'</span><span class="keyword">);<br />
include_once(</span><span class="string">'plugins/attachment_tnef/functions.php'</span><span class="keyword">);<br />
include_once(</span><span class="string">'plugins/attachment_tnef/class/tnef.php'</span><span class="keyword">);<br />
<br />
</span><span class="comment">// $tnef is a binary variable containing only the contents of winmail.dat<br />
</span><span class="default">$attachment </span><span class="keyword">= &amp;new </span><span class="default">TnefAttachment</span><span class="keyword">(</span><span class="default">$tnef_debug</span><span class="keyword">);<br />
</span><span class="default">$result </span><span class="keyword">= </span><span class="default">$attachment</span><span class="keyword">-&gt;</span><span class="default">decodeTnef</span><span class="keyword">(</span><span class="default">$tnef</span><span class="keyword">);<br />
</span><span class="default">$tnef_files </span><span class="keyword">= &amp;</span><span class="default">$attachment</span><span class="keyword">-&gt;</span><span class="default">getFilesNested</span><span class="keyword">();<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$tnef_files</span><span class="keyword">); </span><span class="comment">// See the format of the returned array<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82766""></a>
  <div class="note">
   <strong class="user">fortega  dot  no spam plz  at  uamericas dot net</strong>
   <a href="#82766" class="date">24-Apr-2008 10:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To fetch the body of a "sub part" do the following thing:<br />
<span class="default">&lt;?php<br />
$partno </span><span class="keyword">= </span><span class="string">"2.1"&nbsp;&nbsp; </span><span class="comment">// The first part of the second part<br />
<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">imap_fetchbody</span><span class="keyword">(</span><span class="default">$mbox</span><span class="keyword">, </span><span class="default">$msgno</span><span class="keyword">, </span><span class="default">$partno</span><span class="keyword">));<br />
</span><span class="comment">// TODO: replace print_r for the proper function<br />
</span><span class="default">?&gt;<br />
</span><br />
And remember... you can fetch the structure with<br />
<span class="default">&lt;?php<br />
imap_fetchstructure</span><span class="keyword">(</span><span class="default">$mbox</span><span class="keyword">, </span><span class="default">$msgno</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>then iterate the array of parts fetching the body.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81983""></a>
  <div class="note">
   <strong class="user">anonymous lazy person</strong>
   <a href="#81983" class="date">22-Mar-2008 05:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Expanding on a comment below about using munpack to extract attachments, here's a lazy person's function that extracts attachments from mail with $msg_number from $mailbox and writes them to $dir. It returns an array of filenames or false if there are no attachments. <br />
<br />
function writeAttachmentsToDisk($mailbox, $msg_number, $dir){<br />
&nbsp; <br />
&nbsp; if (!file_exists($dir)){<br />
&nbsp;&nbsp;&nbsp; mkdir($dir);<br />
&nbsp; }<br />
&nbsp; $filename = "tmp.eml";<br />
&nbsp; $email_file = $dir."/".$filename;<br />
&nbsp; // write the message body to disk<br />
&nbsp; imap_savebody&nbsp; ($mailbox, $email_file, $msg_number);<br />
&nbsp; $command = "munpack -C $dir -fq $email_file";<br />
&nbsp; // invoke munpack which will <br />
&nbsp; // write all the attachments to $dir<br />
&nbsp; exec($command,$output);<br />
<br />
&nbsp; // if($output[0]!='Did not find anything to unpack from $filename') {<br />
&nbsp; $found_file = false;<br />
&nbsp; foreach ($output as $attach) {<br />
&nbsp;&nbsp;&nbsp; $pieces = explode(" ", $attach);<br />
&nbsp;&nbsp;&nbsp; $part = $pieces[0];<br />
&nbsp;&nbsp;&nbsp; if (file_exists($dir.$part)){<br />
&nbsp;&nbsp; &nbsp;&nbsp; $found_file = true;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $files[] = $part;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
&nbsp; if (!$found_file){<br />
&nbsp;&nbsp;&nbsp; //echo ("\nMail.php : no files found - cleaning up. ");<br />
&nbsp;&nbsp;&nbsp; // didn't find any output files - delete the directory and email file<br />
&nbsp;&nbsp;&nbsp; unlink($email_file);<br />
&nbsp;&nbsp;&nbsp; rmdir($dir);<br />
&nbsp;&nbsp;&nbsp; return false;<br />
&nbsp; }<br />
&nbsp; else {<br />
&nbsp;&nbsp;&nbsp; // found some files-&nbsp; just delete the email file<br />
&nbsp;&nbsp;&nbsp; unlink($email_file);<br />
&nbsp;&nbsp;&nbsp; return $files;<br />
&nbsp; }<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81776""></a>
  <div class="note">
   <strong class="user">tom at tomwardrop dot com</strong>
   <a href="#81776" class="date">13-Mar-2008 08:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If text has been encoded as quoted-printable (most body text is encoded as this), it must be decoded for it to be displayed correctly (without '=', '=20' and other strange text chunks all through the string).<br />
<br />
To decode, you can use the following built-in php function...<br />
<br />
quoted_printable_decode($string)<br />
<br />
Hopefully I've just saved a few people from having to do a preg_replace on there email bodies.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80358""></a>
  <div class="note">
   <strong class="user">bryn</strong>
   <a href="#80358" class="date">11-Jan-2008 08:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
An alternative to munpack for rfc822 messages is ripmime <a href="http://www.pldaniels.com/ripmime/" rel="nofollow" target="_blank">http://www.pldaniels.com/ripmime/</a><br />
<br />
It lets you pass it the rfc822 attachment (usually something.eml) and it recursively writes out attachments (and text and html files)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77180""></a>
  <div class="note">
   <strong class="user">ted at qtis dot co dot nz</strong>
   <a href="#77180" class="date">18-Aug-2007 10:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's simple way of extending Makusnospam's little routine to flatten the entire message into an array which can be useful to quickly find the body and attachments just by walking through the array elements.<br />
<br />
function create_part_array($structure, $prefix="") {<br />
&nbsp;&nbsp; $part_array = array();<br />
<br />
&nbsp;&nbsp;&nbsp; if (sizeof($structure-&gt;parts) &gt; 0) { <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach ($structure-&gt;parts as $count =&gt; $part) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; add_part_to_array($part, $prefix.($count+1), $part_array);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp; return $part_array;<br />
}<br />
<br />
function add_part_to_array($obj, $partno, &amp; $part_array) {<br />
<br />
&nbsp;&nbsp;&nbsp; if ($obj-&gt;type == TYPEMESSAGE) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; parse_message($obj-&gt;parts[0], $partno.".");<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (sizeof($obj-&gt;parts) &gt; 0) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach ($obj-&gt;parts as $count =&gt; $p) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; add_part_to_array($p, $partno.".".($count+1), $part_array);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; $part_array[] = array('part_number' =&gt; $partno, 'part_object' =&gt; $obj);<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74612""></a>
  <div class="note">
   <strong class="user">phpnetlover at yoz dot us</strong>
   <a href="#74612" class="date">20-Apr-2007 07:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi everyone<br />
<br />
I have been inspecting the RFC's and the answer to what to display is not like Musawir Ali in 2 areas<br />
<br />
1- You can not rely on disposition being present, not all mail software composes mail to standard, and if you would just take a quick look at the RFC's you will find out that someone can send you email where your solution will fail even though the mail is "within standards"<br />
<br />
2- When you are presented with Alternative-multipart, assuming you will find one text-plain and one text-html, you should NOT be looking for HTML then TEXT, the last mentioned subtype is the most loyal to the original composition, you check if you can support the last, if not you simply go one step back and see the one before it, if your client supports it, you take that, and so on, this is how Alternative works, Just because HTML is best colored does not mean we should chose that, we are looking for the closest representation of the original and not for any in specific</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73426""></a>
  <div class="note">
   <strong class="user">anonymous at coward dot village</strong>
   <a href="#73426" class="date">22-Feb-2007 08:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A very easy way to handle attachments is just using munpack, with a subdirectory called attachments chmod it to 777 and then use the following bit of code (with mpack installed) on the MIME encoded body:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">//email MIME body in $input<br />
</span><span class="default">file_put_contents</span><span class="keyword">(</span><span class="string">"attachments/body.eml"</span><span class="keyword">,</span><span class="default">$input</span><span class="keyword">);<br />
</span><span class="default">$command </span><span class="keyword">= </span><span class="string">"munpack -C attachments -fq body.eml"</span><span class="keyword">;<br />
</span><span class="default">exec</span><span class="keyword">(</span><span class="default">$command</span><span class="keyword">,</span><span class="default">$output</span><span class="keyword">);<br />
if(</span><span class="default">$output</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]!=</span><span class="string">'Did not find anything to unpack from body.eml'</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$output </span><span class="keyword">as </span><span class="default">$attach</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pieces </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">" "</span><span class="keyword">, </span><span class="default">$attach</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$part </span><span class="keyword">= </span><span class="default">$pieces</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"&lt;a href=\"attachments/</span><span class="default">$part</span><span class="string">\"&gt;</span><span class="default">$part</span><span class="string">&lt;/a&gt;&lt;br&gt;"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72951""></a>
  <div class="note">
   <strong class="user">web at i-ps dot net</strong>
   <a href="#72951" class="date">05-Feb-2007 07:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had an issue with the content that was returned by imap_fetchbody - either the function itself, or the mail-server, was inserting "=\r\n" at points into the text body returned. This may depend upon the content type (i.e. plain text / csv, as opposed to something like a Word document), but you may need to do something like:<br />
<br />
$body = preg_replace("/=(\r?)\n/", '', imap_fetchbody($mailbox, $message, $part));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71775""></a>
  <div class="note">
   <strong class="user">jbr at ya-right dot com</strong>
   <a href="#71775" class="date">15-Dec-2006 05:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Musawir Ali comment is not totally correct, ifdisposition= 1 will never tell you 100% if there is an attachment. You must look at (ifdparameters, ifparameters) if (1) of them is greater then (0), then you need to look inside (parameters), looking at each ($obj-&gt;parameters) and check the (attribute) for (NAME, FILENAME), also be sure to set them to upper or lower case before doing your testing. That's the only way to know if you have an attachment. inline attachments will have $obj-&gt;ifid equal to 1, the $obj-&gt;id will contain the (cid). If $obj-&gt;ifid equals 0 then it's also an attachment (file type) if you have (NAME, FILENAME) as the current parameters (attribute).<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $name </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if ( </span><span class="default">$parent</span><span class="keyword">-&gt;</span><span class="default">ifdparameters </span><span class="keyword">&amp;&amp; </span><span class="default">sizeof </span><span class="keyword">( </span><span class="default">$parent</span><span class="keyword">-&gt;</span><span class="default">dparameters </span><span class="keyword">) &gt; </span><span class="default">0 </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach ( </span><span class="default">$parent</span><span class="keyword">-&gt;</span><span class="default">dparameters </span><span class="keyword">as </span><span class="default">$child </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ( </span><span class="default">strtolower </span><span class="keyword">( </span><span class="default">$child</span><span class="keyword">-&gt;</span><span class="default">attribute </span><span class="keyword">) == </span><span class="string">'name' </span><span class="keyword">|| </span><span class="default">strtolower </span><span class="keyword">( </span><span class="default">$child</span><span class="keyword">-&gt;</span><span class="default">attribute </span><span class="keyword">) == </span><span class="string">'filename' </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$name </span><span class="keyword">= </span><span class="default">strtolower </span><span class="keyword">( </span><span class="default">$child</span><span class="keyword">-&gt;</span><span class="default">value </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if ( empty ( </span><span class="default">$name </span><span class="keyword">) )<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ( </span><span class="default">$parent</span><span class="keyword">-&gt;</span><span class="default">ifparameters </span><span class="keyword">&amp;&amp; </span><span class="default">sizeof </span><span class="keyword">( </span><span class="default">$parent</span><span class="keyword">-&gt;</span><span class="default">parameters </span><span class="keyword">) &gt; </span><span class="default">0 </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach ( </span><span class="default">$parent</span><span class="keyword">-&gt;</span><span class="default">parameters </span><span class="keyword">as </span><span class="default">$child </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ( </span><span class="default">strtolower </span><span class="keyword">( </span><span class="default">$child</span><span class="keyword">-&gt;</span><span class="default">attribute </span><span class="keyword">) == </span><span class="string">'name' </span><span class="keyword">|| </span><span class="default">strtolower </span><span class="keyword">( </span><span class="default">$child</span><span class="keyword">-&gt;</span><span class="default">attribute </span><span class="keyword">) == </span><span class="string">'filename' </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$name </span><span class="keyword">= </span><span class="default">strtolower </span><span class="keyword">( </span><span class="default">$child</span><span class="keyword">-&gt;</span><span class="default">value </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
$parent is derived from imap_fetchstructure(), as a child object if $obj-&gt;parts is set or as the $parent if $obj-&gt;parts is not set!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68097""></a>
  <div class="note">
   <strong class="user">Musawir Ali</strong>
   <a href="#68097" class="date">13-Jul-2006 07:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For those of you trying to create a "flexible" email reader, I suggest doing the following.<br />
<br />
Firstly, instead of going through each part of the email and decoding it, I suggest you go in a specific order. <br />
<br />
1) First go through all the parts and search for the part that has subtype=='HTML'. If found, use that as your message body, else go to Step 2.<br />
2) If HTML component not found, search all parts for subtype=='PLAIN'. If found, use that as your message body else print out an error message (this should never occur).<br />
3) At this point, you already have the main body of the email that you should display. The next thing to do is to find all the attachments. You do this by going through all parts, searching for the parts with ifdisposition==1 (there can be multiple).<br />
<br />
This is the way I did my email reader program and it works perfectly. I started off by using the methods recommended in a lot of webpages (i.e. going through the parts tree like 1.2.1, 1, 2, etc) but the problem is the message body is never in some fixed part! Sometimes its in 1, somtimes 1.1.2, sometimes 2, and sometimes in some totally unexpected place! So my approach was to "search" for the parts that I'm interested. Hope this helps. I also managed to crack the problem with emails containing embedded images. I will probably write a tutorial on that soon.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50560""></a>
  <div class="note">
   <strong class="user">se at designlinks dot net</strong>
   <a href="#50560" class="date">03-Mar-2005 12:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you insist on using imap_fetchbody() to retrieve a mail body that doesn't contain 'parts' [normally you'd use imap_body() ], then note that the header text is in part '0' and the body text in part '1'.<br />
So, imap_fetchbody($mbox,$msg,'0') will return the header and imap_fetchbody($mbox,$msg,'1') will return the body text.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46253""></a>
  <div class="note">
   <strong class="user">guru at php dot net</strong>
   <a href="#46253" class="date">04-Oct-2004 05:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
After many battles with the imap extension I took it upon myself to write my own implementation using sockets. Below is what I came up with, and hopefully it will be usefull to others as well. I know that there are some parts of this that can be tweaked, however I will leave that for you to do. Use/abuse/mutilate this as you wish (no license).<br />
<br />
(Note: I am not placing the source here since it is well over 1900 lines ~48KB)<br />
<br />
<a href="http://www.nutextonline.com/cimap.phps" rel="nofollow" target="_blank">http://www.nutextonline.com/cimap.phps</a><br />
<br />
If enough people find this usefull I will continue to improve it and eventually commit it (or have it committed) to pear.<br />
<br />
Also worth noting is the fact that you can use the imap extensions on mbox format mailboxes. A combination of this class with the imap extension would certainly make a great combination of done correctly.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46041""></a>
  <div class="note">
   <strong class="user">Adam</strong>
   <a href="#46041" class="date">28-Sep-2004 08:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It took me a while to figure out how part id's(numbers) are assigned to different parts of a message.&nbsp; After getting a few AOL e-mails that had a semi-complex structure I was finally able to break it down. <br />
<br />
0 multipart/mixed<br />
&nbsp;&nbsp;&nbsp; 1 multipart/alternative<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 1.1 text/plain<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 1.2 text/html<br />
&nbsp;&nbsp;&nbsp; 2 message/rfc822<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 2 multipart/mixed<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2.1 multipart/alternative<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2.1.1 text/plain<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2.1.2 text/html<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2.2 message/rfc822<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2.2 multipart/alternative<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2.2.1 text/plain<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2.2.2 text/html<br />
<br />
Hopefully this will help others get the different body parts of a message.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45408""></a>
  <div class="note">
   <strong class="user">sales at nocwizard dot com</strong>
   <a href="#45408" class="date">06-Sep-2004 02:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I'm adding this for those of you like me who are scouring the web looking for code to break down a message.&nbsp; These two functions will break down a multi-part and non multi-part message and return the contents of the message in the array $message.&nbsp; It doesn't do attachments.&nbsp; This assumes you've already opened the mailbox and pass it VIA the $mbox.<br />
<br />
function retrieve_message($mbox, $messageid)<br />
{<br />
&nbsp;&nbsp; $message = array();<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp; $header = imap_header($mbox, $messageid);<br />
&nbsp;&nbsp; $structure = imap_fetchstructure($mbox, $messageid);<br />
<br />
&nbsp;&nbsp; $message['subject'] = $header-&gt;subject;<br />
&nbsp;&nbsp; $message['fromaddress'] =&nbsp;&nbsp; $header-&gt;fromaddress;<br />
&nbsp;&nbsp; $message['toaddress'] =&nbsp;&nbsp; $header-&gt;toaddress;<br />
&nbsp;&nbsp; $message['ccaddress'] =&nbsp;&nbsp; $header-&gt;ccaddress;<br />
&nbsp;&nbsp; $message['date'] =&nbsp;&nbsp; $header-&gt;date;<br />
<br />
&nbsp; if (check_type($structure))<br />
&nbsp; {<br />
&nbsp;&nbsp; $message['body'] = imap_fetchbody($mbox,$messageid,"1"); ## GET THE BODY OF MULTI-PART MESSAGE<br />
&nbsp;&nbsp; if(!$message['body']) {$message['body'] = '[NO TEXT ENTERED INTO THE MESSAGE]\n\n';}<br />
&nbsp; }<br />
&nbsp; else<br />
&nbsp; {<br />
&nbsp;&nbsp; $message['body'] = imap_body($mbox, $messageid);<br />
&nbsp;&nbsp; if(!$message['body']) {$message['body'] = '[NO TEXT ENTERED INTO THE MESSAGE]\n\n';}<br />
&nbsp; }<br />
&nbsp;&nbsp; <br />
&nbsp; return $message;<br />
}<br />
<br />
function check_type($structure) ## CHECK THE TYPE<br />
{<br />
&nbsp; if($structure-&gt;type == 1) <br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; return(true); ## YES THIS IS A MULTI-PART MESSAGE<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;else<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; return(false); ## NO THIS IS NOT A MULTI-PART MESSAGE<br />
&nbsp;&nbsp;&nbsp; }<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43405""></a>
  <div class="note">
   <strong class="user">noose (at) nospam (dot) tweak (dot) pl</strong>
   <a href="#43405" class="date">20-Jun-2004 01:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Sorry for my english....
<br />

<br />
for read the attachment's:
<br />

<br />
&lt;?
<br />
&nbsp;foreach ($_GET as $k =&gt; $v)
<br />
&nbsp;{
<br />
&nbsp;&nbsp; &nbsp; $$k = $v;
<br />
&nbsp;}
<br />
&nbsp;$login = 'mylogin';
<br />
&nbsp;$password = 'mypassword';
<br />
&nbsp;$host = '{myhost:110/pop3}';
<br />

<br />
$mbox = imap_open("$host", "$login", "$password");
<br />
$struckture = imap_fetchstructure($mbox, $id);
<br />
$message = imap_fetchbody($mbox,$id,$part);&nbsp; &nbsp; 
<br />
$name = $struckture-&gt;parts[$part]-&gt;dparameters[0]-&gt;value;
<br />
$type = $struckture-&gt;parts[$part]-&gt;typee;
<br />
############## type
<br />
if ($type == 0)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "text/";
<br />
}
<br />
elseif ($type == 1)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "multipart/";
<br />
}
<br />
elseif ($type == 2)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "message/";
<br />
}
<br />
elseif ($type == 3)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "application/";
<br />
}
<br />
elseif ($type == 4)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "audio/";
<br />
}
<br />
elseif ($type == 5)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "image/";
<br />
}
<br />
elseif ($type == 6)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "video";
<br />
}
<br />
elseif($type == 7)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $type = "other/";
<br />
}
<br />
$type .= $struckture-&gt;parts[$part]-&gt;subtypee;
<br />
######## Type end
<br />

<br />
header("Content-typee: ".$type);
<br />
header("Content-Disposition: attachment; filename=".$name);
<br />

<br />
######## coding
<br />
$coding = $struckture-&gt;parts[$part]-&gt;encoding;
<br />
if ($coding == 0)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $message = imap_7bit($message);
<br />
}
<br />
elseif ($coding == 1)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $wiadomsoc = imap_8bit($message);
<br />
}
<br />
elseif ($coding == 2)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $message = imap_binary($message);
<br />
}
<br />
elseif ($coding == 3)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $message = imap_base64($message);
<br />
}
<br />
elseif ($coding == 4)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $message = quoted_printable($message);
<br />
}
<br />
elseif ($coding == 5)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; $message = $message;
<br />
}
<br />
echo $message;
<br />
########## coding end
<br />
&nbsp;imap_close($mbox);
<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42633""></a>
  <div class="note">
   <strong class="user">jsimlo yahoo com</strong>
   <a href="#42633" class="date">24-May-2004 10:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
this may be the way, how to obtain all those part_numbers.... even when a message contains another message attached, and it contains another message attached...<br />
<br />
&lt;?<br />
&nbsp;$parttypes = array ("text", "multipart", "message", "application", "audio", "image", "video", "other");<br />
&nbsp;function buildparts ($struct, $pno = "") {<br />
&nbsp;&nbsp; global $parttypes;<br />
&nbsp;&nbsp; switch ($struct-&gt;type):<br />
&nbsp;&nbsp; &nbsp; case 1:<br />
&nbsp;&nbsp; &nbsp; &nbsp; $r = array (); $i = 1;<br />
&nbsp;&nbsp; &nbsp; &nbsp; foreach ($struct-&gt;parts as $part)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $r[] = buildparts ($part, $pno.".".$i++);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; return implode (", ", $r);<br />
&nbsp;&nbsp; &nbsp; case 2: <br />
&nbsp;&nbsp; &nbsp; &nbsp; return "{".buildparts ($struct-&gt;parts[0], $pno)."}";<br />
&nbsp;&nbsp; &nbsp; default:<br />
&nbsp;&nbsp; &nbsp; &nbsp; return '&lt;a href="?p='.substr ($pno, 1).'"&gt;'.$parttypes[$struct-&gt;type]."/".strtolower ($struct-&gt;subtype)."&lt;/a&gt;";<br />
&nbsp;&nbsp; endswitch;<br />
&nbsp;}<br />
<br />
&nbsp; $struct = imap_fetchstructure ($pop3mbox, $msguid, FT_UID);<br />
&nbsp; echo buildparts ($struct);<br />
?&gt;<br />
<br />
it will print something like: <br />
<br />
&lt;a href="?p=1"&gt;text/plain&lt;/a&gt;, {&lt;a href="?p=2.1"&gt;text/plain&lt;/a&gt;, &lt;a href="?p=2.2"&gt;text/html&lt;/a&gt;}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42622""></a>
  <div class="note">
   <strong class="user">Sito</strong>
   <a href="#42622" class="date">24-May-2004 01:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Better, a fix on a fix... ;)<br />
<br />
function read_all_parts($uid){<br />
&nbsp;global $mime,$ret_info,$enc;<br />
&nbsp; $mime = array("text","multipart","message","application","audio",<br />
"image","video","other","unknow");<br />
&nbsp; $enc&nbsp; = array("7BIT","8BIT","BINARY","BASE64",<br />
"QUOTED-PRINTABLE","OTHER");<br />
&nbsp;&nbsp; &nbsp; <br />
<br />
&nbsp;$struct = imap_fetchstructure( $this -&gt; Link, $uid );<br />
<br />
&nbsp;$ret_info = array();<br />
<br />
function scan($struct,$subkey){<br />
&nbsp;global $mime,$enc,$ret_info;<br />
&nbsp;<br />
&nbsp;&nbsp; foreach($struct as $key =&gt; $value){ <br />
<br />
&nbsp; <br />
&nbsp;&nbsp;&nbsp; if($subkey!=0){<br />
&nbsp;&nbsp;&nbsp; $pid = $subkey.".".($key+1); }<br />
&nbsp;&nbsp;&nbsp; else { $pid = ($key+1); }<br />
&nbsp; <br />
&nbsp;&nbsp;&nbsp; $ret_info[]['pid'] = $pid;<br />
&nbsp;&nbsp;&nbsp; $ret_info[key($ret_info)]['type'] = $mime["$value-&gt;type"];<br />
&nbsp;&nbsp;&nbsp; $ret_info[key($ret_info)]['encoding'] = $enc["$value-&gt;encoding"]; <br />
<br />
&nbsp;&nbsp;&nbsp; next($ret_info);<br />
&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(($value-&gt;parts)!= null) {scan($value-&gt;parts,$pid); }<br />
&nbsp;&nbsp; } <br />
&nbsp;}<br />
<br />
if(!is_null($struct-&gt;parts))<br />
{<br />
&nbsp;scan($struct-&gt;parts,0);<br />
}<br />
else<br />
{<br />
&nbsp;&nbsp;&nbsp; print_r($struct);<br />
&nbsp;&nbsp;&nbsp; echo("&lt;hr&gt;");<br />
&nbsp;&nbsp;&nbsp; $ret_info[]['pid']=1;<br />
&nbsp;&nbsp;&nbsp; $ret_info[key($ret_info)]['type']=$mime["$struct-&gt;type"];&nbsp; &nbsp; <br />
&nbsp;&nbsp;&nbsp; $ret_info[key($ret_info)]['encoding']=$enc["$struct-&gt;encoding"];&nbsp; &nbsp; <br />
}<br />
<br />
return $ret_info;<br />
<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="41262""></a>
  <div class="note">
   <strong class="user">php at NOSPAM dot sibyla dot cz</strong>
   <a href="#41262" class="date">05-Apr-2004 12:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
// $uid - msg number<br />
<br />
function read_all_parts($uid){<br />
&nbsp;global $mime,$ret_info,$enc;<br />
&nbsp; $mime = array("text","multipart","message","application","audio",<br />
"image","video","other","unknow");<br />
&nbsp; $enc&nbsp; = array("7BIT","8BIT","BINARY","BASE64",<br />
"QUOTED-PRINTABLE","OTHER");<br />
&nbsp;&nbsp; &nbsp;&nbsp; <br />
<br />
&nbsp;$struct = imap_fetchstructure( $this -&gt; Link, $uid );<br />
<br />
&nbsp;$ret_info = array();<br />
<br />
function scan($struct,$subkey){<br />
&nbsp;global $mime,$enc,$ret_info;<br />
&nbsp;<br />
&nbsp;foreach($struct as $key =&gt; $value){ <br />
<br />
&nbsp; <br />
&nbsp; if($subkey!=0){<br />
&nbsp; $pid = $subkey.".".($key+1); }<br />
&nbsp; else { $pid = ($key+1); }<br />
&nbsp; <br />
&nbsp; $ret_info[]['pid'] = $pid;<br />
&nbsp; $ret_info[key($ret_info)]['type'] = $mime["$value-&gt;type"];<br />
&nbsp; $ret_info[key($ret_info)]['encoding'] = $enc["$value-&gt;encoding"]; <br />
<br />
&nbsp; next($ret_info);<br />
&nbsp; <br />
&nbsp; if(($value-&gt;parts)!= null) {scan($value-&gt;parts,$pid); }<br />
&nbsp;}<br />
&nbsp;<br />
&nbsp;}<br />
<br />
scan($struct-&gt;parts,0);<br />
<br />
return $ret_info;<br />
<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35407""></a>
  <div class="note">
   <strong class="user">asfd at aasdfa dot com</strong>
   <a href="#35407" class="date">30-Aug-2003 11:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PLEASE DOCUMENT THIS POST AND SAVE US SOME TIME! :)<br />
ac at artcenter dot ac<br />
17-Feb-2002 04:24 <br />
Lets say your email has this structure:<br />
1 multipart<br />
&nbsp;&nbsp;&nbsp; plain<br />
&nbsp;&nbsp;&nbsp; html<br />
2 x-vcard<br />
and... you can't seem to figure out how to get either plain or HTML part of the multipart message? have you been going through all the trouble looking for a PHP mime parser? well here is a simple solution which SHOULD BE documented in this manual. From example above, if you want to get the plain part of the "multipart" message do this:<br />
$text=imap_fetchbody($mbox,$msg_num,"1.1");<br />
all you do is instead of part number 1, put 1.1 or to get the HTML part put 1.2<br />
<br />
EASY!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31685""></a>
  <div class="note">
   <strong class="user">ulrich at kaldamar dot de</strong>
   <a href="#31685" class="date">30-Apr-2003 01:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The function imap_fetchbody() seems uncapable of getting subordinate parts of a message/rfc822-part. I had problems with getting an attachment that was forwarded in such a part, because the object given by imap_fetchstructure() would assume that the part was represented by the string "2.1.2.1.2". <br />
<br />
So I wrote this set of functions which parses the raw message-body and creates an array with the struture corresponding to the structure given by imap_fetchstructure(). The function mail_fetchpart() (see below) will work on the array and return even those parts that I could not get with imap_fetchbody().<br />
<br />
Example usage of this function: mail_fetchpart($mbox, 2, "2.1.2.1.2");<br />
<br />
Note: If the message does not contain multiple pars, the body of the message can be accessed by the part-string "1".<br />
I have more functions for parsing and decoding messages, just email me.<br />
<br />
&nbsp;&nbsp;&nbsp; // get the body of a part of a message according to the<br />
&nbsp;&nbsp;&nbsp; // string in $part<br />
&nbsp;&nbsp;&nbsp; function mail_fetchpart($mbox, $msgNo, $part) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $parts = mail_fetchparts($mbox, $msgNo);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $partNos = explode(".", $part);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $currentPart = $parts;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; while(list ($key, $val) = each($partNos)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $currentPart = $currentPart[$val];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if ($currentPart != "") return $currentPart;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else return false;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; // splits a message given in the body if it is<br />
&nbsp;&nbsp;&nbsp; // a mulitpart mime message and returns the parts,<br />
&nbsp;&nbsp;&nbsp; // if no parts are found, returns false<br />
&nbsp;&nbsp;&nbsp; function mail_mimesplit($header, $body) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $parts = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $PN_EREG_BOUNDARY = "Content-Type:(.*)boundary=\"([^\"]+)\"";<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (eregi ($PN_EREG_BOUNDARY, $header, $regs)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $boundary = $regs[2];<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $delimiterReg = "([^\r\n]*)$boundary([^\r\n]*)";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (eregi ($delimiterReg, $body, $results)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $delimiter = $results[0];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $parts = explode($delimiter, $body);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $parts = array_slice ($parts, 1, -1);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return $parts;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return false;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }&nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; // returns an array with all parts that are<br />
&nbsp;&nbsp;&nbsp; // subparts of the given part<br />
&nbsp;&nbsp;&nbsp; // if no subparts are found, return the body of <br />
&nbsp;&nbsp;&nbsp; // the current part<br />
&nbsp;&nbsp;&nbsp; function mail_mimesub($part) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $i = 1;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $headDelimiter = "\r\n\r\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $delLength = strlen($headDelimiter);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // get head &amp; body of the current part<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $endOfHead = strpos( $part, $headDelimiter);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $head = substr($part, 0, $endOfHead);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $body = substr($part, $endOfHead + $delLength, strlen($part));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // check whether it is a message according to rfc822<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (stristr($head, "Content-Type: message/rfc822")) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $part = substr($part, $endOfHead + $delLength, strlen($part));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $returnParts[1] = mail_mimesub($part);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return $returnParts;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // if no message, get subparts and call function recursively<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } elseif ($subParts = mail_mimesplit($head, $body)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // got more subparts<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while (list ($key, $val) = each($subParts)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $returnParts[$i] = mail_mimesub($val);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $i++;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return $returnParts;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return $body;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; // get an array with the bodies all parts of an email<br />
&nbsp;&nbsp;&nbsp; // the structure of the array corresponds to the <br />
&nbsp;&nbsp;&nbsp; // structure that is available with imap_fetchstructure<br />
&nbsp;&nbsp;&nbsp; function mail_fetchparts($mbox, $msgNo) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $parts = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $header = imap_fetchheader($mbox,$msgNo);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $body = imap_body($mbox,$msgNo, FT_INTERNAL);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $i = 1;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if ($newParts = mail_mimesplit($header, $body)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while (list ($key, $val) = each($newParts)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $parts[$i] = mail_mimesub($val);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $i++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $parts[$i] = $body;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $parts;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30653""></a>
  <div class="note">
   <strong class="user">bubblocity at yahoo dot com</strong>
   <a href="#30653" class="date">25-Mar-2003 05:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is a well overdue addendum to the code submitted on<br />
14-Jan-2002 02:58.&nbsp; This function was called inside the GetParts function:<br />
<br />
function concat_ws($separator, $str1, $str2){<br />
&nbsp;&nbsp;&nbsp; if(strlen($str1) &amp;&amp; strlen($str2)){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $str1 . $separator . $str2;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else if (strlen($str1)){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $str1;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else if (strlen($str2)){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $str2;<br />
&nbsp;&nbsp;&nbsp; }&nbsp; &nbsp; <br />
&nbsp;&nbsp;&nbsp; else return '';<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="24312""></a>
  <div class="note">
   <strong class="user">markusNOSPAM at broede dot NO_SPAM dot de</strong>
   <a href="#24312" class="date">13-Aug-2002 05:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Maybe you prefer a short and recursive way to parse a message<br />
and get the part numbers built:<br />
-------------------------------------------------------------<br />
<br />
function parse_message($obj, $prefix="") {<br />
/* Here you can process the data of the main "part" of the message, e.g.: */<br />
&nbsp; do_anything_with_message_struct($obj);<br />
<br />
&nbsp; if (sizeof($obj-&gt;parts) &gt; 0)<br />
&nbsp;&nbsp;&nbsp; foreach ($obj-&gt;parts as $count=&gt;$p)<br />
&nbsp;&nbsp; &nbsp;&nbsp; parse_part($p, $prefix.($count+1));<br />
}<br />
<br />
function parse_part($obj, $partno) {<br />
/* Here you can process the part number and the data of the parts of the message, e.g.: */<br />
&nbsp; do_anything_with_part_struct($obj,$partno);<br />
<br />
&nbsp; if ($obj-&gt;type == TYPEMESSAGE)<br />
&nbsp;&nbsp;&nbsp; parse_message($obj-&gt;parts[0], $partno.".");<br />
&nbsp; else<br />
&nbsp;&nbsp;&nbsp; if (sizeof($obj-&gt;parts) &gt; 0)<br />
&nbsp;&nbsp; &nbsp;&nbsp; foreach ($obj-&gt;parts as $count=&gt;$p)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; parse_part($p, $partno.".".($count+1));<br />
}<br />
<br />
/* Let's say, you have an already opened mailbox stream $mbox<br />
&nbsp;&nbsp; and you like to parse through the first message: */<br />
<br />
$msgno = 1;<br />
parse_message(imap_fetchstructure($mbox,$msgno));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19578""></a>
  <div class="note">
   <strong class="user">sarachaga at yahoo dot com</strong>
   <a href="#19578" class="date">04-Mar-2002 08:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For those guys trying to extract a message/rfc822 parts correctly here is a hint:<br />
<br />
As you may note, if you recurse over the structure object returned by imap_fetchstructure, when you reach the message/rfc822 you find that the message itself counts as a part too, so an attachment in that message should be 2.1.2 (the .1. is the whole rfc822 msg), but if you use that part number in imap_fetchbody you get nothing.<br />
<br />
What i did is: my recursing function checks if the part/subtype of a particular part is message/rfc822, and only in that case i do not concatenate the .1 to the part number, because as far as i know, this only happens with this kind of message. And for all the other parts (non rfc822) it concats the dot-partnumber.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19138""></a>
  <div class="note">
   <strong class="user">ac at artcenter dot ac</strong>
   <a href="#19138" class="date">18-Feb-2002 02:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Lets say your email has this structure:<br />
1 multipart<br />
&nbsp;&nbsp;&nbsp; plain<br />
&nbsp;&nbsp;&nbsp; html<br />
2 x-vcard<br />
and... you can't seem to figure out how to get either plain or HTML part of the multipart message? have you been going through all the trouble looking for a PHP mime parser? well here is a simple solution which SHOULD BE documented in this manual. From example above, if you want to get the plain part of the "multipart" message do this:<br />
$text=imap_fetchbody($mbox,$msg_num,"1.1");<br />
all you do is instead of part number 1, put 1.1 or to get the HTML part put 1.2<br />
<br />
EASY!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="18206""></a>
  <div class="note">
   <strong class="user">bubblocity at yahoo dot com</strong>
   <a href="#18206" class="date">14-Jan-2002 10:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are trying to fetch the body part and don't know what to fetch,<br />
here is a function that will return all the body parts as a single string with each part separated by '|' character.<br />
Followed by a fuction which will retrieve the structure of that part.<br />
<br />
You can then parse the return string by explode() and call imap_fetchbody() on each of the parts.<br />
<br />
Chunks of this code was stolen from the following site:<br />
<a href="http://www.bitsense.net/PHPNotes/IMAP/imap_fetchstructure.asp" rel="nofollow" target="_blank">http://www.bitsense.net/PHPNotes/IMAP/imap_fetchstructure.asp</a><br />
<br />
&lt;pre&gt;<br />
#Function Gets all the subparts , but does not get part: ''<br />
function GetParts($this_part, $part_no) {<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //If it is type message(2)=msg envelope,<br />
&nbsp;&nbsp;&nbsp; //Not sure about this assumption : the if statement<br />
&nbsp;&nbsp;&nbsp; //double check with RFC822 on this one.<br />
<br />
&nbsp;&nbsp;&nbsp; if($this_part-&gt;type==2){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //and there is only 1 subpart of the envelope<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //and that subpart is multipart<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //otherwise will generate excessive '.1' and <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //send wrong part_no to imap_fetchbody<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if($this_part-&gt;parts[0]-&gt;type==1){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $this_part=$this_part-&gt;parts[0];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (count($this_part-&gt;parts)&gt;0) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for ($i = 0; $i &lt; count($this_part-&gt;parts); $i++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ($part_no != "") {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $newpartno = $part_no . '.' . ($i +1);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else $newpartno = $i+1;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $partstringary[$i] = <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetParts($this_part-&gt;parts[$i], $newpartno);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }//for<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $partstring = implode('|', $partstringary);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }//if<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $partstring = concat_ws('|', $part_no , $partstring);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //echo $partstring ;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $partstring;<br />
}<br />
<br />
#########################################<br />
#Companion function go to GetParts();<br />
#Given the partno - returns the structure<br />
#########################################<br />
function GetSubPartStructure($mbox, $msgno, $partno){<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $msg_struct = imap_fetchstructure($mbox, $msgno);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $partsary = explode ('.', $partno);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $subpartstruct = $msg_struct;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for ($i=0; $i&lt; count($partsary); $i++){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //Not sure about this, if assumption<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // you should probably double check with RFC822 on this one.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if($subpartstruct-&gt;type==2){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if($subpartstruct-&gt;parts[0]-&gt;type==1){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $subpartstruct=$subpartstruct-&gt;parts[0];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $subpartstruct = $subpartstruct-&gt;parts[$partsary[$i]-1];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $subpartstruct;<br />
}<br />
<br />
function decodemsg($msgstring, $encoding){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //Write your own function to decode,<br />
&nbsp;&nbsp;&nbsp; //or lots of examples within PHP already.<br />
&nbsp;&nbsp;&nbsp; return $decodemsg;<br />
}<br />
<br />
#Usage:<br />
$msg_struct = imap_fetchstructure($mbox, $msgno);<br />
$msgparts= GetParts($msg_struct, $part_no);<br />
$partsary = explode($msgparts, '|');<br />
for($i=0; $i&lt;count($parsary);$i++){<br />
&nbsp;&nbsp;&nbsp; $substruct = GetSubPartStructure($mbox, $msgno, $partsary[$i]);<br />
&nbsp;&nbsp;&nbsp; if($substruct-&gt;type==''){&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //then this is type TEXT<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $msg = imap_fetchbody($mbox, $msgno, $msgpartsary[$i]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //Do the decoding<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $msg = decodemsg($msg, $struct-&gt;encoding);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo $msg; //or do whatever you want with it.<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else{ //Not TEXT<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //Do whatever you want<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //i.e. write the attachment...etc<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
&lt;/pre&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="13919""></a>
  <div class="note">
   <strong class="user">pmzandbergen at yahoo dot com</strong>
   <a href="#13919" class="date">10-Jul-2001 04:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Nice function above. However, there are some webmail (normaly plain text) services like you which don't use structure type 'ATTACHMENT' with the attachments, but 'INLINE' (also plain text is called like this). Just replace
<br />
if (strtoupper ($structure-&gt;disposition) == "ATTACHMENT"){
<br />
with
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (strtoupper ($structure-&gt;disposition) == "ATTACHMENT" || strtoupper ($structure-&gt;disposition) == "INLINE" &amp;&amp; strtoupper ($structure-&gt;subtype) != "PLAIN") {
<br />

<br />
But remember, when uou send a message with plaintext &amp; attachment, also the plaintext is an attachment</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="10124""></a>
  <div class="note">
   <strong class="user">rfinnie at kefta dot com</strong>
   <a href="#10124" class="date">14-Dec-2000 11:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
With regard to message/rfc822 parts, it appears that the IMAP c-client that PHP uses does not follow the IMAP RFC (#2060) correctly.&nbsp; The RFC specifies that to grab the headers for a message/rfc822 part, you would request part "2.HEADER" (assuming 2 is your part number), and the full text of the part would be "2.TEXT".&nbsp; Instead, "2.0" will grab the headers, and just "2" will get the text.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="4880""></a>
  <div class="note">
   <strong class="user">cleong at organic dot com</strong>
   <a href="#4880" class="date">05-Apr-2000 06:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a routine that yields the part of a message with a particular MIME type:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">get_mime_type</span><span class="keyword">(&amp;</span><span class="default">$structure</span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$primary_mime_type </span><span class="keyword">= array(</span><span class="string">"TEXT"</span><span class="keyword">, </span><span class="string">"MULTIPART"</span><span class="keyword">, </span><span class="string">"MESSAGE"</span><span class="keyword">, </span><span class="string">"APPLICATION"</span><span class="keyword">, </span><span class="string">"AUDIO"</span><span class="keyword">, </span><span class="string">"IMAGE"</span><span class="keyword">, </span><span class="string">"VIDEO"</span><span class="keyword">, </span><span class="string">"OTHER"</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">subtype</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">$primary_mime_type</span><span class="keyword">[(int) </span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">type</span><span class="keyword">] . </span><span class="string">'/' </span><span class="keyword">. </span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">subtype</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; }
<br />
&nbsp;&nbsp; &nbsp; return </span><span class="string">"TEXT/PLAIN"</span><span class="keyword">;
<br />
}
<br />

<br />
function </span><span class="default">get_part</span><span class="keyword">(</span><span class="default">$stream</span><span class="keyword">, </span><span class="default">$msg_number</span><span class="keyword">, </span><span class="default">$mime_type</span><span class="keyword">, </span><span class="default">$structure </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">, </span><span class="default">$part_number </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; if (!</span><span class="default">$structure</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$structure </span><span class="keyword">= </span><span class="default">imap_fetchstructure</span><span class="keyword">(</span><span class="default">$stream</span><span class="keyword">, </span><span class="default">$msg_number</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; }
<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$structure</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if(</span><span class="default">$mime_type </span><span class="keyword">== </span><span class="default">get_mime_type</span><span class="keyword">(</span><span class="default">$structure</span><span class="keyword">)) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(!</span><span class="default">$part_number</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$part_number </span><span class="keyword">= </span><span class="string">"1"</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$text </span><span class="keyword">= </span><span class="default">imap_fetchbody</span><span class="keyword">(</span><span class="default">$stream</span><span class="keyword">, </span><span class="default">$msg_number</span><span class="keyword">, </span><span class="default">$part_number</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">encoding </span><span class="keyword">== </span><span class="default">3</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">imap_base64</span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (</span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">encoding </span><span class="keyword">== </span><span class="default">4</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">imap_qprint</span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">$text</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if (</span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">type </span><span class="keyword">== </span><span class="default">1</span><span class="keyword">) { </span><span class="comment">/* multipart */
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">while (list(</span><span class="default">$index</span><span class="keyword">, </span><span class="default">$sub_structure</span><span class="keyword">) = </span><span class="default">each</span><span class="keyword">(</span><span class="default">$structure</span><span class="keyword">-&gt;</span><span class="default">parts</span><span class="keyword">)) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$part_number</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$prefix </span><span class="keyword">= </span><span class="default">$part_number </span><span class="keyword">. </span><span class="string">'.'</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$data </span><span class="keyword">= </span><span class="default">get_part</span><span class="keyword">(</span><span class="default">$stream</span><span class="keyword">, </span><span class="default">$msg_number</span><span class="keyword">, </span><span class="default">$mime_type</span><span class="keyword">, </span><span class="default">$sub_structure</span><span class="keyword">, </span><span class="default">$prefix </span><span class="keyword">. (</span><span class="default">$index </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$data</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$data</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;
<br />
}
<br />

<br />
</span><span class="comment">// get plain text
<br />
</span><span class="default">$data </span><span class="keyword">= </span><span class="default">get_part</span><span class="keyword">(</span><span class="default">$stream</span><span class="keyword">, </span><span class="default">$msg_number</span><span class="keyword">, </span><span class="string">"TEXT/PLAIN"</span><span class="keyword">);
<br />
</span><span class="comment">// get HTML text
<br />
</span><span class="default">$data </span><span class="keyword">= </span><span class="default">get_part</span><span class="keyword">(</span><span class="default">$stream</span><span class="keyword">, </span><span class="default">$msg_number</span><span class="keyword">, </span><span class="string">"TEXT/HTML"</span><span class="keyword">);
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Right now only the first part with the matching MIME type is returned. A more useful version would create an array and return all matching parts (for GIFs, for instance).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
