<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>按照 RFC 3986 对 URL 进行编码</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.rawurldecode.html">? rawurldecode</a></li>
      <li style="float: right;"><a href="function.urldecode.html">urldecode ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.url.html">URL 函数</a></li>
    <li>按照 RFC 3986 对 URL 进行编码</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.rawurlencode" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">rawurlencode</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7)</p><p class="refpurpose"><span class="refname">rawurlencode</span> &mdash; <span class="dc-title">按照 RFC 3986 对 URL 进行编码</span></p>

 </div>
 <div class="refsect1 description" id="refsect1-function.rawurlencode-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>rawurlencode</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$str</code></span>
   )</div>

  <p class="para rdfs-comment">
   根据 <a href="http://www.faqs.org/rfcs/rfc3986" class="link external" title="Link : http://www.faqs.org/rfcs/rfc3986">&raquo;&nbsp;RFC 3986</a> 编码指定的字符。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.rawurlencode-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">str</code></dt>

     <dd>

      <p class="para">
       要编码的 URL。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.rawurlencode-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回字符串，此字符串中除了
   <em>-_.</em> 
   之外的所有非字母数字字符都将被替换成百分号（<em>%</em>）后跟两位十六进制数。这是在
   <a href="http://www.faqs.org/rfcs/rfc3986" class="link external" title="Link : http://www.faqs.org/rfcs/rfc3986">&raquo;&nbsp;RFC 3986</a> 中描述的编码，是为了保护原义字符以免其被解释为特殊的 
   URL 定界符，同时保护 URL 
   格式以免其被传输媒体（像一些邮件系统）使用字符转换时弄乱。
   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <p class="para">
     在 PHP 5.3.0 之前，rawurlencode 根据 <a href="http://www.faqs.org/rfcs/rfc1738" class="link external" title="Link : http://www.faqs.org/rfcs/rfc1738">&raquo;&nbsp;RFC 1738</a> 来编码波浪线（<em>~</em>）。
    </p>
   </p></blockquote>
  </p>
 </div>

 
 <div class="refsect1 changelog" id="refsect1-function.rawurlencode-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.3.4</td>
       <td>
        因为 <span class="function"><strong>rawurlencode()</strong></span> 使用了  EBCDIC，所以波浪线字符不会再被编码。
       </td>
      </tr>

      <tr>
       <td>5.3.0</td>
       <td>
        现在符合了<a href="http://www.faqs.org/rfcs/rfc3986" class="link external" title="Link : http://www.faqs.org/rfcs/rfc3986">&raquo;&nbsp;RFC 3986</a>。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.rawurlencode-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-4504">
    <p><strong>Example #1 在 FTP URL 里包含一个密码</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">echo&nbsp;</span><span style="color: #DD0000">'&lt;a&nbsp;href="ftp://user:'</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">rawurlencode</span><span style="color: #007700">(</span><span style="color: #DD0000">'foo&nbsp;@+%/'</span><span style="color: #007700">),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #DD0000">'@ftp.example.com/x.txt"&gt;'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上例程会输出：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
&lt;a href=&quot;ftp://user:foo%20%40%2B%25%2F@ftp.example.com/x.txt&quot;&gt;
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   或者，如果你想通过 URL 的 PATH_INFO 构成部分去传递信息：
  </p>
  <p class="para">
   <div class="example" id="example-4505">
    <p><strong>Example #2 <span class="function"><strong>rawurlencode()</strong></span> 示例 2</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">echo&nbsp;</span><span style="color: #DD0000">'&lt;a&nbsp;href="http://example.com/department_list_script/'</span><span style="color: #007700">,<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000BB">rawurlencode</span><span style="color: #007700">(</span><span style="color: #DD0000">'sales&nbsp;and&nbsp;marketing/Miami'</span><span style="color: #007700">),&nbsp;</span><span style="color: #DD0000">'"&gt;'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上例程会输出：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
&lt;a href=&quot;http://example.com/department_list_script/sales%20and%20marketing%2FMiami&quot;&gt;
</pre></div>
    </div>
   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.rawurlencode-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.rawurldecode.html" class="function" rel="rdfs-seeAlso">rawurldecode()</a> - 对已编码的 URL 字符串进行解码</span></li>
    <li class="member"><span class="function"><a href="function.urldecode.html" class="function" rel="rdfs-seeAlso">urldecode()</a> - 解码已编码的 URL 字符串</span></li>
    <li class="member"><span class="function"><a href="function.urlencode.html" class="function" rel="rdfs-seeAlso">urlencode()</a> - 编码 URL 字符串</span></li>
    <li class="member"><a href="http://www.faqs.org/rfcs/rfc3986" class="link external" title="Link : http://www.faqs.org/rfcs/rfc3986">&raquo;&nbsp;RFC 3986</a></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="116839""></a>
  <div class="note">
   <strong class="user">jz</strong>
   <a href="#116839" class="date">09-Mar-2015 08:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For those looking to strip all non-reserved characters from a URL according to RFC 3986, the code would look like:<br />
<br />
&nbsp;<span class="default">&lt;?php<br />
$stripped </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/[^[:alnum:]-._~]/'</span><span class="keyword">, </span><span class="string">''</span><span class="keyword">, </span><span class="default">$source</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span> <br />
<br />
To get this string as it should be used in a url, you still probably want to use rawurlencode, as the [:alpha:] posix bracket expression will catch accented characters - use [A-Za-z][0-9] instead if you only want to include ascii characters.<br />
<br />
So a basic "slug" generation routine might look like:<br />
<br />
&nbsp;<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">strtoslug</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// strip out all but unreserved characters from rfc:3986<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$stripped </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/[^[:alnum:][:blank:]-._~]/'</span><span class="keyword">, </span><span class="string">''</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// convert compacted whitespace to hyphens<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$slug </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/[:blank:]+/'</span><span class="keyword">, </span><span class="string">'-'</span><span class="keyword">, </span><span class="default">$stripped</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$slug</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107219""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#107219" class="date">23-Jan-2012 12:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you, like me, sometimes have the misfortune of being forced to work with PHP4, here is a PHP implementation of http_build_query() that produces more or less the same output as this function, accepting the same arguments.<br />
<br />
The only differences here are that the RFC selector argument does not behave precisely correctly. This implementation passes RFC1738 through urlencode() and RFC3986 through rawurlencode(), which is not 100% correct, see the manual pages of those function for more information.<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp; </span><span class="keyword">if (!</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'http_build_query'</span><span class="keyword">)) {<br />
<br />
&nbsp;&nbsp;&nbsp; if (!</span><span class="default">defined</span><span class="keyword">(</span><span class="string">'PHP_QUERY_RFC1738'</span><span class="keyword">)) </span><span class="default">define</span><span class="keyword">(</span><span class="string">'PHP_QUERY_RFC1738'</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if (!</span><span class="default">defined</span><span class="keyword">(</span><span class="string">'PHP_QUERY_RFC3986'</span><span class="keyword">)) </span><span class="default">define</span><span class="keyword">(</span><span class="string">'PHP_QUERY_RFC3986'</span><span class="keyword">, </span><span class="default">2</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">http_build_query </span><span class="keyword">(</span><span class="default">$query_data</span><span class="keyword">, </span><span class="default">$numeric_prefix </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$arg_separator </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$enc_type </span><span class="keyword">= </span><span class="default">PHP_QUERY_RFC1738</span><span class="keyword">, </span><span class="default">$base </span><span class="keyword">= </span><span class="default">NULL</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$result </span><span class="keyword">= array();<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$arg_separator </span><span class="keyword">= (</span><span class="default">$arg_separator </span><span class="keyword">!= </span><span class="string">''</span><span class="keyword">) ? (string) </span><span class="default">$arg_separator </span><span class="keyword">: </span><span class="default">ini_get</span><span class="keyword">(</span><span class="string">'arg_separator.output'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$enc_func </span><span class="keyword">= (</span><span class="default">$enc_type </span><span class="keyword">== </span><span class="default">PHP_QUERY_RFC3986</span><span class="keyword">) ? </span><span class="string">'rawurlencode' </span><span class="keyword">: </span><span class="string">'urlencode'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$query_data </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$item</span><span class="keyword">) </span><span class="default">$result</span><span class="keyword">[] = (</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$item</span><span class="keyword">) || </span><span class="default">is_object</span><span class="keyword">(</span><span class="default">$item</span><span class="keyword">)) ? </span><span class="default">http_build_query</span><span class="keyword">(</span><span class="default">$item</span><span class="keyword">, </span><span class="default">NULL</span><span class="keyword">, </span><span class="default">$arg_separator</span><span class="keyword">, </span><span class="default">$enc_type</span><span class="keyword">, (</span><span class="default">$base </span><span class="keyword">!== </span><span class="default">NULL</span><span class="keyword">) ? </span><span class="string">"</span><span class="default">$base</span><span class="string">%5B"</span><span class="keyword">.</span><span class="default">$enc_func</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">).</span><span class="string">'%5D' </span><span class="keyword">: </span><span class="default">$enc_func</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">)) : ((</span><span class="default">$base </span><span class="keyword">!== </span><span class="default">NULL</span><span class="keyword">) ? </span><span class="string">"</span><span class="default">$base</span><span class="string">%5B"</span><span class="keyword">.</span><span class="default">$enc_func</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">).</span><span class="string">'%5D='</span><span class="keyword">.</span><span class="default">$enc_func</span><span class="keyword">(</span><span class="default">$item</span><span class="keyword">) : ((</span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">) &amp;&amp; </span><span class="default">$numeric_prefix </span><span class="keyword">!== </span><span class="default">NULL</span><span class="keyword">) ? (string) </span><span class="default">$numeric_prefix </span><span class="keyword">: </span><span class="string">''</span><span class="keyword">).</span><span class="default">$enc_func</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">).</span><span class="string">'='</span><span class="keyword">.</span><span class="default">$enc_func</span><span class="keyword">(</span><span class="default">$item</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">implode</span><span class="keyword">(</span><span class="default">$arg_separator</span><span class="keyword">, </span><span class="default">$result</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp; }</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100567""></a>
  <div class="note">
   <strong class="user">ToKaM</strong>
   <a href="#100567" class="date">24-Oct-2010 12:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be careful here. rawurlencode changes ? to %C3%83%C2%A4 but firefox changes this internally to %c3%83%c2%a4. This could lead to bugs with rewrite loops. <br />
Cheers.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100313""></a>
  <div class="note">
   <strong class="user">bolvaritamas at vipmail dot hu</strong>
   <a href="#100313" class="date">07-Oct-2010 03:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've written a simple function to convert an UTF-8 string to URL encoded string. All the given characters are converted!<br />
<br />
The function:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">mb_rawurlencode</span><span class="keyword">(</span><span class="default">$url</span><span class="keyword">){<br />
</span><span class="default">$encoded</span><span class="keyword">=</span><span class="string">''</span><span class="keyword">;<br />
</span><span class="default">$length</span><span class="keyword">=</span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$url</span><span class="keyword">);<br />
for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$length</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">++){<br />
</span><span class="default">$encoded</span><span class="keyword">.=</span><span class="string">'%'</span><span class="keyword">.</span><span class="default">wordwrap</span><span class="keyword">(</span><span class="default">bin2hex</span><span class="keyword">(</span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$url</span><span class="keyword">,</span><span class="default">$i</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)),</span><span class="default">2</span><span class="keyword">,</span><span class="string">'%'</span><span class="keyword">,</span><span class="default">true</span><span class="keyword">);<br />
}<br />
return </span><span class="default">$encoded</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Example:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">echo </span><span class="string">'<a href="http://example.com/" rel="nofollow" target="_blank">http://example.com/</a>'</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">mb_rawurlencode</span><span class="keyword">(</span><span class="string">'你好'</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
The above example will output:<br />
<a href="http://example.com/%e4%bd%a0%e5%a5%bd" rel="nofollow" target="_blank">http://example.com/%e4%bd%a0%e5%a5%bd</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="86506""></a>
  <div class="note">
   <strong class="user">hiroaki dot kawai at gmail dot com</strong>
   <a href="#86506" class="date">22-Oct-2008 04:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
phpversion()&gt;=5.3 will compliant with RFC 3986, while phpversion()&lt;=5.2.7RC1 is not compliant with RFC 3986.<br />
<br />
History of related RFCs:<br />
<br />
RFC 1738 section 2.2<br />
&nbsp;only alphanumerics, the special characters "$-_.+!*'(),", and<br />
&nbsp;reserved characters used for their reserved purposes may be used<br />
&nbsp;unencoded within a URL.<br />
<br />
RFC 2396 section 2.3<br />
&nbsp;unreserved&nbsp; = alphanum | mark<br />
&nbsp;mark&nbsp; &nbsp; &nbsp; &nbsp; = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"<br />
<br />
RFC 2732 section 3<br />
&nbsp;(3) Add "[" and "]" to the set of 'reserved' characters:<br />
<br />
RFC 3986 section 2.3<br />
&nbsp;unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"<br />
<br />
RFC 3987 section 2.2<br />
&nbsp;unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85130""></a>
  <div class="note">
   <strong class="user">herenvardo at gmail dot com</strong>
   <a href="#85130" class="date">16-Aug-2008 01:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have to mention something about javier's post: the issue you are experiencing only happens because you are using ISO-8859-1 (a.k.a. ISO-LATIN-1) encoding, which is an extension of ASCII using the values 128-255 for latin specific characters (these characters are NOT part of ASCII). To say somethig like 0xF1 is the correct value for "?" in ASCII is wrong: any value equal or higher than 0x80 is invalid in ASCII; and there is no "correct" value for "?" in ASCII because the ASCII character set does not include that character.<br />
These encode/decode functions are designed to work on UTF-8, which is an ASCII-compatible encoding for Unicode, thus being able to represent the entire Unicode character range.<br />
<br />
The main point is: the "?±" you get is the 0xC3 0xB1 sequence, interpreted as two single-byte ISO-8859-1 characters; but if you interpret them as UTF-8, they indeed represent "?". If you are working with the latin character set and encoding, then you are fine with your method (which is essentially a utf-8 =&gt; iso-latin-1 converter).<br />
<br />
For anybody who is using UTF-8 enconding, check if there is any issue before you use a method like javier's: these multi-byte values are actually the right way to represent any non-ASCII character on UTF-8.<br />
<br />
For deeper details on the UTF-8 and ISO-8859-1 encodings, take a look at wikipedia:<br />
<a href="http://en.wikipedia.org/wiki/UTF-8" rel="nofollow" target="_blank">http://en.wikipedia.org/wiki/UTF-8</a><br />
<a href="http://en.wikipedia.org/wiki/ISO-8859-1" rel="nofollow" target="_blank">http://en.wikipedia.org/wiki/ISO-8859-1</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80224""></a>
  <div class="note">
   <strong class="user">javier dot alejandro dot segura at gmail dot com</strong>
   <a href="#80224" class="date">04-Jan-2008 08:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
</span><span class="comment">/*<br />
&nbsp;:: Latin characters issue using rawurldecode() ::<br />
&nbsp;&nbsp;&nbsp; ------------------------------------------<br />
<br />
What happen if you need tu convert this %C3%B1 into this '?' using rawurldecode()? Well, it doesn't work as we'd wish to. We'll get this "?±". To fix this issue, I've made the following function:<br />
<br />
*/<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">urlRawDecode</span><span class="keyword">(</span><span class="default">$raw_url_encoded</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># Hex conversion table<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$hex_table </span><span class="keyword">= array(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">0 </span><span class="keyword">=&gt; </span><span class="default">0x00</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">1 </span><span class="keyword">=&gt; </span><span class="default">0x01</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">2 </span><span class="keyword">=&gt; </span><span class="default">0x02</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">3 </span><span class="keyword">=&gt; </span><span class="default">0x03</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">4 </span><span class="keyword">=&gt; </span><span class="default">0x04</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">5 </span><span class="keyword">=&gt; </span><span class="default">0x05</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">6 </span><span class="keyword">=&gt; </span><span class="default">0x06</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">7 </span><span class="keyword">=&gt; </span><span class="default">0x07</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">8 </span><span class="keyword">=&gt; </span><span class="default">0x08</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">9 </span><span class="keyword">=&gt; </span><span class="default">0x09</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"A"</span><span class="keyword">=&gt; </span><span class="default">0x0a</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"B"</span><span class="keyword">=&gt; </span><span class="default">0x0b</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"C"</span><span class="keyword">=&gt; </span><span class="default">0x0c</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"D"</span><span class="keyword">=&gt; </span><span class="default">0x0d</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"E"</span><span class="keyword">=&gt; </span><span class="default">0x0e</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">"F"</span><span class="keyword">=&gt; </span><span class="default">0x0f<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># Looking for latin characters with a pattern like this %C3%[A-Z0-9]{2} ie. -&gt; %C3%B1 = '?'<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">"/\%C3\%([A-Z0-9]{2})/i"</span><span class="keyword">,</span><span class="default">$raw_url_encoded</span><span class="keyword">,</span><span class="default">$res</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$res </span><span class="keyword">= </span><span class="default">array_unique</span><span class="keyword">(</span><span class="default">$res </span><span class="keyword">= </span><span class="default">$res</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$arr_unicoded </span><span class="keyword">= array();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach(</span><span class="default">$res </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$value</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$arr_unicoded</span><span class="keyword">[] = </span><span class="default">chr</span><span class="keyword">(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (</span><span class="default">0xc0 </span><span class="keyword">| (</span><span class="default">$hex_table</span><span class="keyword">[</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">,</span><span class="default">0</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)]&lt;&lt;</span><span class="default">4</span><span class="keyword">)) | (</span><span class="default">0x03 </span><span class="keyword">&amp; </span><span class="default">$hex_table</span><span class="keyword">[</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)])<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; );<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$res</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="string">"%C3%" </span><span class="keyword">. </span><span class="default">$value</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$raw_url_encoded </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">,</span><span class="default">$arr_unicoded</span><span class="keyword">,</span><span class="default">$raw_url_encoded</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># Return raw url decoded<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">rawurldecode</span><span class="keyword">(</span><span class="default">$raw_url_encoded</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="comment"># Testing<br />
</span><span class="keyword">print </span><span class="string">"Decoded character -&gt; " </span><span class="keyword">. </span><span class="default">urlRawDecode</span><span class="keyword">(</span><span class="string">"%C3%B1"</span><span class="keyword">);<br />
<br />
</span><span class="comment">// ouput:<br />
//&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Decoded chracter -&gt; ?<br />
<br />
/* <br />
<br />
:: A little explanation about what does this function do ::<br />
&nbsp;&nbsp; -----------------------------------------------------<br />
<br />
This function makes two binary operations between C3 and B1. To get an ASCII representation of this kind of raw url encoded character, we have to make a logical OR between HIGH nibble of 0xC3 (0xC) and HIGH nibble of 0xB1 (0xB) -&gt; (0xC0 | 0xB0), then, a logical AND between both LOW nibble (0x03 &amp; 0x01), and finally we have to make a logical OR between these two results -&gt; [hex] ((0xC0 | 0xB0) | (0x03 &amp; 0x01)) = [binary] ((1100 0000 | 1011 0000) | (0000 0011 &amp; 0000 0001)) = [hex] 0xF1 = [binary] 1111 0001 = "?" character.<br />
<br />
Hope to be helpfull, if you have an issue like this, try to use this function.<br />
<br />
Bye,<br />
<br />
Javi =)<br />
<br />
*/<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72597""></a>
  <div class="note">
   <strong class="user">christian _no interest in  at  spam dot  com</strong>
   <a href="#72597" class="date">25-Jan-2007 02:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had serious trouble with local Windows paths containing umlauts on my Apache 2 / Windows NT machine. Apache could not find any of those files if I just used rawurlencode. It's not noted anywhere here, but you fix this by simply making your path utf8 first:<br />
<br />
rawurlencode(utf8_encode($str));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71144""></a>
  <div class="note">
   <strong class="user">Tomek Perlak [tomekperlak at tlen pl]</strong>
   <a href="#71144" class="date">14-Nov-2006 12:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note in regards to 'rickyale at ig dot com dot br' program:<br />
<br />
Wouldn't the whole issue be fixed by using CHARSET=gb2312 in the HTML page?<br />
<br />
I'm passing some data between the HTML form and an PHP program - my 'special' characters have to do with the Polish alphabet - and it looks like JavaScript encoding actually... works. <br />
<br />
Of course, I could have tested only a limitted number of cases.<br />
<br />
Just a thought.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63751""></a>
  <div class="note">
   <strong class="user">piotr DOT wydrych AT gmail DOT com</strong>
   <a href="#63751" class="date">29-Mar-2006 11:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can encode paths using:<br />
<br />
<span class="default">&lt;?php<br />
$encoded </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">(</span><span class="string">"/"</span><span class="keyword">, </span><span class="default">array_map</span><span class="keyword">(</span><span class="string">"rawurlencode"</span><span class="keyword">, </span><span class="default">explode</span><span class="keyword">(</span><span class="string">"/"</span><span class="keyword">, </span><span class="default">$path</span><span class="keyword">)));<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="62407""></a>
  <div class="note">
   <strong class="user">jeroen at virtualhost dot nl</strong>
   <a href="#62407" class="date">28-Feb-2006 12:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On the comments of rickyale and djmaze...<br />
Is what you try to achieve is not a combination of utf8 and url encoding, e.g. :<br />
<br />
&lt;?<br />
$str = "bl?f Charl?ne";<br />
$enc = urlencode(utf8_encode($str));<br />
$str2 = utf8_decode(urldecode($enc));<br />
echo "$str -&gt; $enc -&gt; $str2";<br />
?&gt;<br />
<br />
will output:<br />
bl?f Charl?ne -&gt; bl%C3%B8f+Charl%C3%A8ne -&gt; bl?f Charl?ne<br />
<br />
At least works for me, Jeroen Hofstee</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="61394""></a>
  <div class="note">
   <strong class="user">djmaze@dragonflycms</strong>
   <a href="#61394" class="date">02-Feb-2006 12:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Easier version to 'rickyale at ig dot com dot br' his example<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">encode</span><span class="keyword">(</span><span class="default">$text</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$REQUEST_URI </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'"'</span><span class="keyword">, </span><span class="string">'%22'</span><span class="keyword">, </span><span class="default">$text</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// 0 - 128<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'#([\x3C\x3E])#e'</span><span class="keyword">, </span><span class="string">'"%".bin2hex(\'\\1\')'</span><span class="keyword">, </span><span class="default">$text</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span>Just fill the regular expression with all characters that you need to have encoded.<br />
<br />
NOTE: 142 and up in his array are language specific ASCII characters so the conversion to their unicode ('%C5%BD') equivelant may or may not work for you.<br />
This needs a far more serious and bigger system to handle for non us tables</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59328""></a>
  <div class="note">
   <strong class="user">rickyale at ig dot com dot br</strong>
   <a href="#59328" class="date">03-Dec-2005 05:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As peter@nospam said, the microsoft uses an different table for encode string when sending data... <br />
<br />
with some test i have created a table with this encodes for special char like ? ? ? ? ?<br />
<br />
here is it for those who need know what is this table..<br />
<br />
the index of array is the ord() of a character.. <br />
use with chr(index) to know the char.. and replace with the value.....<br />
<br />
var&nbsp; &nbsp; $ENCODE_TABLE = ARRAY(33=&gt;'%21', 35=&gt;'%23', 36=&gt;'%24', 37=&gt;'%25', 38=&gt;'%26', 40=&gt;'%28', 41=&gt;'%29', 43=&gt;'%2B', 44=&gt;'%2C', 47=&gt;'%2F', 58=&gt;'%3A', 59=&gt;'%3B', 60=&gt;'%3C', 61=&gt;'%3D', 62=&gt;'%3E', 63=&gt;'%3F', 91=&gt;'%5B', 92=&gt;'%5C', 93=&gt;'%5D', 123=&gt;'%7B', 124=&gt;'%7C', 125=&gt;'%7D', 142=&gt;'%C5%BD', 192=&gt;'%C3%80', 193=&gt;'%C3%81', 194=&gt;'%C3%82', 195=&gt;'%C3%83', 196=&gt;'%C3%84', 197=&gt;'%C3%85', 199=&gt;'%C3%87', 200=&gt;'%C3%88', 201=&gt;'%C3%89', 202=&gt;'%C3%8A', 203=&gt;'%C3%8B', 204=&gt;'%C3%8C', 205=&gt;'%C3%8D', 206=&gt;'%C3%8E', 207=&gt;'%C3%8F', 210=&gt;'%C3%92', 211=&gt;'%C3%93', 212=&gt;'%C3%94', 213=&gt;'%C3%95', 214=&gt;'%C3%96', 217=&gt;'%C3%99', 218=&gt;'%C3%9A', 219=&gt;'%C3%9B', 220=&gt;'%C3%9C', 221=&gt;'%C3%9D', 224=&gt;'%C3%A0', 225=&gt;'%C3%A1', 226=&gt;'%C3%A2', 227=&gt;'%C3%A3', 228=&gt;'%C3%A4', 229=&gt;'%C3%A5', 231=&gt;'%C3%A7', 232=&gt;'%C3%A8', 233=&gt;'%C3%A9', 234=&gt;'%C3%AA', 235=&gt;'%C3%AB', 236=&gt;'%C3%AC', 237=&gt;'%C3%AD', 238=&gt;'%C3%AE', 239=&gt;'%C3%AF', 242=&gt;'%C3%B2', 243=&gt;'%C3%B3', 244=&gt;'%C3%B4', 245=&gt;'%C3%B5', 246=&gt;'%C3%B6', 249=&gt;'%C3%B9', 250=&gt;'%C3%BA', 251=&gt;'%C3%BB', 252=&gt;'%C3%BC', 253=&gt;'%C3%BD', 255=&gt;'%C3%BF');<br />
<br />
example::<br />
<br />
function encode($text) {<br />
&nbsp;&nbsp;&nbsp; while(list($ord, $enc) = each($ENCODE_TABLE)) {<br />
&nbsp;&nbsp;&nbsp; $text = str_replace(chr($ord), $enc, $text);<br />
&nbsp;&nbsp;&nbsp; }<br />
return $text;<br />
}<br />
<br />
hope this help ...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56355""></a>
  <div class="note">
   <strong class="user">ulterior AT one.lt</strong>
   <a href="#56355" class="date">31-Aug-2005 02:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In addition to my last post I would like to add that, this function is for the "directories/somefile.ext" paths<br />
<br />
In order to construct valid ftp url (with password added in it )<br />
do this<br />
<br />
$valid_path = "<a href="ftp://" rel="nofollow" target="_blank">ftp://</a>" . rawurlencode($user) . ":" . rawurlencode($pass) . ftp_url_encode($your_server_path_to_file)<br />
<br />
Last function will encode path url so that language characters remain untouched and you get same file name for download after download dialog appears.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56303""></a>
  <div class="note">
   <strong class="user">ulterior AT one.lt</strong>
   <a href="#56303" class="date">30-Aug-2005 09:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This seems the correct way to encode ftp url which you could provide for your users:<br />
<br />
function ftp_url_encode($string) {<br />
<br />
&nbsp;&nbsp; $hex="";<br />
&nbsp;&nbsp; $retstr = "";<br />
&nbsp;&nbsp; for ($i=0; $i &lt; strlen($string) ;$i++) {<br />
<br />
&nbsp;&nbsp; &nbsp; $char = $string[$i];<br />
&nbsp;&nbsp; &nbsp; if(($char &gt;= '0' &amp;&amp; $char &lt;= '9') || ($char &gt;= 'A' &amp;&amp; $char &lt;= 'Z') || ($char &gt;= 'a' &amp;&amp; $char &lt;= 'z') || $char == '.' || $char == '-' || $char == '/' || (ord($char) &gt;=128) ) $retstr .= $char;<br />
&nbsp;&nbsp; &nbsp; else<br />
&nbsp;&nbsp; &nbsp; $retstr .= "%".strtoupper(dechex(ord($string[$i])));<br />
<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; return $retstr;<br />
} <br />
<br />
Browsers mangle certain language characters</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="53388""></a>
  <div class="note">
   <strong class="user">peter at nospam dot webgains dot com</strong>
   <a href="#53388" class="date">31-May-2005 10:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The microsoft URLEncode method ignores the documentation in RFC1738 which states that:<br />
<br />
".... the special characters "$-_.+!*'(),", and reserved characters used for their reserved purposes may be used unencoded within a URL"<br />
<br />
So for example, myaddress@mydomain.com becomes myaddress%40mydomain%2Ecom, whereas php and other languages would encode this as myaddress%40mydomain.com<br />
<br />
This can be an issue when porting from asp or if you are doing string comparison of strings urlencoded on different platforms.<br />
<br />
NB. php will correctly decode myaddress%40mydomain%2Ecom to myaddress@mydomain.com, it is only the encoding that differs</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="48792""></a>
  <div class="note">
   <strong class="user">Lucas Gonze -- lucas at gonze dot com</strong>
   <a href="#48792" class="date">07-Jan-2005 07:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have attempted to incorporate all of the previous comments, plus several bug fixes, into&nbsp; dphantom's linkencode.&nbsp; I see no bugs for these test cases:<br />
<a href="http://example.com/path1;var1=val1/p2;v2" rel="nofollow" target="_blank">http://example.com/path1;var1=val1/p2;v2</a><br />
<a href="http://example.com/p1;v1/p2;v2" rel="nofollow" target="_blank">http://example.com/p1;v1/p2;v2</a><br />
<a href="http://[ip:v6:440]:8080" rel="nofollow" target="_blank">http://[ip:v6:440]:8080</a><br />
<a href="http://example.com:8080" rel="nofollow" target="_blank">http://example.com:8080</a><br />
<a href="http://example.com/~joe" rel="nofollow" target="_blank">http://example.com/~joe</a><br />
<a href="http://example.com/foobar/~joe" rel="nofollow" target="_blank">http://example.com/foobar/~joe</a><br />
<a href="http://username:password@hostname/path 1//path 2/?arg 1=value 1&amp;arg 2=value 2#fragment identifier" rel="nofollow" target="_blank">http://username:password@hostname/path 1//path 2/?arg 1=value 1&amp;arg 2=value 2#fragment identifier</a><br />
hostname/path 1//path 2/?arg 1=value 1&amp;arg 2=value 2#fragment identifier<br />
<a href="http://invalid_host..name/" rel="nofollow" target="_blank">http://invalid_host..name/</a><br />
<br />
function linkencode($p_url){<br />
&nbsp;&nbsp; $uparts = @parse_url($p_url);<br />
<br />
&nbsp;&nbsp; $scheme = array_key_exists('scheme',$uparts) ? $uparts['scheme'] : "";<br />
&nbsp;&nbsp; $pass = array_key_exists('pass',$uparts) ? $uparts['pass']&nbsp; : "";<br />
&nbsp;&nbsp; $user = array_key_exists('user',$uparts) ? $uparts['user']&nbsp; : "";<br />
&nbsp;&nbsp; $port = array_key_exists('port',$uparts) ? $uparts['port']&nbsp; : "";<br />
&nbsp;&nbsp; $host = array_key_exists('host',$uparts) ? $uparts['host']&nbsp; : "";<br />
&nbsp;&nbsp; $path = array_key_exists('path',$uparts) ? $uparts['path']&nbsp; : "";<br />
&nbsp;&nbsp; $query = array_key_exists('query',$uparts) ? $uparts['query']&nbsp; : "";<br />
&nbsp;&nbsp; $fragment = array_key_exists('fragment',$uparts) ? $uparts['fragment']&nbsp; : "";<br />
<br />
&nbsp;&nbsp; if(!empty($scheme))<br />
&nbsp;&nbsp; &nbsp; $scheme .= '://';<br />
<br />
&nbsp;&nbsp; if(!empty($pass) &amp;&amp; !empty($user)) {<br />
&nbsp;&nbsp; &nbsp; $user = rawurlencode($user).':';<br />
&nbsp;&nbsp; &nbsp; $pass = rawurlencode($pass).'@';<br />
&nbsp;&nbsp; } elseif(!empty($user))<br />
&nbsp;&nbsp; &nbsp; $user .= '@';<br />
<br />
&nbsp;&nbsp; if(!empty($port) &amp;&amp; !empty($host))<br />
&nbsp;&nbsp; &nbsp; &nbsp; $host = ''.$host.':';<br />
&nbsp;&nbsp; elseif(!empty($host))<br />
&nbsp;&nbsp; &nbsp; &nbsp; $host=$host;<br />
<br />
&nbsp;&nbsp; if(!empty($path)){<br />
&nbsp;&nbsp; &nbsp; $arr = preg_split("/([\/;=])/", $path, -1, PREG_SPLIT_DELIM_CAPTURE); // needs php &gt; 4.0.5.<br />
&nbsp;&nbsp; &nbsp; $path = "";<br />
&nbsp;&nbsp; &nbsp; foreach($arr as $var){<br />
&nbsp;&nbsp; &nbsp; &nbsp; switch($var){<br />
&nbsp;&nbsp; &nbsp; &nbsp; case "/":<br />
&nbsp;&nbsp; &nbsp; &nbsp; case ";":<br />
&nbsp;&nbsp; &nbsp; &nbsp; case "=":<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $path .= $var;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; default:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $path .= rawurlencode($var);<br />
&nbsp;&nbsp; &nbsp; &nbsp; }<br />
&nbsp;&nbsp; &nbsp; }<br />
&nbsp;&nbsp; &nbsp; // legacy patch for servers that need a literal /~username<br />
&nbsp;&nbsp; &nbsp; $path = str_replace("/%7E","/~",$path);<br />
&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; if(!empty($query)){<br />
&nbsp;&nbsp; &nbsp; $arr = preg_split("/([&amp;=])/", $query, -1, PREG_SPLIT_DELIM_CAPTURE); // needs php &gt; 4.0.5.<br />
&nbsp;&nbsp; &nbsp; $query = "?";<br />
&nbsp;&nbsp; &nbsp; foreach($arr as $var){<br />
&nbsp;&nbsp; &nbsp; &nbsp; if( "&amp;" == $var || "=" == $var )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $query .= $var;<br />
&nbsp;&nbsp; &nbsp; &nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $query .= urlencode($var);<br />
&nbsp;&nbsp; &nbsp; }&nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; if(!empty($fragment))<br />
&nbsp;&nbsp; &nbsp; $fragment = '#'.urlencode($fragment);<br />
<br />
&nbsp;&nbsp; return implode('', array($scheme, $user, $pass, $host, $port, $path, $query, $fragment));<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="28800""></a>
  <div class="note">
   <strong class="user">Andrew Eigus</strong>
   <a href="#28800" class="date">24-Jan-2003 12:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
note that if you implement your own server request engine in the HTTP manner like:<br />
<br />
GET $request_uri<br />
<br />
you should first split all parts of the $request_uri path and rawurlencode() each part, then concatenate those parts back again.&nbsp; this function will translate the URI correctly:<br />
<br />
function translate_uri($uri) {<br />
&nbsp;&nbsp;&nbsp; $parts = explode('/', $uri);<br />
&nbsp;&nbsp;&nbsp; for ($i = 0; $i &lt; count($parts); $i++) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; $parts[$i] = rawurlencode($parts[$i]);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return implode('/', $parts);<br />
}<br />
<br />
because if you do rawurlencode() over the whole URI, path separator characters '/' are also encoded and request will not happen to be correct.&nbsp; '/' characters should not be encoded, only those parts in between.<br />
<br />
hope this helps someone like me...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26872""></a>
  <div class="note">
   
   <a href="#26872" class="date">15-Nov-2002 04:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that RFC 1738 has been amended:<br />
The "[" and "]" are no longer considered unsafe, but instead are now considered "reserved", meaning that they CAN be used in URLs!<br />
<br />
Currently this usage has only been allowed in the hostname part, but there are some proposals to allow such use in some URL schemes. Similar extensions are now found that use the "{}" characters as "reserved" characters with special semantics, instead of "unsafe" characters that must be URL encoded...<br />
<br />
Note also that some characters are currently "reserved" but should have instead been considered as "unsafe": this includes the parenthesis "()" which are clearly unsafe when a URL is used in MIME headers.<br />
<br />
Because of this, if a valid URL contains "()" characters, one should use an upper-level encoding to either enclose the URL with a pair of "unsafe" characters defined in the upper-level protocol (for example a "&lt;&gt;" pair in MIME headers, because these characters cannot be part of a valid URL)...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26870""></a>
  <div class="note">
   
   <a href="#26870" class="date">15-Nov-2002 04:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
About the ";" reserved character in URLs:<br />
<br />
rawurlencode() will encode it with a "%2A" triplet. When used on the path part of a URL, this will break the usage defined in URL RFCs, that allows specifying additional parameters to *EACH* element of a path (separated by "/").<br />
<br />
So if a path element contains a ";" character (some filesystems allow it, but this is not recommanded) as part of a directory name, this character must be encoded so that it won't be mixed with a parameter extension.<br />
<br />
This mapping is allowed on URLs that use a hierarchical scheme (HTTP, HTTPS, FTP, FILE, ...), so that each path element prefixed by "/" can have additional navigational parameters such as authorization strings or semantic parameters.<br />
<br />
The generic format of a path element may include path elements such as:<br />
"/." or "/.." or "/.specialname" or "/regularname"<br />
Each part may be followed by a ";" and other parameters separated by ";". These parameters can be eithger ordered or unordered. Unordered parameters have a symbolic name separated from their value with an equal sign.<br />
<br />
Do not mix path element parameters with a query string: these parameters are directly attached to the individual path element, and this makes a difference when this path element is not the last one of the URL. These parameters are part of the resource name (unlike the query string), and the semantic of "." and ".." apply to the full path element with its parameters, so that:<br />
"/subdir1/subdir2/page.html;CHARSET=gb2312/../index.html"<br />
will resolve to "/subdir1/index.html".<br />
<br />
Note that:<br />
"/subdir1/subdir2/page.html;CHARSET=gb2312"<br />
designates a DISTINCT resource name from:<br />
"/subdir1/subdir2/page.html"<br />
It does not necessarily involves a query, and so it can be cached by default (unlike URLs that contain a query string).<br />
<br />
When using path element parameters, their optional name and required value must be rawurlencode()'d separately before inserting ";" and "=" parameters and creating the path elements that will be imploded in the full path.<br />
<br />
The consequence is that you MUST not urlencode() or rawurlencode individual path elements, without first parsing them:<br />
- first explode the path into its path lements separated by "/"<br />
- then explode each path element in their name and parameters separated by ";" characters<br />
- then split path element parameters that contain a "=" sign into a name/value pair.<br />
- make sure that unordered path paremeters (that have been cut according to "=" into a pair) are specified *after* ordered parameters (including the main path element name) in each path element, and that no two unordered parameters have the same name (this restriction does not occur on unordered, unnamed parameters which only supply a value).<br />
- finally you can interpret rawurlencoded names and values that constitute each path element.<br />
<br />
Note also that some non-compliant HTTP servers consider that named parameters are ordered, and don't add a semantic to the ";" and "=" used to break up the list of path element parameters. On client agents, when validating URLs, it's best then not to try to interpret this list, and you should just split the main part of a path element and the parameters list by isolating the first ";" that introduces this list. However, the encoded parameter list cannot include any "/" parameter.<br />
<br />
Caveats: note that path element parameters (introduced by ";") may be used on upper levels of a hierarchic URL, even before the final document name and its query parameters. When building lists of URLs, you should not separate URLs blindly with a ";" separator, as each URL may include a ";" character, in their path part (the ";" character cannot ocur safely in a query string). In that case, use a surrounding pair such as "&lt;&gt;" or quotes to enclose each URL in such a list.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26869""></a>
  <div class="note">
   
   <a href="#26869" class="date">15-Nov-2002 03:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
--- 1) About "reserved" characters in URLS:<br />
<br />
Beware that RFC 1738 specifies that the characters "{", "}", "|", "\", "^", "~", "[", "]", and "`" are all considered unsafe and SHOULD be URL-encoded with a "%xx" triplet within *ALL* URLs.<br />
<br />
However, some HTTP URLs seem to use the "~" character as a prefix for a user account for example:<br />
<a href="http://www.any.host.domain/~user/subpath/page.html?query#fragment" rel="nofollow" target="_blank">http://www.any.host.domain/~user/subpath/page.html?query#fragment</a><br />
<br />
This usage is acceptable, but the RFC specifies that "%7E" should be used instead of "~" in the path component. HTTP servers should accept "~" as being equivalent to "%7E", and according to the RFC, the "%7E" form should be the canonical one.<br />
<br />
However, some HTTP servers are not fully complying to this RFC and consider "%7E" differently from "~" (i.e. they consider it as being part of a path component name, and search a directory name containing a "~" character, instead of mapping the "~user" path component to a user's directory. In that case, these non compliant HTTP server will not find the resource associated to that URL and may return a 404 error or other errors such as an access denied.<br />
<br />
When using rawurlencode() on such HTTP URLs, it's best to consider this legacy usage, by using str_replace() on the result to convert back "/%7E" to "/~", so that the URLs will correctly map to the legacy use of the "~" character by these servers. On compliant HTTP servers, they will treat the "~" unsafe character equivalently with the "%7E" recommanded form, so they will automatically canonicalize the "~" character into "%7E".<br />
<br />
--- 2) Encoding of hostnames in URLs<br />
<br />
Finally, beware that host domain names parts in URLs *MUST NOT* be encoded with rawurlencode(), as the "[" and "]" are valid delimiters that *MUST* be used to reference an IPv6 address or other hostnames that don't fit to the restricted set of characters allowed in a host name (the "[" and "]" characters MUST be used if the hostname includes characters such as ":" which is typically used to specify an alternate non-default port number).<br />
<br />
The encoding of host names uses another encoding, required to encode international domain names, with a base-64 encoding of Unicode characters and a "bq--" prefix. This encoding must be used only on individual subdomain parts (separated by "." characters). This encoding does not use any "%xx" triplets.<br />
<br />
So NEVER use urlencode() or rawurlencode() on an unparsed URL, unless this full URL is part of a query parameter string!<br />
<br />
--- 3) Encoding of username/passwords in URLs:<br />
<br />
There is no standard to specify a password in a URL. In fact, there's a legacy usage of the ":" character to separate a username from a password, but it is strongly discouraged. The RFC does not attempt to specify a semantic to the authentication part of an URL (before the "@" character and the hostname part).<br />
<br />
If you need to encode a password, always use rawurlencode() on username and passwords separately, and then insert the ":" character to separate both components. Don't use urlencode() (which could use a "+" to encode a space, and would not work because usernames and passwords consider "+" and spaces as being different!)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25182""></a>
  <div class="note">
   
   <a href="#25182" class="date">13-Sep-2002 02:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
rawurlencode() MUST not be used on unparsed URLs.<br />
<br />
rawurlencode() should not be used on host and domain name parts (that may include international characters encoded in each domain part with a "q--" prefix followed by a special encoding of the international domain, currently in testbed).<br />
<br />
rawurlencode() may be used on usernames and passwords separately (so that it won't encode the ':' and '@' separators).<br />
<br />
rawurlencode() must not be used on paths (that may contain '/' separators): the ['path'] element of a parsed URL must first be exploded into individual "directory" names. A directory or filename that contains a space must not be encoded with urlencode() but with this rawurlencode(), so that it will appear as a '%20' hex sequence (not '+')<br />
<br />
rawurlencode() must not be used to encode the ['query'] element of a parsed URL. Instead you must use the urlencode() function:<br />
<br />
Typical queries often use the '&amp;' separator between each parameter. This '&amp;' separator however is just a convention, used in the www-url-encoded format for HTML forms using the default GET method. However, when references are done in a HTML page to an URL that contains static query parameters, these '&amp;' separators should be encoded in the HTML code as '&amp;amp;' for HTML conformance. This is not part of the URL specification, but of the HTML encapsulation! Some browsers forget this, and send '&amp;amp;' with their HTTP GET query. You may wish to substitute '&amp;amp;' by '&amp;' when parsing and validating URLs. This should be done BEFORE calling urlencode() on query parts.<br />
<br />
The ['fragment'] part of a parsed URL (after the first '#' separator found in any URL) must not be encoded with this rawurlencode() function but instead by urlencode().<br />
<br />
Validating a URL sent in a HTTP request is then more complicated than what you may think. This must be done only on parsed URLs (where the basic elements of an URL have been splitted), and then you must explode the path components, and check the presence of '&amp;amp;' sequences in the query or fragment parts.<br />
<br />
The next thing to do is to check the URL scheme that you want to support (for example, only 'http', 'https', or 'ftp').<br />
<br />
You may wich to check the ['port'] part to see if it's really a decimal integer between 1 and 65535.<br />
You may wish to remove the default port number used by the URL schemes you want to support (for example the port '80' for 'http', the port '21' for 'ftp', the port '443' for 'https'), and restrict severely all port numbers below 1024, or some critical ports below 140 (this includes DNS and NetBios ports).<br />
<br />
Then you may wish to control severely the ['host'] part (in fact a full host domain name or an IP address), by forbidding those host names that don't contain at least one dot, forbidding those that start with a dot, those that contain two consecutive dots, those that start or finish with a '-' dash, those that contain '.-' or '-.' (invalid in all domain names), those that contain two dashes in another position than the second and third character of a domain name part and not folled by at least one other character, forbid top level domain names that have only one non numeric character, or more than 6 characters (".museum" is, for now, the longest acceptable TLD), check that pseudo-TLD names that are pure integers are effectively between 0 and 255, in that case check that this is a valid IPv4 address by comparing it to long2ip(ip2long($host)), ...<br />
<br />
This done, you must use the urlencode() function on all parts up to the exploded path elements, and rawurlencode() on the query and fragment parts, according to the specs, to recreate a complete and validated URL.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="18746""></a>
  <div class="note">
   <strong class="user">dphantom at ticino dot com</strong>
   <a href="#18746" class="date">03-Feb-2002 11:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP's functions rawurlencode() and urlencode(), both encode the whole argument parameter string, making the result useless as a valid link. <br />
<br />
The function listed here encodes a link string (e.g. <a href="http://www.domain.com/long_path/to" rel="nofollow" target="_blank">http://www.domain.com/long_path/to</a>\file.php?query=param#fragm) to a valid &lt;a href=""&gt; parameter string, preserving the original URI structure and the path given.<br />
<br />
function linkencode ($p_url) {<br />
&nbsp;&nbsp;&nbsp; $ta = parse_url($p_url);<br />
&nbsp;&nbsp;&nbsp; if (!empty($ta[scheme])) { $ta[scheme].='://'; }<br />
&nbsp;&nbsp;&nbsp; if (!empty($ta[pass]) and !empty($ta[user])) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ta[user].=':';<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ta[pass]=rawurlencode($ta[pass]).'@';<br />
&nbsp;&nbsp;&nbsp; } elseif (!empty($ta[user])) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $ta[user].='@';<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (!empty($ta[port]) and !empty($ta[host])) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $ta[host]=''.$ta[host].':';<br />
&nbsp;&nbsp;&nbsp; } elseif&nbsp; &nbsp; (!empty($ta[host])) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $ta[host]=$ta[host];<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (!empty($ta[path])) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $tu='';<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $tok=strtok($ta[path], "\\/");<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; while (strlen($tok)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $tu.=rawurlencode($tok).'/';<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $tok=strtok("\\/");<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $ta[path]='/'.trim($tu, '/');<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (!empty($ta[query])) { $ta[query]='?'.$ta[query]; }<br />
&nbsp;&nbsp;&nbsp; if (!empty($ta[fragment])) { $ta[fragment]='#'.$ta[fragment]; }<br />
&nbsp;&nbsp;&nbsp; return implode('', array($ta[scheme], $ta[user], $ta[pass], $ta[host], $ta[port], $ta[path], $ta[query], $ta[fragment]));<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
