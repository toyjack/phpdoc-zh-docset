<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>预定义变量</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.variables.basics.html">? 基础</a></li>
      <li style="float: right;"><a href="language.variables.scope.html">变量范围 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="language.variables.html">变量</a></li>
    <li>预定义变量</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.variables.predefined" class="sect1">
   <h2 class="title">预定义变量</h2>

   <p class="simpara">
    PHP 提供了大量的预定义变量。由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。一些预定义变量在
    PHP 以<a href="features.commandline.html" class="link">命令行</a>形式运行时并不生效。有关这些变量的详细列表，请参阅<a href="reserved.variables.html" class="link">预定义变量</a>一章。
   </p>

   <div class="warning"><strong class="warning">Warning</strong>
    <p class="simpara">
     PHP 4.2.0 以及后续版本中，PHP 指令 <a href="ini.core.html#ini.register-globals" class="link">register_globals</a> 的默认值为
     <em class="emphasis">off</em>。这是 PHP 的一个主要变化。让 register_globals 的值为
     <em class="emphasis">off</em> 将影响到预定义变量集在全局范围内的有效性。例如，为了得到
     <var class="varname"><var class="varname">DOCUMENT_ROOT</var></var> 的值，将必须使用
     <var class="varname"><var class="varname"><a href="reserved.variables.server.html" class="classname">$_SERVER['DOCUMENT_ROOT']</a></var></var> 代替
     <var class="varname"><var class="varname">$DOCUMENT_ROOT</var></var>，又如，使用
     <var class="varname"><var class="varname"><a href="reserved.variables.get.html" class="classname">$_GET['id']</a></var></var> 来代替 <var class="varname"><var class="varname">$id</var></var> 从 URL
     <em>http://www.example.com/test.php?id=3</em> 中获取
     id 值，亦或使用 <var class="varname"><var class="varname"><a href="reserved.variables.environment.html" class="classname">$_ENV['HOME']</a></var></var> 来代替
     <var class="varname"><var class="varname">$HOME</var></var> 获取环境变量 HOME 的值。
    </p>
    <p class="simpara">
     更多相关信息，请阅读 <a href="ini.core.html#ini.register-globals" class="link">register_globals</a>
     的配置项条目，安全一章中的<a href="security.globals.html" class="link">使用 Register Globals</a>，以及 PHP
     <a href="http://www.php.net/releases/4_1_0.php" class="link external" title="Link : http://www.php.net/releases/4_1_0.php">&raquo;&nbsp;4.1.0</a> 和
     <a href="http://www.php.net/releases/4_2_0.php" class="link external" title="Link : http://www.php.net/releases/4_2_0.php">&raquo;&nbsp;4.2.0</a> 的发布公告。
    </p>
    <p class="simpara">
     如果有可用的 PHP 预定义变量那最好用，如<a href="language.variables.superglobals.html" class="link">超全局数组</a>。
    </p>
   </div>

   <p class="simpara">
    从 PHP 4.1.0 开始，PHP 提供了一套附加的预定数组，这些数组变量包含了来自 web
    服务器（如果可用），运行环境，和用户输入的数据。这些数组非常特别，它们在全局范围内自动生效，例如，在任何范围内自动生效。因此通常被称为自动全局变量（autoglobals）或者超全局变量（superglobals）。（PHP
    中没有用户自定义超全局变量的机制。）超全局变量罗列于下文中；但是为了得到它们的内容和关于
    PHP 预定义变量的进一步的讨论以及它们的本质，请参阅<a href="reserved.variables.html" class="link">预定义变量</a>。而且，你也将注意到旧的预定义数组（<var class="varname"><var class="varname">$HTTP_*_VARS</var></var>）仍旧存在。自 PHP 5.0.0 起, 用
<a href="ini.core.html#ini.register-long-arrays" class="link">register_long_arrays</a> 设置选项可禁用
长类型的 PHP <a href="language.variables.predefined.html" class="link">预定义变量</a>数组。
   </p>

   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <strong>可变变量</strong><br />
    <p class="para">
     超级全局变量不能被用作函数或类方法中的<a href="language.variables.variable.html" class="link">可变变量</a>。
    </p>
   </p></blockquote>
    <blockquote class="note"><p><strong class="note">Note</strong>: 
    <p class="para">
     尽管超全局变量和 HTTP_*_VARS
     同时存在，但是它们并不是同一个变量，所以改变其中一个的值并不会对另一个产生影响。
    </p>
   </p></blockquote>

   <p class="para">
    如果某些 <a href="ini.core.html#ini.variables-order" class="link">variables_order</a>
    中的变量没有设定，它们的对应的 PHP 预定义数组也是空的。
   </p>

  </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="80794""></a>
  <div class="note">
   <strong class="user">root at mantoru dot de</strong>
   <a href="#80794" class="date">31-Jan-2008 09:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To tokie at hanmail dot net: You took that out of context -- it is merely a recommendation.<br />
<br />
If your variables_order setting does not contain "E", $_ENV is still useful. Every call to getenv will be "cached" in $_ENV, so you can do this:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// variables_order = GPCS<br />
</span><span class="default">var_dump</span><span class="keyword">(isset(</span><span class="default">$_ENV</span><span class="keyword">[</span><span class="string">'PATH'</span><span class="keyword">])); </span><span class="comment">// bool(false)<br />
</span><span class="default">getenv</span><span class="keyword">(</span><span class="string">'PATH'</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(isset(</span><span class="default">$_ENV</span><span class="keyword">[</span><span class="string">'PATH'</span><span class="keyword">])); </span><span class="comment">// bool(true)<br />
</span><span class="default">?&gt;<br />
</span><br />
For some reason, it does not work with with own environment variables. The above example with PHP_TEST instead of PATH would fail (if it is set via putenv).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="76062""></a>
  <div class="note">
   <strong class="user">fabrizio at bibivu dot com</strong>
   <a href="#76062" class="date">28-Jun-2007 04:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
theonly_DD32, I refined your function a little bit<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">long_to_GET</span><span class="keyword">(</span><span class="default">$PATH_INFO</span><span class="keyword">=</span><span class="string">''</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * This function converts info.php/a/1/b/2/c?d=4 TO<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * array ( [d] =&gt; 4 [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; array ( [d] =&gt; 4 ) )<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * got this function from <a href="http://php.net/GLOBALS" rel="nofollow" target="_blank">http://php.net/GLOBALS</a><br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; **/<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">$PATH_INFO</span><span class="keyword">==</span><span class="string">'' </span><span class="keyword">&amp;&amp; isset(</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">]) &amp;&amp; </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">] != </span><span class="string">''</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$PATH_INFO </span><span class="keyword">= </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$PATH_INFO </span><span class="keyword">!= </span><span class="string">''</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Split it out.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">,</span><span class="default">$PATH_INFO</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Remove first empty item<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">unset(</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Loop through and apend it into the $_GET superglobal.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;=</span><span class="default">count</span><span class="keyword">(</span><span class="default">$tmp</span><span class="keyword">);</span><span class="default">$i</span><span class="keyword">+=</span><span class="default">2</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">strpos</span><span class="keyword">(</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">],</span><span class="string">'?'</span><span class="keyword">)!==</span><span class="default">false</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$tmp1 </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'?'</span><span class="keyword">,</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">parse_str</span><span class="keyword">(isset(</span><span class="default">$tmp1</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">])?</span><span class="default">$tmp1</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]:</span><span class="string">''</span><span class="keyword">,</span><span class="default">$_GET</span><span class="keyword">[</span><span class="default">$tmp1</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i</span><span class="keyword">--;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$_GET</span><span class="keyword">[</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]] = isset(</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">])?</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">]:</span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74620""></a>
  <div class="note">
   <strong class="user">pinkgothic at gmail dot com</strong>
   <a href="#74620" class="date">20-Apr-2007 04:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Dealing with "superglobals" and functions is not as straightforward as it may seem when you're doing plenty manipulations.<br />
<br />
For example:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; </span><span class="keyword">function </span><span class="default">some_other_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">];<br />
&nbsp; }<br />
&nbsp; function </span><span class="default">some_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">] = </span><span class="default">440</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">some_other_method</span><span class="keyword">();<br />
&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Calling some_method() will cause a warning-level error by PHP informing you that "id" is not set in some_other_method(). However, if you instead use:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; $_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">] = </span><span class="default">0</span><span class="keyword">;<br />
&nbsp; function </span><span class="default">some_other_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">];<br />
&nbsp; }<br />
&nbsp; function </span><span class="default">some_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">] = </span><span class="default">440</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">some_other_method</span><span class="keyword">();<br />
&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Then the script will echo 440.<br />
<br />
In consequence, if you manually attempt to add keys to the superglobals, those keys *aren't* automatically superglobal. The above example isn't very sensible, of course, but this can be a huge gotcha if you're juggling user data between functions and you're unwittingly being forced to work inside a function (e.g. via PHP include in TYPO3).<br />
<br />
Unfortunately, global $_REQUEST['id'] won't save you, either - it causes a parse error - nor will a global $_REQUEST change anything after you've set the keys... consequently making it hard to conviniently 'hack' outdated scripts by making them believe they're still running in a different environment.<br />
<br />
The only "solution" to this issue is to use parameters.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72829""></a>
  <div class="note">
   <strong class="user">holger at doessing dot net</strong>
   <a href="#72829" class="date">02-Feb-2007 03:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On the subject of permalinks and queries:<br />
Say, you use an inexpensive subdomain of (e.g.) www.nice.net, thus www.very.nice.net, and that the domain owner has simply placed a frame at this particular location, linking to the actual address (ugly and subject-to-change) of your site.<br />
Consequently, the actual site URI and various associated hashes and query strings are not immediately visible to the user. Sometimes this is useful, but it also makes bookmarking/permalinking impossible (the browser will only bookmark the static address in the top frame).<br />
However, as far as the query strings go, there is workaround. Instead of providing users with permalinks to the actual URI (e.g. prtcl://weird.and.ugly/~very/ugly.php?stuff=here; may even be subject to change), I provide them with this: prtcl://www.very.nice.net?stuff=here.<br />
<br />
In brief, I then use the following code to re-populate the $_GET array:<br />
<br />
if (isset($_SERVER['HTTP_REFERER'])) { // If set, this page is running in a frame<br />
&nbsp;&nbsp;&nbsp; $uri = parse_url($_SERVER['HTTP_REFERER']); // grab URI of parent frame<br />
&nbsp;&nbsp;&nbsp; $querystring = ($uri['query']) ? $uri['query'] : false; // grab the querystring<br />
&nbsp;&nbsp;&nbsp; if ($querystring) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $vars = explode('&amp;', $querystring); // cut into individual statements<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach ($vars as $varstring) { // populate $_GET<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $var = explode('=', $varstring);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (count($var) == 2) $_GET[$var[0]] = $var[1];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; } // no, nothing to report from the parent frame<br />
} // no, not using a parent frame today...<br />
<br />
If the actual host address is ever changed, users entering the frame (with the nicer address) will be using the new (and ugly) URI, but this way the old query strings will be available to the new address also. The users will never again be bothered by you moving to another neighborhood.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68765""></a>
  <div class="note">
   <strong class="user">yarco dot w at gmail dot com</strong>
   <a href="#68765" class="date">10-Aug-2006 04:13</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
And you should know<br />
<br />
$_POST is not a reference of $HTTP_POST_VARS<br />
<br />
So, if you change $_POST, there are no change to $HTTP_POST_VARS.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="65659""></a>
  <div class="note">
   <strong class="user">I?igo Medina</strong>
   <a href="#65659" class="date">05-May-2006 10:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is true. I usually write variables in this way: $chuckNorrisFilms. So one almost never finds problems.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="64336""></a>
  <div class="note">
   <strong class="user">johnphayes at gmail dot com</strong>
   <a href="#64336" class="date">12-Apr-2006 07:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I haven't found it anywhere else in the manual, so I'll make a note of it here - PHP will automatically replace any dots ('.') in an incoming variable name with underscores ('_'). So if you have dots in your incoming variables, e.g.:<br />
<br />
example.com/page.php?chuck.norris=nevercries<br />
<br />
you can not reference them by the name used in the URI:<br />
//INCORRECT<br />
echo $_GET['chuck.norris'];<br />
<br />
instead you must use:<br />
//CORRECT<br />
echo $_GET['chuck_norris'];</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63708""></a>
  <div class="note">
   <strong class="user">jk at ricochetsolutions dot com</strong>
   <a href="#63708" class="date">28-Mar-2006 10:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
here is a one line snippet to do the same as DD32's func<br />
<br />
@preg_replace(<br />
&nbsp;&nbsp; "/(?i)([a-z0-9_]+)\/([a-z0-9_]+)\/?/e", <br />
&nbsp;&nbsp; '$_GET[\'$1\'] = "$2";', <br />
&nbsp;&nbsp; ((isset($_SERVER['PATH_INFO'])) ? $_SERVER['PATH_INFO'] : '')<br />
);<br />
<br />
may be faster, it may not ;o</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63312""></a>
  <div class="note">
   <strong class="user">DD32=theonly_DD32[&amp;amp;]yahoo.com.au</strong>
   <a href="#63312" class="date">19-Mar-2006 02:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have this function in my main files, it allows for easier SEO for some pages without having to rely on .htaccess and mod_rewrite for some things.<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">long_to_GET</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * This function converts info.php/a/1/b/2/c?d=4 TO<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * Array ( [d] =&gt; 4 [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; ) <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; **/<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(isset(</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">]) &amp;&amp; </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">] != </span><span class="string">''</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Split it out.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">,</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Remove first empty item<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">unset(</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Loop through and apend it into the $_GET superglobal.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;=</span><span class="default">count</span><span class="keyword">(</span><span class="default">$tmp</span><span class="keyword">);</span><span class="default">$i</span><span class="keyword">+=</span><span class="default">2</span><span class="keyword">){ </span><span class="default">$_GET</span><span class="keyword">[</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]] = </span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">];}<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Its probably not the most efficient, but it does the job rather nicely.<br />
<br />
DD32</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="62735""></a>
  <div class="note">
   
   <a href="#62735" class="date">08-Mar-2006 02:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
there is a difference to the scope of eg. java: variables that are defined inside a block are also defined outside of&nbsp; the brackets.<br />
<br />
eg. this works:<br />
<br />
if {true}<br />
{<br />
&nbsp; $a = 'it works';<br />
}<br />
<br />
echo $a;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56717""></a>
  <div class="note">
   <strong class="user">Graeme Jefferis</strong>
   <a href="#56717" class="date">13-Sep-2005 01:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I find this sort of thing consistently useful for dealing with superglobals in safety and comfort.<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">foreach (</span><span class="default">$_POST </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$value</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; switch (</span><span class="default">$key</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"submitted_var_1"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"submitted_var_2"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"submitted_var_3"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $</span><span class="default">$key </span><span class="keyword">= </span><span class="default">$value</span><span class="keyword">; break;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"dangerous_var"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$value </span><span class="keyword">= </span><span class="default">do_something_special_with</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $</span><span class="default">$key </span><span class="keyword">= </span><span class="default">$value</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56689""></a>
  <div class="note">
   <strong class="user">Nicole King</strong>
   <a href="#56689" class="date">12-Sep-2005 08:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There seems to a maximum size of key that you can use for the $_SESSION array on php5. If you exceed this length, which seems to be around 72 characters, the value is stored in the array, but is not serialised and restored later in the session (ie. when a subsquent page is processed). The same restriction *might* apply to other system-defined arrays.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56289""></a>
  <div class="note">
   <strong class="user">webdesign at benking dot com</strong>
   <a href="#56289" class="date">29-Aug-2005 11:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
# this is a follow-up to kasey at cornerspeed's 14-Jun-2004 08:33 post and debabratak at softhome's 14-Mar-2003 12:59 post, minus sessions but including a safety mechanism to block unwanted variables...<br />
<br />
# if you are like me and do not want to have to type $_POST[some_var] to get to all your passed variable data, you can safely convert all the data to the variable names (so it is like old style php) by using a pre-defined allowed arg names list like this;<br />
<br />
$allowed_args = ',f_name,l_name,subject,msg,';<br />
<br />
foreach(array_keys($_POST) as $k) {<br />
&nbsp;&nbsp;&nbsp; $temp = ",$k,";<br />
&nbsp;&nbsp;&nbsp; if(strpos($allowed_args,$temp) !== false) { $$k = $_POST[$k]; }<br />
}<br />
<br />
# then you can use the programmer friendly (less typing) vars like so;<br />
echo "Hello $f_name";<br />
<br />
# make sure you have commas in front of and after each var name in the $allowed_args list, so strpos will never surprise you by mistakingly finding an unwanted var name within another var name</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52857""></a>
  <div class="note">
   <strong class="user">dompody [at] gmail [dot] com</strong>
   <a href="#52857" class="date">15-May-2005 02:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To urbanheroes:<br />
<br />
version_compare() is only in PHP version 4.1.0 and up. This completely negates your function, since if the version is less than 4.1.0 it will generate an error anyway. The better solution is to do what is stated in the post above yours:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if (!isset(</span><span class="default">$_SERVER</span><span class="keyword">))<br />
{<br />
&nbsp;&nbsp; </span><span class="default">$_GET&nbsp; &nbsp; </span><span class="keyword">= &amp;</span><span class="default">$HTTP_GET_VARS</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$_POST&nbsp; &nbsp; </span><span class="keyword">= &amp;</span><span class="default">$HTTP_POST_VARS</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$_ENV&nbsp; &nbsp; </span><span class="keyword">= &amp;</span><span class="default">$HTTP_ENV_VARS</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$_SERVER&nbsp; </span><span class="keyword">= &amp;</span><span class="default">$HTTP_SERVER_VARS</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$_COOKIE&nbsp; </span><span class="keyword">= &amp;</span><span class="default">$HTTP_COOKIE_VARS</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">$_REQUEST </span><span class="keyword">= </span><span class="default">array_merge</span><span class="keyword">(</span><span class="default">$_GET</span><span class="keyword">, </span><span class="default">$_POST</span><span class="keyword">, </span><span class="default">$_COOKIE</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Include that before everything else in your script and it will fix the flaw.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52304""></a>
  <div class="note">
   <strong class="user">myfirstname dot barros at gmail dot com</strong>
   <a href="#52304" class="date">27-Apr-2005 04:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
vars in $_REQUEST are *not* a reference to the respective $_POST and $_GET and $_COOKIE ones.<br />
<br />
Consider:<br />
<a href="http://site.com/index.php?avar=abc" rel="nofollow" target="_blank">http://site.com/index.php?avar=abc</a><br />
<br />
index.php:<br />
<span class="default">&lt;?php<br />
$_GET</span><span class="keyword">[</span><span class="string">'avar'</span><span class="keyword">] = </span><span class="string">'b'</span><span class="keyword">;<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$_GET</span><span class="keyword">); print(</span><span class="string">'&lt;br&gt;'</span><span class="keyword">);<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$_REQUEST</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
output:<br />
Array ( [avar] =&gt; 'b' )<br />
Array ( [avar] =&gt; 'abc' )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52283""></a>
  <div class="note">
   <strong class="user">sendoshin[at]noodleroni[dot]com</strong>
   <a href="#52283" class="date">27-Apr-2005 02:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is one way to safely execute PHP code files without running the risk of compromising your own code.&nbsp; A prior note pointed out that the code being evaluated would still have access to globals using the global keyword.&nbsp; While this is a valid point, there's one other approach to be looked at - one which actually gives you much more ability than just unsetting some variable references.&nbsp; It's known as code parsing.<br />
<br />
The specifics would be different and much more complex in a deployed site, but here's an extremely strip-down example of how to restrict access to global variables:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">while (</span><span class="default">$x </span><span class="keyword">= </span><span class="default">stristr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="string">"global"</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$temp </span><span class="keyword">= </span><span class="default">substr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">, </span><span class="default">$x</span><span class="keyword">-</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$temp </span><span class="keyword">.= </span><span class="default">substr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="default">stristr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="string">";"</span><span class="keyword">, </span><span class="default">$x</span><span class="keyword">) + </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$code_to_eval </span><span class="keyword">= </span><span class="default">$temp</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ret_val </span><span class="keyword">= eval (</span><span class="default">$code_to_eval</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Of course, that's just a rudimentary example, and a deployment version would have much more checking involved, but parsing the file before you eval it lets you remove any code you don't want to let run, thus making it as safe as your parsing rules.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51757""></a>
  <div class="note">
   <strong class="user">lanny at freemail dot hu</strong>
   <a href="#51757" class="date">10-Apr-2005 11:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
From PHP 5.0.3 long predefined arrays such HTTP_GET_VARS got disabled by default. For backward compatibility you can enable them in php.ini:<br />
<br />
register_long_arrays = On<br />
<br />
I sugget a big WARNING up there like that one with the resister_globals. <br />
<br />
Anyway.. I cannot understand why they do such tings all the time.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50044""></a>
  <div class="note">
   
   <a href="#50044" class="date">16-Feb-2005 01:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
php.net uses this<br />
<br />
// Backward compatible array creation. After this point, the<br />
// PHP 4.1.0+ arrays can be used to access variables coming<br />
// from outside PHP. But it should be noted that these variables<br />
// are not necessarily superglobals, so they need to be global-ed!<br />
if (!isset($_SERVER))<br />
{<br />
&nbsp;&nbsp;&nbsp; $_GET&nbsp; &nbsp;&nbsp; = &amp;$HTTP_GET_VARS;<br />
&nbsp;&nbsp;&nbsp; $_POST&nbsp; &nbsp; = &amp;$HTTP_POST_VARS;<br />
&nbsp;&nbsp;&nbsp; $_ENV&nbsp; &nbsp;&nbsp; = &amp;$HTTP_ENV_VARS;<br />
&nbsp;&nbsp;&nbsp; $_SERVER&nbsp; = &amp;$HTTP_SERVER_VARS;<br />
&nbsp;&nbsp;&nbsp; $_COOKIE&nbsp; = &amp;$HTTP_COOKIE_VARS;<br />
&nbsp;&nbsp;&nbsp; $_REQUEST = array_merge($_GET, $_POST, $_COOKIE);<br />
}<br />
<br />
$PHP_SELF = $_SERVER['PHP_SELF'];</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43228""></a>
  <div class="note">
   <strong class="user">kasey at cornerspeed dowt com</strong>
   <a href="#43228" class="date">15-Jun-2004 02:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have a few points to note to (debabratak at softhome dot net).&nbsp; Firstly, extracting all your variables from the global variable arrays is rather cumbersome and possibly unsafe.&nbsp; This causes longer run times, and wastes more memory.&nbsp; Then, your script is starting the session before it parses the superglobals.&nbsp; Bad things can happen because of this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// user sent a GET header with key = secret_access, val = true, so<br />
<br />
</span><span class="keyword">echo </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: true<br />
</span><span class="keyword">echo </span><span class="default">$secret_access</span><span class="keyword">; </span><span class="comment">// output:<br />
<br />
</span><span class="default">session_start</span><span class="keyword">();<br />
<br />
</span><span class="comment">// in previous logic, you set session variable $secret_access = false<br />
<br />
</span><span class="keyword">echo </span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: false<br />
</span><span class="keyword">echo </span><span class="default">$secret_access</span><span class="keyword">; </span><span class="comment">// output: false<br />
<br />
</span><span class="default">extract_globals</span><span class="keyword">();&nbsp; </span><span class="comment">// Globals put into "normal" variables<br />
<br />
</span><span class="keyword">echo </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: true<br />
</span><span class="keyword">echo </span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: false<br />
</span><span class="keyword">echo </span><span class="default">$secret_access</span><span class="keyword">; </span><span class="comment">// output: true<br />
<br />
// VARIABLES ARE COMPROMISED!<br />
// DO NOT USE $secret_access !<br />
// USE $_SESSION["secret_access"] instead !!!<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Secondly, I would like to point out the fact that all $_POST, $_GET, and $_COOKIE variables are intrinsically unsafe anyway.&nbsp; Users can create their own scripts in the language of their choosing (PHP, ASP, JSP, etc.) that generate those headers to send to your PHP program via socket connections.&nbsp; PHP cannot determine that these headers are any less valid than the ones sent by a web browser, so it parses them and places them in the $_POST, $_GET, or $_COOKIE variables.<br />
<br />
The best practice is to use $_SESSION variables to validate the user before making any decisions based on form data.&nbsp; e.g.:<br />
<br />
<span class="default">&lt;?php<br />
session_start</span><span class="keyword">();<br />
if (isset(</span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"valid"</span><span class="keyword">]))<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// all your program decisions and database interactions can go here<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (isset(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"button_name"</span><span class="keyword">]))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; ...<br />
}<br />
elseif (isset(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"submit_login"</span><span class="keyword">]))<br />
{<br />
&nbsp;&nbsp;&nbsp; if ((</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"username"</span><span class="keyword">] == </span><span class="string">"foo"</span><span class="keyword">) AND (</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"password"</span><span class="keyword">] == </span><span class="string">"bar"</span><span class="keyword">))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"valid"</span><span class="keyword">] = </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">session_unset</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">session_destroy</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$error_msg </span><span class="keyword">= </span><span class="string">"Invalid username or password"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result_page </span><span class="keyword">= </span><span class="string">"login.php"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
elseif (isset(</span><span class="default">$logoff</span><span class="keyword">))<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_unset</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_destroy</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$success_msg </span><span class="keyword">= </span><span class="string">"You have logged off successfully"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$result_page </span><span class="keyword">= </span><span class="string">"login.php"</span><span class="keyword">;<br />
}<br />
else<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_unset</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_destroy</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$result_page </span><span class="keyword">= </span><span class="string">"login.php"</span><span class="keyword">;<br />
}<br />
require (</span><span class="default">$result_page</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Session variables are orders of magnitude harder to compromise than POST, GET, and COOKIE data, since the server keeps track of session id's, and the session id is unique to each client and somewhat randomly generated.&nbsp; If security is an ultimate concern, then you need to use SSL in case your traffic can be sniffed (since the session cookie is passed plain text to the client).<br />
<br />
In summary, extracting out all the superglobals to normal variable names is not a good idea for reasons of security and ambiguity, not to mention wasted CPU cycles.&nbsp; For private applications (ones that you don't want just anyone to be able to access), the only ways you can prevent malicious access is to 1) use sessions to ensure that the user is valid (for that page), and 2) use SSL-encryption to prevent session-hijacking.<br />
<br />
Kasey<br />
<br />
in reply to:<br />
--------------------------------------------------------------<br />
&nbsp;debabratak at softhome dot net<br />
14-Mar-2003 12:59<br />
After having register_globals = off, I am using the following piece of code to get all the variables created for me. I have put this code in a separate file and just make it require_once() on top of every page.<br />
<br />
session_start();<br />
$ArrayList = array("_GET", "_POST", "_SESSION", "_COOKIE", "_SERVER");<br />
foreach($ArrayList as $gblArray)<br />
{<br />
&nbsp;&nbsp; $keys = array_keys($$gblArray);<br />
&nbsp;&nbsp; foreach($keys as $key)<br />
&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; $$key = trim(${$gblArray}[$key]);<br />
&nbsp;&nbsp; }<br />
}<br />
<br />
This pulls out all the possible variables for me, including the predefined variables, so I can keep coding the old style. Note that, this code does not handle the $_FILE.<br />
<br />
Hope this helps someone.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42270""></a>
  <div class="note">
   <strong class="user">bryan at nolifeline dot com</strong>
   <a href="#42270" class="date">10-May-2004 09:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
to marcbender at mail dot com<br />
<br />
unset the globals<br />
<br />
use a preg_replace ( pattern: |\;[^\;]*$i[^\;]*\;|Uis, replacement: ";", where $i is the name of any function/variable you wish to prevent access to.) on the code-to-be-evaled.&nbsp; ideas are "global", "fopen", "mysql_connect", etc.&nbsp; You know, anything that you wouldn't want to give a hyperactive 13 year old access to.<br />
<br />
execute the code.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="41656""></a>
  <div class="note">
   <strong class="user">marcbender_AT_mail_DOT_com</strong>
   <a href="#41656" class="date">18-Apr-2004 11:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
-Security issue-<br />
<br />
In response to lopez at yellowspace,<br />
<br />
You provided a method for executing potentially unsafe code:<br />
<br />
&gt; function safeEval($evalcode) {<br />
&gt;&nbsp; &nbsp; unset($GLOBALS);<br />
&gt;&nbsp; &nbsp; unset($_ENV);<br />
&gt;&nbsp; &nbsp; // unset any other superglobal...<br />
&gt;&nbsp; &nbsp; return eval($evalcode);<br />
&gt; }<br />
<br />
Your method, though clever, won't work.&nbsp; The problem is the way that PHP handles function scope.&nbsp; If $evalcode contains a function declaration, and runs that function, the "unset"s will be effectively useless inside the body of that function.<br />
<br />
Try running the above code with $evalcode set as follows:<br />
<br />
<span class="default">&lt;?php<br />
$evalcode</span><span class="keyword">=</span><span class="string">'f();<br />
function f() {<br />
&nbsp;&nbsp; $GLOBALS["_SERVER"] = "compromised";<br />
}'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Then print $_SERVER and see what you get.<br />
<br />
Another problem is that the "global" directive will always grant access to global variables.&nbsp; Try this one:<br />
<br />
<span class="default">&lt;?php<br />
$evalcode</span><span class="keyword">=</span><span class="string">'global $a;<br />
$a = "compromised";'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
$a will of course be changed at the global level.&nbsp; I don't know if it's supposed to work this way, but on my system (PHP 4.3.4) you can do the same to any superglobal by importing it using "global".<br />
<br />
As far as I can tell, there is NO way to execute potentially unsafe code without a lot of risk.&nbsp; With the sloppy way that PHP deals with function scope etc., there isn't much hope that it ever will be.&nbsp; What we'd need is (at least):<br />
&nbsp; - a way to disable the "global" directive (restrictive eval).<br />
&nbsp; - a way to shut off any write-access to superglobals within untrusted functions.<br />
<br />
The first wouldn't be too hard to implement.&nbsp; The second, on the other hand, is practically impossible IMHO.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="36878""></a>
  <div class="note">
   <strong class="user">mark at pitchpipe dot org</strong>
   <a href="#36878" class="date">26-Oct-2003 07:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had always mistakenly assumed that superglobal $_COOKIE (while preferred) was identical to the outdated $HTTP_COOKIE_VARS.&nbsp; However, if you assign:<br />
<br />
$_COOKIE['destroyWorld'] = "true";<br />
if (isset($HTTP_COOKIE_VARS['destroyWorld'])) {<br />
&nbsp;&nbsp; $temp =&amp; new Armeggedon();<br />
&nbsp;&nbsp; $temp-&gt;pushRedButton();<br />
&nbsp;}<br />
<br />
then the world will be safe forever.&nbsp; Might throw off a newbie, or someone like me who was updating really old code bit-by-bit.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="36167""></a>
  <div class="note">
   <strong class="user">wagner at cesnet dot cz</strong>
   <a href="#36167" class="date">29-Sep-2003 05:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The redirected pages by response codes 301, 302, 303 change the request method always to GET, that's why $HTTP_POST_VARS are lost. It is described in Apache documentation.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35627""></a>
  <div class="note">
   <strong class="user">joker at vip dot hr</strong>
   <a href="#35627" class="date">09-Sep-2003 04:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If anyone of you have a problem with uploading files with globals off here is the solution... just add this to the top of the code:<br />
<br />
reset ($_FILES);<br />
while (list ($key, $val) = each ($_FILES)) {<br />
&nbsp;&nbsp;&nbsp; ${$key}=$_FILES[$key]['tmp_name'];<br />
&nbsp;&nbsp;&nbsp; while (list ($key1, $val1) = each ($val)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ${$key."_".$key1}=$_FILES[$key][$key1];<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
&nbsp;&nbsp; Daniel</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31772""></a>
  <div class="note">
   <strong class="user">alexsp at olywa dot net</strong>
   <a href="#31772" class="date">03-May-2003 04:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For those of us who don't have the luxery of upgrading to the latest version of PHP on all of the servers we use but want to use the same variable names that are used in the latest version for super global arrays here's a snippet of code that will help:<br />
&nbsp;&nbsp;&nbsp; // Makes available those super global arrays that are made available<br />
&nbsp;&nbsp;&nbsp; // in versions of PHP after v4.1.0.<br />
&nbsp;&nbsp;&nbsp; if (isset ($HTTP_SERVER_VARS))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $_SERVER = &amp;$HTTP_SERVER_VARS;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if (isset ($HTTP_GET_VARS))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $_GET = &amp;$HTTP_GET_VARS;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if (isset ($HTTP_POST_VARS))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $_POST = &amp;$HTTP_POST_VARS;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if (isset ($HTTP_COOKIE_VARS))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $_COOKIE = &amp;$HTTP_COOKIE_VARS;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if (isset ($HTTP_POST_FILES))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $_FILES = &amp;$HTTP_POST_FILES;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if (isset ($HTTP_ENV_VARS))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $_ENV = &amp;$HTTP_ENV_VARS;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if (isset ($HTTP_SESSION_VARS))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $_SESSION = &amp;$HTTP_SESSION_VARS;<br />
&nbsp;&nbsp;&nbsp; }<br />
The only downfall to this is that there's no way to make them super global. Chances are, though, if you're using a lot of global arrays in your code you should consider a code redesign!&nbsp; :)&nbsp; Hope this helps.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31724""></a>
  <div class="note">
   
   <a href="#31724" class="date">01-May-2003 06:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reply to destes at ix dot netcom dot com dot nospam:<br />
<br />
It's possible for a HTTP client to spoof HTTP_X_FORWARDED_FOR, and set it to a fake IP number.&nbsp; It's more secure to use this code and log BOTH the ip and the proxy ip.<br />
<br />
if ($_SERVER["HTTP_X_FORWARDED_FOR"]) {<br />
&nbsp;&nbsp; if ($_SERVER["HTTP_CLIENT_IP"]) {<br />
&nbsp;&nbsp;&nbsp; $proxy = $_SERVER["HTTP_CLIENT_IP"];<br />
&nbsp; } else {<br />
&nbsp;&nbsp;&nbsp; $proxy = $_SERVER["REMOTE_ADDR"];<br />
&nbsp; }<br />
&nbsp; $ip = $_SERVER["HTTP_X_FORWARDED_FOR"];<br />
} else {<br />
&nbsp; if ($_SERVER["HTTP_CLIENT_IP"]) {<br />
&nbsp;&nbsp;&nbsp; $ip = $_SERVER["HTTP_CLIENT_IP"];<br />
&nbsp; } else {<br />
&nbsp;&nbsp;&nbsp; $ip = $_SERVER["REMOTE_ADDR"];<br />
&nbsp; }<br />
}<br />
<br />
echo "Your IP $ip&lt;BR&gt;\n";<br />
if (isset($proxy)) {<br />
&nbsp; echo "Your proxy IP is $proxy&lt;BR&gt;\n";<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30678""></a>
  <div class="note">
   <strong class="user">LouisGreen at pljg dot freeserve dot co dot uk</strong>
   <a href="#30678" class="date">25-Mar-2003 07:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems that when you wish to export a varible, you can do it as return $varible, return an array(), or globalise it. If you return something, information for that varible can only travel one way when the script is running, and that is out of the function. <br />
<br />
function fn() {<br />
&nbsp;&nbsp; $varible = "something";<br />
<br />
&nbsp; return $variable;<br />
}<br />
<br />
echo fn();<br />
OR<br />
$newvariable = fn();<br />
<br />
Although if global was used, it creates a pointer to a varible, whether it existed or not, and makes whatever is created in the function linked to that global pointer. So if the pointer was global $varible, and then you set a value to $varible, it would then be accessible in the global scope. But then what if you later on in the script redefine that global to equal something else. This means that whatever is put into the global array, the information that is set in the pointer, can be set at any point (overiden). Here is an example that might make this a little clearer:<br />
<br />
function fn1() {<br />
<br />
&nbsp;&nbsp; global $varible; // Pointer to the global array<br />
&nbsp;&nbsp; $varible = "something";<br />
}<br />
<br />
fn1();<br />
echo $varible; // Prints something<br />
$varible = "12345";<br />
echo $varible; // Prints 12345<br />
<br />
function fn2() {<br />
<br />
&nbsp;&nbsp; global $varible; // Pointer to the global array<br />
&nbsp;&nbsp; echo $varible;<br />
}<br />
<br />
fn2(); // echos $varible which contains "12345"<br />
<br />
Basically when accessing the global array, you can set it refer to something already defined or set it to something, (a pointer) such as varible you plan to create in the function, and later possibly over ride the pointer with something else.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30484""></a>
  <div class="note">
   <strong class="user">Good Liam</strong>
   <a href="#30484" class="date">19-Mar-2003 06:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Warning:<br />
If you use dynamic variables in a local scope, the variable doesn't "know" when it should be a superglobal.&nbsp; An example will help elucidate this:<br />
<br />
function Example($Variable_Name='_POST') {<br />
&nbsp;&nbsp;&nbsp; print_r($$Variable_Name);<br />
} // End Example<br />
<br />
This would print out<br />
<br />
NULL<br />
<br />
To use a dynamic variable to reference a superglobal, you have to declare the value (not the name) as a global:<br />
<br />
function WorkingExample($Variable_Name='_POST') {<br />
&nbsp;&nbsp;&nbsp; global $$Variable_Name;<br />
&nbsp;&nbsp;&nbsp; print_r($$Variable_Name);<br />
} // End WorkingExample()<br />
<br />
This would print out the contents of your $_POST variable.<br />
<br />
This threw me when I first tried it, but it makes sense, in a way.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30278""></a>
  <div class="note">
   <strong class="user">LouisGreen at pljg dot freeserve dot co dot uk</strong>
   <a href="#30278" class="date">12-Mar-2003 11:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you require access to Predefined Variables in different PHP/ servers versions and don't wish to mess about with how you access them, this little snippet of code might help you:<br />
<br />
function fn_http_vars_access() {<br />
<br />
&nbsp;&nbsp; global $GET_VARS, $POST_VARS, $COOKIE_VARS, $SESSION_VARS, $SERVER_VARS, $ENV_VARS;<br />
<br />
&nbsp;&nbsp; $parser_version = phpversion();<br />
<br />
&nbsp;&nbsp; if ($parser_version &lt;= "4.1.0") { <br />
&nbsp;&nbsp; &nbsp;&nbsp; $GET_VARS&nbsp; &nbsp; &nbsp; = $GET_VARS;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $POST_VARS&nbsp; &nbsp;&nbsp; = $POST_VARS;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $COOKIE_VARS&nbsp;&nbsp; = $COOKIE_VARS;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $SESSION_VARS&nbsp; = $HTTP_SESSION_VARS;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $SERVER_VARS&nbsp;&nbsp; = $HTTP_SERVER_VARS;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $ENV_VARS&nbsp; &nbsp; &nbsp; = $HTTP_ENV_VARS;<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; if ($parser_version &gt;= "4.1.0") { <br />
&nbsp;&nbsp; &nbsp;&nbsp; $GET_VARS&nbsp; &nbsp; &nbsp; = $_GET;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $POST_VARS&nbsp; &nbsp;&nbsp; = $_POST;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $COOKIE_VARS&nbsp;&nbsp; = $_COOKIE;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $SESSION_VARS&nbsp; = $_SESSION;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $SERVER_VARS&nbsp;&nbsp; = $_SERVER;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $ENV_VARS&nbsp; &nbsp; &nbsp; = $_ENV;<br />
&nbsp;&nbsp; }<br />
}<br />
<br />
fn_http_vars_access();</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="29386""></a>
  <div class="note">
   
   <a href="#29386" class="date">12-Feb-2003 07:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
i just noticed that the free web server i'm running my scripts on still only knows the deprecated variable names (i.e. it uses $HTTP_POST_VARS instead of $_POST). to make scripts work both on updated servers and servers that are a bit out of date, i now use:<br />
<br />
$variablename=(isset($_POST["variablename"])) ? $_POST["variablename"] : $HTTP_POST_VARS["variablename"];</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="28614""></a>
  <div class="note">
   <strong class="user">lopez dot on dot the dot lists at yellowspace dot net</strong>
   <a href="#28614" class="date">18-Jan-2003 03:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
- Security Issue and workaround - <br />
If You use "eval()" to execute code stored in a database or elsewhere, you might find this tip useful.<br />
<br />
Issue:<br />
By default, all superglobals are known in every function. <br />
Thus, if you eval database- or dynamically generated code (let's call it "potentially unsafe code"), it can use _all_ the values stored in _any_ superglobal. <br />
<br />
Workaround:<br />
Whenever you want to hide superglobals from use in evaluated code, wrap that eval() in an own function within which you unset() all the superglobals. The superglobals are not deleted by php in all scopes - just within that function. eg:<br />
<br />
function safeEval($evalcode) {<br />
&nbsp;&nbsp;&nbsp; unset($GLOBALS);<br />
&nbsp;&nbsp;&nbsp; unset($_ENV);<br />
&nbsp;&nbsp;&nbsp; // unset any other superglobal...<br />
&nbsp;&nbsp;&nbsp; return eval($evalcode);<br />
}<br />
<br />
(This example assumes that the eval returns something with 'return')<br />
<br />
In addition, by defining such a function outside classes, in the global scope, you'll make sure as well that the evaluated ('unsafe') code doesn't have access to the object variables ($this-&gt; ...).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="23063""></a>
  <div class="note">
   
   <a href="#23063" class="date">08-Jul-2002 10:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Wouldn't it be great if there was a variable called $_SERVER["PATH_USERHOME"]. Here is how to set it yourself:<br />
<br />
$path_fs = split ("/", ltrim ($_SERVER["PATH_TRANSLATED"], "/"));<br />
$path_fs_rev = array_reverse ($path_fs);<br />
<br />
$path_http = split ("/", ltrim ($_SERVER["PHP_SELF"], "/"));<br />
$path_http_rev = array_reverse ($path_http);<br />
<br />
$num_same = 0;<br />
while ($path_fs_rev[$num_same] == $path_http_rev[$num_same]) {<br />
&nbsp;&nbsp;&nbsp; $num_same++;<br />
}<br />
<br />
$path_userhome = array ();<br />
$numdirs_userhome = sizeof ($path_http) - $num_same;<br />
echo $numdirs_userhome;<br />
<br />
for ($i = 0; $i &lt; $numdirs_userhome; $i++) {<br />
&nbsp;&nbsp;&nbsp; array_push ($path_userhome, $path_http[$i]);<br />
}<br />
<br />
$_SERVER["PATH_USERHOME"] = "/" . implode ("/", $path_userhome) . "/";<br />
<br />
print_r ($_SERVER["PATH_USERHOME"]);<br />
<br />
;) Happy programming,<br />
<br />
Peder</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="21952""></a>
  <div class="note">
   <strong class="user">juancri at TAGnet dot org</strong>
   <a href="#21952" class="date">01-Jun-2002 05:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you try this:<br />
<br />
&lt;FORM action="hola"&gt;<br />
&nbsp; ....<br />
&lt;/FORM&gt;<br />
<br />
and hola is a directory, you have to write the final slash (/) because the page is redirected from hola to hola/ and you'll lost the POST variables.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="14246""></a>
  <div class="note">
   <strong class="user">rick@independence,netI</strong>
   <a href="#14246" class="date">24-Jul-2001 03:13</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It should be noted that $HTTP_RAW_POST_DATA only exists if the encoding type of the data is -not- the default of application/x-www.form-urlencoded, and so, to accessing raw post data from an HTTP form requires setting enctype= in your HTML.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="9776""></a>
  <div class="note">
   <strong class="user">mike at dbeat dot com</strong>
   <a href="#9776" class="date">23-Nov-2000 03:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you're running PHP as a shell script, and you want to use the argv and argc arrays to get command-line arguments, make sure you have register_argc_argv&nbsp; =&nbsp; on.&nbsp; If you're using the 'optimized' php.ini, this defaults to off.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
