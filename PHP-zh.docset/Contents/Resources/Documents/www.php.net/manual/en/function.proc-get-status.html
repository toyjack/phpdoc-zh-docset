<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>获取由 proc_open 函数打开的进程的信息</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.proc-close.html">? proc_close</a></li>
      <li style="float: right;"><a href="function.proc-nice.html">proc_nice ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.exec.html">程序执行函数</a></li>
    <li>获取由 proc_open 函数打开的进程的信息</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.proc-get-status" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">proc_get_status</h1>
  <p class="verinfo">(PHP 5, PHP 7)</p><p class="refpurpose"><span class="refname">proc_get_status</span> &mdash; <span class="dc-title">获取由 <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span> 函数打开的进程的信息</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.proc-get-status-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>proc_get_status</strong></span>
    ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$process</code></span>
   ) : <span class="type">array</span></div>

  <p class="para rdfs-comment">
   <span class="function"><strong>proc_get_status()</strong></span> 函数可以获取由
   <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span> 函数打开的进程的信息。
  </p>
 </div>

 
 <div class="refsect1 parameters" id="refsect1-function.proc-get-status-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">process</code></dt>

     <dd>

      <p class="para">
       要检查的由 <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span> 打开的进程 <span class="type"><a href="language.types.resource.html" class="type resource">resource</a></span>。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.proc-get-status-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
    如果调用成功，则返回一个包含了进程信息的 <span class="type"><a href="language.types.array.html" class="type array">array</a></span>，如果发生错误，返回 <strong><code>FALSE</code></strong>。
    返回的数组包含下列元素：
  </p>
  <p class="para">
  <table class="doctable informaltable">
   
    <thead>
     <tr><th>元素</th><th>类型</th><th>描述</th></tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td>command</td>
      <td><span class="type"><a href="language.types.string.html" class="type string">string</a></span></td>
      <td>
       传入 <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span> 函数的命令行字符串。
      </td>
     </tr>

     <tr>
      <td>pid</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>进程 ID</td>
     </tr>

     <tr>
      <td>running</td>
      <td><span class="type"><a href="language.types.boolean.html" class="type bool">bool</a></span></td>
      <td>
       <strong><code>TRUE</code></strong> 表示进程还在运行中， <strong><code>FALSE</code></strong> 表示进程已经终止
      </td>
     </tr>

     <tr>
      <td>signaled</td>
      <td><span class="type"><a href="language.types.boolean.html" class="type bool">bool</a></span></td>
      <td>
       <strong><code>TRUE</code></strong> 表示子进程被未捕获的信号所终止。
       在 Windows 平台永远为 <strong><code>FALSE</code></strong>。
      </td>
     </tr>

     <tr>
      <td>stopped</td>
      <td><span class="type"><a href="language.types.boolean.html" class="type bool">bool</a></span></td>
      <td>
        <strong><code>TRUE</code></strong> 表示子进程被信号停止。
        在 Windows 平台永远为 <strong><code>FALSE</code></strong>。
      </td>
     </tr>

     <tr>
      <td>exitcode</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>
        进程的退出码（仅在 <em>running</em> 为 <strong><code>FALSE</code></strong> 时有意义）。
        仅在第一次调用此函数时会返回实际的值，
        后续的调用将返回 <em>-1</em>。
      </td>
     </tr>

     <tr>
      <td>termsig</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>
        导致子进程终止执行的信号值
        （仅在 <em>signaled</em> 为 <strong><code>TRUE</code></strong> 时有意义）。
      </td>
     </tr>

     <tr>
      <td>stopsig</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>
        导致子进程停止执行的信号值
        （仅在 <em>stopped</em> 为 <strong><code>TRUE</code></strong> 时有意义）。
      </td>
     </tr>

    </tbody>
   
  </table>

  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.proc-get-status-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.proc-open.html" class="function" rel="rdfs-seeAlso">proc_open()</a> - 执行一个命令，并且打开用来输入/输出的文件指针。</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="103189""></a>
  <div class="note">
   <strong class="user">Lachlan Mulcahy</strong>
   <a href="#103189" class="date">30-Mar-2011 11:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is worth noting that proc_get_status will continue to indicate the process that you spawned is running (because it is!) until that process has been able to write everything it wants to write to the STDOUT and STDERR streams.<br />
<br />
PHP seems to use a buffer for this and so the spawned process can can get it's write calls to return immediately. <br />
<br />
However, once this buffer is full the write call will block until you read out some of the information from the stream/pipe.<br />
<br />
This can manifest itself in many ways but generally the called process will still be running, but just not doing anything as it is blocking on being able to write more to STDERR or STDOUT -- whichever stream buffer is full.<br />
<br />
To work around this you should include in your loop of checking proc_get_status' running element a "stream_get_contents" on the relevant pipes.<br />
<br />
I generally use stream_set_blocking($pipies[2], 0) kind of calls to make sure that the stream_get_contents call will not block if there is no data in the stream.<br />
<br />
This one had me stumped for a while, so hopefully it helps someone!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93382""></a>
  <div class="note">
   <strong class="user">Mark Seecof</strong>
   <a href="#93382" class="date">06-Sep-2009 08:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On Unix/Linux, if you change the command line you pass to proc_open() just slightly then proc_get_status() will give you the actual process-id (pid) of your child.<br />
<br />
Suppose you wish to run the external command /usr/bin/compress to create a BSD foo.Z file.&nbsp; Rather than proc_open("/usr/bin/compress /tmp/foo",...) you may invoke proc_open("exec /usr/bin/compress /tmp/foo",...) and then proc_get_status()['pid'] will be the actual pid of /usr/bin/compress.<br />
<br />
Why?&nbsp; Because the way proc_open() actually works on Unix/Linux is by starting "/bin/sh -c usercmd userargs...", e.g., "/bin/sh -c /usr/bin/compress /tmp/foo".[Note 1]&nbsp; That means normally your command is the child of the shell, so the pid you retrieve with proc_get_status() is the pid of the shell (PHP's child), and you have to fumble around trying to find the pid of your command (PHP's grandchild).&nbsp; But if you put "exec" in front of your command, you tell the shell to *replace itself* with your command without starting another process (technically, to exec your command without forking first).&nbsp; That means your command will inherit the pid of the shell, which is the pid that proc_get_status() returns.<br />
<br />
So if you would like the actual pid of the process running your command, just prepend "exec " to&nbsp; your proc_open() command argument then retrieve the pid using proc_get_status().<br />
<br />
This also makes proc_terminate() and proc_close() work more like you might prefer, since they will affect the actual process running your command (which will be a child process rather than a grandchild process).<br />
<br />
[Note 1] My guess is that the PHP developers want the shell to expand wildcards in path/filenames.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92145""></a>
  <div class="note">
   <strong class="user">php dot net at crazedsanity dot com</strong>
   <a href="#92145" class="date">10-Jul-2009 08:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For clarification, the "exitcode" is only valid the FIRST TIME IT IS CALLED after the process exits.<br />
<br />
If you have a method that polls a spawned process for its status, you *MUST* have that same method capture the exitcode: if the method is called a second time (after realizing the pid is dead) and it hasn't cached that exitcode, it will receive the -1 mentioned.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87894""></a>
  <div class="note">
   <strong class="user">lytithwyn at gmail dot com</strong>
   <a href="#87894" class="date">29-Dec-2008 06:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have had lots of problems in the past bit trying to kill external commands run by proc_open.
<br />

<br />
Others have suggested using ps to find the children of the pid returned by proc_get_status, but on my system this doesn't work.&nbsp; I'm using php-5.2.5 and apache-2.0.59 on linux kernel 2.6.21, and the processes I start with proc_open end up being owned by init (pid 1), not by the pid returned by proc_get_status.
<br />

<br />
I did notice, however, that the pid's of the processes were always above and very close to the proc_get_status pid.&nbsp; Using that information, I wrote a little function that takes the name of a command, the starting pid at which to search (which would be the proc_get_status pid), and optionally a search limit as arguments.&nbsp; It will use ps to list processes owned by apache (you may have to change this user name for your system), and search for the command specified.&nbsp; The limit tells how far above the starting pid to search.&nbsp; This will help if the command may have already exited, and you don't want to kill a process from a different session than the one you're working with.
<br />

<br />
Here's the code:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">findCommandPID</span><span class="keyword">(</span><span class="default">$command</span><span class="keyword">, </span><span class="default">$startpid</span><span class="keyword">, </span><span class="default">$limit </span><span class="keyword">= </span><span class="default">3</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ps </span><span class="keyword">= `</span><span class="string">ps -u apache --sort=pid -o comm= -o pid=</span><span class="keyword">`;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ps_lines </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">"\n"</span><span class="keyword">, </span><span class="default">$ps</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pattern </span><span class="keyword">= </span><span class="string">"/(\S{1,})(\s{1,})(\d{1,})/"</span><span class="keyword">;
<br />

<br />
&nbsp;&nbsp;&nbsp; foreach(</span><span class="default">$ps_lines </span><span class="keyword">as </span><span class="default">$line</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="default">$line</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">))
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//this limits us to finding the command within $limit pid's of the parent;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //eg, if ppid = 245, limit = 3, we won't search past 248 
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">3</span><span class="keyword">] &gt; </span><span class="default">$startpid </span><span class="keyword">+ </span><span class="default">$limit</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//try to match a ps line where the command matches our search 
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //at a higher pid than our parent
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] == </span><span class="default">$command </span><span class="keyword">&amp;&amp; </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">3</span><span class="keyword">] &gt; </span><span class="default">$startpid</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">3</span><span class="keyword">];
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; }
<br />

<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84338""></a>
  <div class="note">
   <strong class="user">webmaster at rouen dot fr</strong>
   <a href="#84338" class="date">09-Jul-2008 01:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The following function takes an array of shell commands and executes them. It is able to execute up to $nb_max_process at the same time. As soon as one process is terminated, another one is executed. Quite useful if you want to batch process commands on a multi-processor or multi-core environment.<br />
<br />
The example below tries to convert to PNG a list of SVG files submitted on the command line (using Inkscape).<br />
<br />
(it's quick and dirty but works very well for me)<br />
<br />
#!/usr/bin/php<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">pool_execute</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">,</span><span class="default">$nb_max_process</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$pool</span><span class="keyword">=array();<br />
&nbsp; for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$nb_max_process</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]=</span><span class="default">FALSE</span><span class="keyword">;<br />
&nbsp; }<br />
<br />
&nbsp; while(</span><span class="default">count</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">)&gt;</span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$commande</span><span class="keyword">=</span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$commande_lancee</span><span class="keyword">=</span><span class="default">FALSE</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; while(</span><span class="default">$commande_lancee</span><span class="keyword">==</span><span class="default">FALSE</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">usleep</span><span class="keyword">(</span><span class="default">50000</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$nb_max_process </span><span class="keyword">and </span><span class="default">$commande_lancee</span><span class="keyword">==</span><span class="default">FALSE</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]===</span><span class="default">FALSE</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]=</span><span class="default">proc_open</span><span class="keyword">(</span><span class="default">$commande</span><span class="keyword">,array(),</span><span class="default">$foo</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$commande_lancee</span><span class="keyword">=</span><span class="default">TRUE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$etat</span><span class="keyword">=</span><span class="default">proc_get_status</span><span class="keyword">(</span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$etat</span><span class="keyword">[</span><span class="string">'running'</span><span class="keyword">]==</span><span class="default">FALSE</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">proc_close</span><span class="keyword">(</span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]=</span><span class="default">proc_open</span><span class="keyword">(</span><span class="default">$commande</span><span class="keyword">,array(),</span><span class="default">$foo</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$commande_lancee</span><span class="keyword">=</span><span class="default">TRUE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
}<br />
<br />
</span><span class="default">$fichiers</span><span class="keyword">=</span><span class="default">$argv</span><span class="keyword">;<br />
</span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$fichiers</span><span class="keyword">);<br />
</span><span class="default">$commandes</span><span class="keyword">=array();<br />
foreach(</span><span class="default">$fichiers </span><span class="keyword">as </span><span class="default">$fichier</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$entree</span><span class="keyword">=</span><span class="default">$fichier</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$sortie</span><span class="keyword">=</span><span class="default">basename</span><span class="keyword">(</span><span class="default">$fichier</span><span class="keyword">,</span><span class="string">'.svg'</span><span class="keyword">).</span><span class="string">".png"</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$commandes</span><span class="keyword">[]=</span><span class="string">'inkscape --file='</span><span class="keyword">.</span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$entree</span><span class="keyword">).</span><span class="string">' --export-area-canvas --export-png='</span><span class="keyword">.</span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$sortie</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="default">pool_execute</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">,</span><span class="default">4</span><span class="keyword">);</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83628""></a>
  <div class="note">
   <strong class="user">strrev xc.noxeh@ellij</strong>
   <a href="#83628" class="date">05-Jun-2008 01:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can NOT rely on pid+1.<br />
You could prefix exec to the command string, this will replace the /bin/sh script with the real thing you want to exec (use only if you don't do 'scary things' like pipes, output redirection, multiple commands, however if you know how they work, go ahead).<br />
If you prefix exec, the /bin/sh process will only start your process, and the PID will be the same.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75725""></a>
  <div class="note">
   <strong class="user">damien at cyg dot net</strong>
   <a href="#75725" class="date">13-Jun-2007 06:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Alternatively, if you're calling a subsequent php script using proc_open, you can have that process echo its own actual PID in the output.<br />
Also, if you go through the /proc filesystem on linux, you can read through /proc/12345 where 12345 is the pid returned by proc_get_status (the pid of the /bin/sh instance) and it will list its child processes within.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74329""></a>
  <div class="note">
   <strong class="user">andy dot shellam at mailnetwork dot co dot uk</strong>
   <a href="#74329" class="date">05-Apr-2007 05:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Further to my previous note, I've found out the PID returned is the PID of the shell (/bin/sh) that then runs the actual command requested.<br />
<br />
I've raised this as bug #41003.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74328""></a>
  <div class="note">
   <strong class="user">andy dot shellam at mailnetwork dot co dot uk</strong>
   <a href="#74328" class="date">05-Apr-2007 04:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To the poster above, same here on FreeBSD 6.1, PHP 5.2.1.<br />
<br />
To get the correct PID to use for posix_kill I have to add 1 to the PID returned from proc_get_status.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
