<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>引用的解释</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.attributes.classes.html">? 声明注解类</a></li>
      <li style="float: right;"><a href="language.references.whatare.html">引用是什么 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="langref.html">语言参考</a></li>
    <li>引用的解释</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.references" class="chapter">
 <h1>引用的解释</h1>
<h2>Table of Contents</h2><ul class="chunklist chunklist_chapter"><li><a href="language.references.whatare.html">引用是什么</a></li><li><a href="language.references.whatdo.html">引用做什么</a></li><li><a href="language.references.arent.html">引用不是什么</a></li><li><a href="language.references.pass.html">引用传递</a></li><li><a href="language.references.return.html">引用返回</a></li><li><a href="language.references.unset.html">取消引用</a></li><li><a href="language.references.spot.html">引用定位</a></li></ul>


 

 

 

 

 

 

 

</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="122814""></a>
  <div class="note">
   <strong class="user">dallgoot</strong>
   <a href="#122814" class="date">09-Jun-2018 04:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
After some headaches, here is a function to check if, between 2 variables $a,$b check if one is a reference to the other.<br />
It means they "point" to the same value.<br />
Tested on :<br />
PHP 7.2.2 (cli) (built: Jan 31 2018 19:31:17) ( ZTS MSVC15 (Visual C++ 2017) x64 )<br />
Hope that helps...<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">are_references</span><span class="keyword">(&amp;</span><span class="default">$a</span><span class="keyword">, &amp;</span><span class="default">$b</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$mem </span><span class="keyword">= </span><span class="default">$a</span><span class="keyword">;&nbsp; &nbsp;&nbsp; </span><span class="comment">//memorize<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">uniqid </span><span class="keyword">(</span><span class="string">"REFERENCE???"</span><span class="keyword">, </span><span class="default">true </span><span class="keyword">); </span><span class="comment">//change $a<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$same </span><span class="keyword">= </span><span class="default">$a </span><span class="keyword">=== </span><span class="default">$b</span><span class="keyword">; </span><span class="comment">//compare<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">$mem</span><span class="keyword">; </span><span class="comment">//restore $a<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">$same</span><span class="keyword">;<br />
}<br />
echo </span><span class="string">"***distinct vars AND distinct values\n"</span><span class="keyword">;<br />
</span><span class="default">$a </span><span class="keyword">= </span><span class="string">"toto"</span><span class="keyword">;<br />
</span><span class="default">$b </span><span class="keyword">= </span><span class="string">"tata"</span><span class="keyword">;<br />
<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">, </span><span class="default">are_references</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">));<br />
echo </span><span class="string">"verify original values: </span><span class="default">$a</span><span class="string">, </span><span class="default">$b</span><span class="string">\n"</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"***distinct vars BUT SAME values\n"</span><span class="keyword">;<br />
</span><span class="default">$a </span><span class="keyword">= </span><span class="string">"toto"</span><span class="keyword">;<br />
</span><span class="default">$b </span><span class="keyword">= </span><span class="string">"toto"</span><span class="keyword">;<br />
<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">, </span><span class="default">are_references</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">));<br />
echo </span><span class="string">"verify original values: </span><span class="default">$a</span><span class="string">, </span><span class="default">$b</span><span class="string">\n"</span><span class="keyword">;<br />
<br />
echo </span><span class="string">'*** $b is a reference of $a'</span><span class="keyword">.</span><span class="string">"\n"</span><span class="keyword">;<br />
</span><span class="default">$a </span><span class="keyword">= </span><span class="string">"titi"</span><span class="keyword">;<br />
</span><span class="default">$b </span><span class="keyword">= &amp;</span><span class="default">$a</span><span class="keyword">;<br />
<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">, </span><span class="default">are_references</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">));<br />
echo </span><span class="string">"verify original values: </span><span class="default">$a</span><span class="string">, </span><span class="default">$b</span><span class="string">\n"</span><span class="keyword">;<br />
<br />
echo </span><span class="string">'*** $a is a reference of $b'</span><span class="keyword">.</span><span class="string">"\n"</span><span class="keyword">;<br />
</span><span class="default">$b </span><span class="keyword">= </span><span class="string">"titi"</span><span class="keyword">;<br />
</span><span class="default">$a </span><span class="keyword">= &amp;</span><span class="default">$b</span><span class="keyword">;<br />
<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">, </span><span class="default">are_references</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">));<br />
echo </span><span class="string">"verify original values: </span><span class="default">$a</span><span class="string">, </span><span class="default">$b</span><span class="string">\n"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span>Result:<br />
***distinct vars AND distinct values<br />
string(4) "toto"<br />
string(4) "tata"<br />
bool(false)<br />
verify original values: toto, tata<br />
***distinct vars BUT SAME values<br />
string(4) "toto"<br />
string(4) "toto"<br />
bool(false)<br />
verify original values: toto, toto<br />
*** $b is a reference of $a<br />
string(4) "titi"<br />
string(4) "titi"<br />
bool(true)<br />
verify original values: titi, titi<br />
*** $a is a reference of $b<br />
string(4) "titi"<br />
string(4) "titi"<br />
bool(true)<br />
verify original values: titi, titi</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="119048""></a>
  <div class="note">
   <strong class="user">jszoja at gmail dot com</strong>
   <a href="#119048" class="date">23-Mar-2016 11:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be aware of a reference to another reference. It is probably bad practice to even do that.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">Obj1 </span><span class="keyword">{ public </span><span class="default">$name </span><span class="keyword">= </span><span class="string">'Obj1'</span><span class="keyword">; }<br />
&nbsp;&nbsp;&nbsp; class </span><span class="default">Obj2 </span><span class="keyword">{ public </span><span class="default">$name </span><span class="keyword">= </span><span class="string">'Obj2'</span><span class="keyword">; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$objects </span><span class="keyword">= [];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$toLoad </span><span class="keyword">= [ </span><span class="string">'Obj1'</span><span class="keyword">, </span><span class="string">'Obj2' </span><span class="keyword">];<br />
<br />
&nbsp;&nbsp;&nbsp; foreach( </span><span class="default">$toLoad </span><span class="keyword">as </span><span class="default">$i </span><span class="keyword">=&gt; </span><span class="default">$obj </span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ref </span><span class="keyword">= new </span><span class="default">$obj</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$objects</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] =&amp; </span><span class="default">$ref</span><span class="keyword">; </span><span class="comment">// a reference to a reference<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // $objects[$i] = $ref; // that would work<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$objects</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]-&gt;</span><span class="default">name</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// outputs 'Obj2' !<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118500""></a>
  <div class="note">
   <strong class="user">Someone</strong>
   <a href="#118500" class="date">16-Dec-2015 09:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another example of something to watch out for when using references with arrays.&nbsp; It seems that even an usused reference to an array cell modifies the *source* of the reference.&nbsp; Strange behavior for an assignment statement (is this why I've seen it written as an =&amp; operator?&nbsp; - although this doesn't happen with regular variables).<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $array1 </span><span class="keyword">= array(</span><span class="default">1</span><span class="keyword">,</span><span class="default">2</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$x </span><span class="keyword">= &amp;</span><span class="default">$array1</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];&nbsp;&nbsp; </span><span class="comment">// Unused reference<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2 </span><span class="keyword">= </span><span class="default">$array1</span><span class="keyword">;&nbsp; </span><span class="comment">// reference now also applies to $array2 !<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]=</span><span class="default">22</span><span class="keyword">;&nbsp; &nbsp; &nbsp; </span><span class="comment">// (changing [0] will not affect $array1)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$array1</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Produces:<br />
&nbsp;&nbsp;&nbsp; Array<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; 1<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 22&nbsp; &nbsp; // var_dump() will show the &amp; here<br />
&nbsp;&nbsp;&nbsp; )<br />
<br />
//above was Noted By Dave at SymmetricDesign dot com//<br />
//and below is my opinion to this simple problem. //<br />
<br />
This is an normal referencing problem.<br />
<br />
when you gain an reference to a memory at some variable.<br />
this variable, means "memory itself". (in above example, this would be -&gt;&nbsp; $x = &amp;$array1[1];&nbsp;&nbsp; // Unused reference)<br />
<br />
and you've copied original one($array1) to another one($array2).<br />
and the copy means "paste everything on itself". including references or pointers, etcs. so, when you copied $array1 to $array2, this $array2 has same referencers that original $array1 has. meaning that $x = &amp;$array1[1]&nbsp; = &amp;$array2[1];<br />
and again i said above. this reference means "memory itself".<br />
when you choose to inserting some values to $array2[1], <br />
$x; reference is affected by $array2[1]'s value. because, in allocated memory, $array2[1] is a copy of $array1[1]. this means that $array2[1] = $array1[1], also means &amp;$array2[1] = &amp;$array1[1]&nbsp; as said above. this causes memory's&nbsp; value reallocation on $array1[1]. at this moment. the problem of this topic is cleared by '$x', the memory itself.&nbsp; and this problem was solved by unsetting the '$x'. unsetting this reference triggers memory reallocation of $array2[1]. this closes the reference link between the copied one($array1, which is the original) and copy($array2). this is where that bug(clearly, it's not a bug. it's just a missunderstanding) has triggered by. closing reference link makes two array object to be separated on memory. and this work was done through the unset() function. this topic was posted 7 years ago, but i just want to clarify that it's not a bug.<br />
<br />
if there's some problems in my notes, plz, note that on above.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114620""></a>
  <div class="note">
   <strong class="user">alexander at gamerev dot org</strong>
   <a href="#114620" class="date">13-Mar-2014 02:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Simply put, here's an example of what referencing IS:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $foo&nbsp; </span><span class="keyword">= </span><span class="default">5</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bar </span><span class="keyword">= &amp;</span><span class="default">$foo</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bar</span><span class="keyword">++;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$foo</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
The above example will output the value 6, because $bar references the value of $foo, therefore, when changing $bar's value, you also change $foo's value too.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113187""></a>
  <div class="note">
   <strong class="user">shooo dot xz at gmail dot com</strong>
   <a href="#113187" class="date">10-Sep-2013 12:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi, i've worked a abit on reference stuff.<br />
Here is what i've noticed.<br />
<br />
The problem: Sort mysql result through columns<br />
<br />
$rewrite_self = gt::recombine(array('lang', 'id'), 'value_column', $sql_result);<br />
<br />
public static function recombine($keys, $value, &amp;$arr) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $ref = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $main = &amp;$ref;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach($arr as $data) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach($keys as $key) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!is_array($ref[$data[$key]])) $ref[$data[$key]] = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ref = &amp;$ref[$data[$key]];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ref = $data[$value];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ref = &amp;$main;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $main;<br />
}<br />
<br />
array(2) {<br />
&nbsp; ["pl"]=&gt;<br />
&nbsp; array(2) {<br />
&nbsp;&nbsp;&nbsp; [2]=&gt;<br />
&nbsp;&nbsp;&nbsp; string(4) "value_column_str"<br />
&nbsp;&nbsp;&nbsp; [3]=&gt;<br />
&nbsp;&nbsp;&nbsp; string(4) "value_column_str2"<br />
&nbsp; }<br />
&nbsp; ["en"]=&gt;<br />
&nbsp; array(1) {<br />
&nbsp;&nbsp;&nbsp; [13]=&gt;<br />
&nbsp;&nbsp;&nbsp; string(7) "value_column_str3"<br />
&nbsp; }<br />
}<br />
<br />
Enjoy!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107946""></a>
  <div class="note">
   <strong class="user">sneskid at hotmail dot com</strong>
   <a href="#107946" class="date">15-Mar-2012 10:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is no built in method (yet) to check if two variables are references to the same piece of data, but you can do a "reference sniff" test. This is rarely needed, but can be very useful. The function bellow is a slightly modified version of this technique I saw in a forum regarding this comparison limitation.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">is_ref_to</span><span class="keyword">(&amp;</span><span class="default">$a</span><span class="keyword">, &amp;</span><span class="default">$b</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$r</span><span class="keyword">=(</span><span class="default">$b</span><span class="keyword">===(</span><span class="default">$a</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">))){ </span><span class="default">$r </span><span class="keyword">= (</span><span class="default">$b</span><span class="keyword">===(</span><span class="default">$a</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">)); }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">$t</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$r</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">$varA </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
</span><span class="default">$varB </span><span class="keyword">= </span><span class="default">$varA</span><span class="keyword">;<br />
</span><span class="default">$varC </span><span class="keyword">=&amp;</span><span class="default">$varA</span><span class="keyword">;<br />
<br />
</span><span class="default">var_dump</span><span class="keyword">( </span><span class="default">is_ref_to</span><span class="keyword">(</span><span class="default">$varA</span><span class="keyword">, </span><span class="default">$varB</span><span class="keyword">) ); </span><span class="comment">// bool(false)<br />
</span><span class="default">var_dump</span><span class="keyword">( </span><span class="default">is_ref_to</span><span class="keyword">(</span><span class="default">$varA</span><span class="keyword">, </span><span class="default">$varC</span><span class="keyword">) ); </span><span class="comment">// bool(true)<br />
</span><span class="default">?&gt;<br />
</span><br />
The test above uses a two step process to be 100% generic.<br />
But if you are sure the variables being tested will not be a certain value, example null, then use that value to allow a one step check.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">is_ref_to_1step</span><span class="keyword">(&amp;</span><span class="default">$a</span><span class="keyword">, &amp;</span><span class="default">$b</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$r</span><span class="keyword">=(</span><span class="default">$b</span><span class="keyword">===(</span><span class="default">$a</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">$t</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$r</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100451""></a>
  <div class="note">
   <strong class="user">zoranbankovic at gmail dot com</strong>
   <a href="#100451" class="date">16-Oct-2010 01:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If someone wants to add slashes to multidimensional array directly, can use recursive (pass-by-reference) function like this:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">slashit</span><span class="keyword">(&amp;</span><span class="default">$aray</span><span class="keyword">, </span><span class="default">$db_link</span><span class="keyword">)<br />
{<br />
&nbsp; foreach (</span><span class="default">$aray </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; &amp;</span><span class="default">$value</span><span class="keyword">)<br />
&nbsp;&nbsp; if(</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">)) </span><span class="default">slashit</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">, </span><span class="default">$link</span><span class="keyword">);<br />
&nbsp;&nbsp; else </span><span class="default">$aray</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">mysql_real_escape_string</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">, </span><span class="default">$db_link</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="comment">// Test:<br />
</span><span class="default">$fruits </span><span class="keyword">= array (<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"fruits"&nbsp; </span><span class="keyword">=&gt; array(</span><span class="string">"a" </span><span class="keyword">=&gt; </span><span class="string">"or'ange"</span><span class="keyword">, </span><span class="string">"b" </span><span class="keyword">=&gt; </span><span class="string">"ban'ana"</span><span class="keyword">, </span><span class="string">"c" </span><span class="keyword">=&gt; </span><span class="string">"apple'"</span><span class="keyword">),<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"numbers" </span><span class="keyword">=&gt; array(</span><span class="default">1</span><span class="keyword">, </span><span class="default">2</span><span class="keyword">, </span><span class="default">3</span><span class="keyword">, </span><span class="default">4</span><span class="keyword">, </span><span class="default">5</span><span class="keyword">, </span><span class="default">6</span><span class="keyword">),<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"holes"&nbsp;&nbsp; </span><span class="keyword">=&gt; array(</span><span class="string">"fir'st"</span><span class="keyword">, </span><span class="default">5 </span><span class="keyword">=&gt; </span><span class="string">"sec'ond"</span><span class="keyword">, </span><span class="string">"thir'd"</span><span class="keyword">),<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"odma"&nbsp; &nbsp; </span><span class="keyword">=&gt; </span><span class="string">"jugo'slavija"<br />
</span><span class="keyword">);<br />
<br />
</span><span class="comment">// You have to make link to the database or can use addslashes instead of mysql_real_escape_string and remove $link from function definition<br />
<br />
</span><span class="default">slashit</span><span class="keyword">(</span><span class="default">$fruits</span><span class="keyword">, </span><span class="default">$dbLink</span><span class="keyword">);<br />
echo </span><span class="string">"&lt;pre&gt;"</span><span class="keyword">; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$fruits</span><span class="keyword">); echo </span><span class="string">"&lt;/pre&gt;"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
// Output:<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [fruits] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [a] =&gt; or\'ange<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [b] =&gt; ban\'ana<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [c] =&gt; apple\'<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
&nbsp;&nbsp;&nbsp; [numbers] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; 1<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; 2<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [2] =&gt; 3<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [3] =&gt; 4<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [4] =&gt; 5<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [5] =&gt; 6<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
&nbsp;&nbsp;&nbsp; [holes] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; fir\'st<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [5] =&gt; sec\'ond<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [6] =&gt; thir\'d<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
&nbsp;&nbsp;&nbsp; [odma] =&gt; jugo\'slavija<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99644""></a>
  <div class="note">
   <strong class="user">gnuffo1 at gmail dot com</strong>
   <a href="#99644" class="date">27-Aug-2010 07:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to know the reference count of a particular variable, then here's a function that makes use of debug_zval_dump() to do so:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">refcount</span><span class="keyword">(</span><span class="default">$var</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_start</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">debug_zval_dump</span><span class="keyword">(</span><span class="default">$var</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$dump </span><span class="keyword">= </span><span class="default">ob_get_clean</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$matches </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/refcount\(([0-9]+)/'</span><span class="keyword">, </span><span class="default">$dump</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$count </span><span class="keyword">= </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//3 references are added, including when calling debug_zval_dump()<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">$count </span><span class="keyword">- </span><span class="default">3</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
debug_zval_dump() is a confusing function, as explained in its documentation, as among other things, it adds a reference count when being called as there is a reference within the function. refcount() takes account of these extra references by subtracting them for the return value.<br />
<br />
It's also even more confusing when dealing with variables that have been assigned by reference (=&amp;), either on the right or left side of the assignment, so for that reason, the above function doesn't really work for those sorts of variables. I'd use it more on object instances.<br />
<br />
However, even taking into account that passing a variable to a function adds one to the reference count; which should mean that calling refcount() adds one, and then calling debug_zval_dump() adds another, refcount() seems to have aquired another reference from somewhere; hence subtracting 3 instead of 2 in the return line. Not quite sure where that comes from.<br />
<br />
I've only tested this on 5.3; due to the nature of debug_zval_dump(), the results may be completely different on other versions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95154""></a>
  <div class="note">
   <strong class="user">Youssef Omar</strong>
   <a href="#95154" class="date">15-Dec-2009 12:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is to show the affect of changing property of object A through another object B when you pass object A as a property of another object B.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;</span><span class="comment">// data class to be passed to another class as an object<br />
&nbsp;</span><span class="keyword">class </span><span class="default">A</span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; public </span><span class="default">$info</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">__construct</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">= </span><span class="string">"eeee"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;}<br />
&nbsp;<br />
&nbsp;</span><span class="comment">// B class to change the info in A obj<br />
&nbsp;</span><span class="keyword">class </span><span class="default">B_class</span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; public </span><span class="default">$A_obj</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$A_obj</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">A_obj </span><span class="keyword">=&nbsp; </span><span class="default">$A_obj</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; public function </span><span class="default">change</span><span class="keyword">(</span><span class="default">$newVal</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">= </span><span class="default">$newVal</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;}<br />
<br />
&nbsp;</span><span class="comment">// create data object from the A<br />
&nbsp;</span><span class="default">$A_obj </span><span class="keyword">= new </span><span class="default">A</span><span class="keyword">();<br />
&nbsp;</span><span class="comment">// print the info property<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'A_obj info: ' </span><span class="keyword">. </span><span class="default">$A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
&nbsp;<br />
&nbsp;</span><span class="comment">// create the B object and pass the A_obj we created above<br />
&nbsp;</span><span class="default">$B_obj </span><span class="keyword">= new </span><span class="default">B_class</span><span class="keyword">(</span><span class="default">$A_obj</span><span class="keyword">);<br />
&nbsp;</span><span class="comment">// print the info property through the B object to make sure it has the same value 'eeee'<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'B_obj info: ' </span><span class="keyword">. </span><span class="default">$B_obj</span><span class="keyword">-&gt;</span><span class="default">A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
&nbsp;<br />
&nbsp;</span><span class="comment">// chage the info property<br />
&nbsp;</span><span class="default">$B_obj</span><span class="keyword">-&gt;</span><span class="default">change</span><span class="keyword">(</span><span class="string">'xxxxx'</span><span class="keyword">);<br />
&nbsp;</span><span class="comment">// print the info property through the B object to make sure it changed the value to 'xxxxxx'<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'B_obj info after change: ' </span><span class="keyword">. </span><span class="default">$B_obj</span><span class="keyword">-&gt;</span><span class="default">A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
&nbsp;</span><span class="comment">// print the info property from the A_obj to see if the change through B_obj has affected it<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'A_obj info: ' </span><span class="keyword">. </span><span class="default">$A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
The result:<br />
<br />
A_obj info: eeee<br />
B_obj info: eeee<br />
B_obj info after change: xxxxx<br />
A_obj info: xxxxx</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93292""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#93292" class="date">01-Sep-2009 01:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
After hours of confusion and reading tons of posts I finally figured out that replacing PHP 4 style object creation, where new is assigned by reference:<br />
<br />
$node_obj =&amp; new someClass($somearg, $moreargs);<br />
<br />
which in PHP 5.3.0 generates an E_STRICT message telling you that "Assigning the return value of new by reference is deprecated" <br />
<br />
with the following, where &amp; has been removed:<br />
<br />
$node_obj = new someClass($somearg, $moreargs);<br />
<br />
in some cases (at least in recursive loops while creating a tree of nodes containing child nodes) requires<br />
<br />
unset($node_obj);<br />
<br />
before the actual object assignment line to avoid all child nodes becoming identical. <br />
<br />
Hope that delicate piece of information will save someone else a few hours.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="89264""></a>
  <div class="note">
   <strong class="user">midir</strong>
   <a href="#89264" class="date">28-Feb-2009 11:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is a good magazine article (PDF format) that explains the internals of PHP's reference mechanism in detail: <a href="http://derickrethans.nl/files/phparch-php-variables-article.pdf" rel="nofollow" target="_blank">http://derickrethans.nl/files/phparch-php-variables-article.pdf</a><br />
<br />
It should explain some of the odd behavior PHP sometimes seems to exhibit, as well as why you can't create "references to references" (unlike in C++), and why you should never attempt to use references to speed up passing of large strings or arrays (it will make no difference, or it will slow things down).<br />
<br />
It was written for PHP 4 but it still applies. The only difference is in how PHP 5 handles objects: passing object variables by value only copies an internal pointer to the object. Objects in PHP 5 are only ever duplicated if you explicitly use the clone keyword.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87532""></a>
  <div class="note">
   <strong class="user">ivan at mailinator dot com</strong>
   <a href="#87532" class="date">09-Dec-2008 05:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A little gotcha (be careful with references!):<br />
<br />
<span class="default">&lt;?php<br />
$arr </span><span class="keyword">= array(</span><span class="string">'a'</span><span class="keyword">=&gt;</span><span class="string">'first'</span><span class="keyword">, </span><span class="string">'b'</span><span class="keyword">=&gt;</span><span class="string">'second'</span><span class="keyword">, </span><span class="string">'c'</span><span class="keyword">=&gt;</span><span class="string">'third'</span><span class="keyword">);<br />
foreach (</span><span class="default">$arr </span><span class="keyword">as &amp;</span><span class="default">$a</span><span class="keyword">); </span><span class="comment">// do nothing. maybe?<br />
</span><span class="keyword">foreach (</span><span class="default">$arr </span><span class="keyword">as </span><span class="default">$a</span><span class="keyword">);&nbsp; </span><span class="comment">// do nothing. maybe?<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Output:<br />
<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [a] =&gt; first<br />
&nbsp;&nbsp;&nbsp; [b] =&gt; second<br />
&nbsp;&nbsp;&nbsp; [c] =&gt; second<br />
)<br />
<br />
Add 'unset($a)' between the foreachs to obtain the 'correct' output:<br />
<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [a] =&gt; first<br />
&nbsp;&nbsp;&nbsp; [b] =&gt; second<br />
&nbsp;&nbsp;&nbsp; [c] =&gt; third<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84502""></a>
  <div class="note">
   <strong class="user">zzo38</strong>
   <a href="#84502" class="date">16-Jul-2008 01:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can make references like pointers. Example:<br />
<span class="default">&lt;?php<br />
&nbsp; $a</span><span class="keyword">=</span><span class="default">6</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$b</span><span class="keyword">=array(&amp;</span><span class="default">$a</span><span class="keyword">); </span><span class="comment">// $b is a pointer to $a<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">=array(&amp;</span><span class="default">$b</span><span class="keyword">); </span><span class="comment">// $c is a pointer to $b<br />
&nbsp; </span><span class="default">$d</span><span class="keyword">=</span><span class="default">7</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]=</span><span class="default">9</span><span class="keyword">; </span><span class="comment">// $a is 9<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]=array(&amp;</span><span class="default">$d</span><span class="keyword">); </span><span class="comment">// $b is a pointer to $d<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]=</span><span class="default">4</span><span class="keyword">; </span><span class="comment">// $d is 4<br />
&nbsp; </span><span class="default">$b</span><span class="keyword">=array(&amp;</span><span class="default">$a</span><span class="keyword">); </span><span class="comment">// $b is a pointer to $a again<br />
&nbsp; </span><span class="keyword">echo </span><span class="default">$a</span><span class="keyword">.</span><span class="default">$b</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">].</span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">].</span><span class="default">$d</span><span class="keyword">; </span><span class="comment">// outputs 9994<br />
</span><span class="default">?&gt;<br />
</span>These kind of pointers may even be passed to functions or returned from functions, copied and stored in multiple arrays/variables/objects, etc.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84378""></a>
  <div class="note">
   <strong class="user">jasonpvp at gmail dot com</strong>
   <a href="#84378" class="date">10-Jul-2008 04:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To change values in a multi-dimensional array while looping through:<br />
<br />
$var=array('a'=&gt;array(1,2,3),'b'=&gt;array(4,5,6));<br />
<br />
foreach ($var as &amp;$sub) {<br />
&nbsp; foreach ($sub as &amp;$element) {<br />
&nbsp;&nbsp;&nbsp; $element=$element+1;<br />
&nbsp; }<br />
}<br />
<br />
var_dump($var);<br />
<br />
------------------------------<br />
produces:<br />
------------------------------<br />
array(2) {<br />
&nbsp; ["a"]=&gt;<br />
&nbsp; array(3) {<br />
&nbsp;&nbsp;&nbsp; [0]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(2)<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(3)<br />
&nbsp;&nbsp;&nbsp; [2]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(4)<br />
&nbsp; }<br />
&nbsp; ["b"]=&gt;<br />
&nbsp; array(3) {<br />
&nbsp;&nbsp;&nbsp; [0]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(5)<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(6)<br />
&nbsp;&nbsp;&nbsp; [2]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(7)<br />
&nbsp; }<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84088""></a>
  <div class="note">
   <strong class="user">mpapec</strong>
   <a href="#84088" class="date">26-Jun-2008 05:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It's strange that function definition AND call to the same function must have "&amp;" before them. <br />
<br />
$arr = array();<br />
$ref =&amp; oras($arr['blah'], array());<br />
$ref []= "via ref";<br />
print_r($arr);<br />
<br />
/* result<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [blah] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; via ref<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
)<br />
*/<br />
<br />
// perl like ||=<br />
function &amp;oras (&amp;$v, $new) {<br />
&nbsp; $v or $v = $new;<br />
&nbsp; return $v;<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83737""></a>
  <div class="note">
   <strong class="user">dnhuff at acm dot org</strong>
   <a href="#83737" class="date">09-Jun-2008 12:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is discussed before (below) but bears repeating:<br />
<br />
$a = null; ($a =&amp; null; does not parse) is NOT the same as unset($a);<br />
<br />
$a = null; replaces the value at the destination of $a with the null value;<br />
<br />
If you chose to use a convention like $NULL = NULL;<br />
<br />
THEN, you could say $a =&amp; $NULL to break any previous reference assignment to $a (setting it of course to $NULL), which could still get you into trouble if you forgot and then said $a = '5'. Now $NULL would be '5'.<br />
<br />
Moral: use unset when it is called for.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83325""></a>
  <div class="note">
   <strong class="user">Dave at SymmetricDesigns dot com</strong>
   <a href="#83325" class="date">20-May-2008 11:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another example of something to watch out for when using references with arrays.&nbsp; It seems that even an usused reference to an array cell modifies the *source* of the reference.&nbsp; Strange behavior for an assignment statement (is this why I've seen it written as an =&amp; operator?&nbsp; - although this doesn't happen with regular variables).<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $array1 </span><span class="keyword">= array(</span><span class="default">1</span><span class="keyword">,</span><span class="default">2</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$x </span><span class="keyword">= &amp;</span><span class="default">$array1</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];&nbsp;&nbsp; </span><span class="comment">// Unused reference<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2 </span><span class="keyword">= </span><span class="default">$array1</span><span class="keyword">;&nbsp; </span><span class="comment">// reference now also applies to $array2 !<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]=</span><span class="default">22</span><span class="keyword">;&nbsp; &nbsp; &nbsp; </span><span class="comment">// (changing [0] will not affect $array1)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$array1</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Produces:<br />
&nbsp;&nbsp;&nbsp; Array<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; 1<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 22&nbsp; &nbsp; // var_dump() will show the &amp; here<br />
&nbsp;&nbsp;&nbsp; )<br />
<br />
I fixed my bug by rewriting the code without references, but it can also be fixed with the unset() function:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $array1 </span><span class="keyword">= array(</span><span class="default">1</span><span class="keyword">,</span><span class="default">2</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$x </span><span class="keyword">= &amp;</span><span class="default">$array1</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2 </span><span class="keyword">= </span><span class="default">$array1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; unset(</span><span class="default">$x</span><span class="keyword">); </span><span class="comment">// Array copy is now unaffected by above reference<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]=</span><span class="default">22</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$array1</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Produces:<br />
&nbsp;&nbsp;&nbsp; Array<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; 1<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 2<br />
&nbsp;&nbsp;&nbsp; )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79220""></a>
  <div class="note">
   <strong class="user">marco at greenlightsolutions dot nl</strong>
   <a href="#79220" class="date">15-Nov-2007 02:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I ran into a bit of a problem recently, with an array copy resulting in a reference copy of one of the elements instead of a clone. Sample code:<br />
<br />
<span class="default">&lt;?php<br />
$a</span><span class="keyword">=array(</span><span class="default">1 </span><span class="keyword">=&gt; </span><span class="string">"A"</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">=&amp;</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
</span><span class="default">$c</span><span class="keyword">=</span><span class="default">$a</span><span class="keyword">; </span><span class="comment">// should be a deep cloning<br />
</span><span class="default">$c</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]=</span><span class="string">"C"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]); </span><span class="comment">// yields 'C' instead of 'A'<br />
</span><span class="default">?&gt;<br />
</span><br />
After some searching, I found that it was a known bug which would be too costly to fix (see <a href="http://bugs.php.net/bug.php?id=20993" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=20993</a>). There was supposed to be some documentation on this behaviour on this page:<br />
<br />
"Due to peculiarities of the internal workings of PHP, if a reference&nbsp; is made to a single element of an array and then the array is copied, whether by assignment or when passed by value in a function call, the reference is copied as part of the array.&nbsp; This means that changes to any such elements in either array will be duplicated in the other array (and in the other references), even if the arrays have different scopes (e.g. one is an argument inside a function and the other is global)!&nbsp; Elements that did not have references at the time of the copy, as well as references assigned to those other elements after the copy of the array, will behave normally (i.e. independent of the other array)."<br />
<br />
However, this paragraph appears to have been removed from this page at some point, presumably because it was a bit obscure. The comments section seem to be a proper place for this, though.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79086""></a>
  <div class="note">
   <strong class="user">warnickr at gmail dot com</strong>
   <a href="#79086" class="date">10-Nov-2007 01:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I must say that it has been rather confusing following all of the explanations of PHP references, especially since I've worked a lot with C pointers.&nbsp; As far as I can tell PHP references are the same as C pointers for all practical purposes.&nbsp; I think a lot of the confusion comes from examples like the one shown below where people expect that a C pointer version of this would change what $bar references.&nbsp; <br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">foo</span><span class="keyword">(&amp;</span><span class="default">$var</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$var </span><span class="keyword">=&amp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="string">"baz"</span><span class="keyword">];<br />
}<br />
</span><span class="default">foo</span><span class="keyword">(</span><span class="default">$bar</span><span class="keyword">); <br />
</span><span class="default">?&gt;</span> <br />
<br />
This is not the case.&nbsp; In fact, a C pointer version of this example (shown below) would behave exactly the same way (it would not modify what bar references) as the PHP reference version.<br />
<br />
int baz = 5;<br />
int* bar;<br />
void foo(int* var)<br />
{<br />
&nbsp;&nbsp;&nbsp; var = &amp;baz;<br />
}<br />
foo(bar);<br />
<br />
In this case, just as in the case of PHP references, the call foo(bar) doesn't change what bar references.&nbsp; If you wanted to change what bar references, then you would need to work with a double pointer like so:<br />
<br />
int baz = 5;<br />
int* bar;<br />
void foo(int** var)<br />
{<br />
&nbsp;&nbsp;&nbsp; *var = &amp;baz;<br />
}<br />
foo(&amp;bar);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75635""></a>
  <div class="note">
   <strong class="user">eduardofleury at uol dot com dot br</strong>
   <a href="#75635" class="date">09-Jun-2007 06:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
$foo </span><span class="keyword">= </span><span class="string">'Hello'</span><span class="keyword">; <br />
</span><span class="default">$bar </span><span class="keyword">= </span><span class="string">'World'</span><span class="keyword">;&nbsp; <br />
print </span><span class="default">$foo </span><span class="keyword">. </span><span class="string">" " </span><span class="keyword">. </span><span class="default">$bar</span><span class="keyword">;</span><span class="comment">// Hello World<br />
<br />
</span><span class="default">$foo </span><span class="keyword">= &amp;</span><span class="default">$bar</span><span class="keyword">;<br />
</span><span class="default">$bar </span><span class="keyword">= </span><span class="string">'Hello My World'</span><span class="keyword">;<br />
<br />
print </span><span class="default">$foo</span><span class="keyword">;</span><span class="comment">// Hello My World<br />
</span><span class="keyword">print </span><span class="default">$bar</span><span class="keyword">;</span><span class="comment">// Hello My World<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75056""></a>
  <div class="note">
   <strong class="user">maghiel at mdijksman dot nl</strong>
   <a href="#75056" class="date">10-May-2007 04:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that:<br />
<br />
Call-time pass-by-reference has been deprecated - argument passed by value; If you would like to pass it by reference, modify the declaration of xxxxx. If you would like to enable call-time pass-by-reference, you can set allow_call_time_pass_reference to true in your INI file. However, future versions may not support this any longer</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74950""></a>
  <div class="note">
   <strong class="user">trucex at gmail dot com</strong>
   <a href="#74950" class="date">05-May-2007 01:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In response to Xor and Slava:<br />
<br />
I recommend you read up a bit more on the way PHP handles memory management. Take the following code for example:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$data </span><span class="keyword">= </span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'lotsofdata'</span><span class="keyword">];<br />
</span><span class="default">$data2 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
</span><span class="default">$data3 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
</span><span class="default">$data4 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
</span><span class="default">$data5 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Assuming we post 10MB of data to this PHP file, what will PHP do with the memory? <br />
<br />
PHP uses a table of sorts that maps variable names to the data that variable refers to in memory. The $_POST superglobal will actually be the first instance of that data in the execution, so it will be the first variable referenced to that data in the memory. It will consume 10MB. Each $data var will simply point to the same data in memory. Until you change that data PHP will NOT duplicate it.<br />
<br />
Passing a variable by value does just what I did with each $data var. There is no significant overhead to assigning a new name to the same data. It is only when you modify the data passed to the function that it must allocate memory for the data. Passing a variable by reference will do essentially the same thing when you pass the data to the function, only modifying it will modify the data that is in the memory already versus copying it to a new location in memory.<br />
<br />
If for learning purposes you choose to disregard the obvious pointlessness in benchmarking the difference between these two methods of passing arguments, you will need to modify the data when it is passed to the function in order to obtain more accurate results.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73663""></a>
  <div class="note">
   <strong class="user">sneskid at hotmail dot com</strong>
   <a href="#73663" class="date">06-Mar-2007 12:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
(v5.1.4)<br />
One cool thing about var_dump is it shows which variables are references (when dumping arrays), symbolized by '∫' for int/null, and by '&amp;' for boolean/double/string/array/object. I don't know why the difference in symmmmbolism.<br />
After playing around I found a better way to implement detaching (twas by accident). var_dump can show what's going on.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function &amp;</span><span class="default">detach</span><span class="keyword">(</span><span class="default">$v</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">){return </span><span class="default">$v</span><span class="keyword">;}<br />
<br />
</span><span class="default">$A</span><span class="keyword">=array(</span><span class="string">'x' </span><span class="keyword">=&gt; </span><span class="default">123</span><span class="keyword">, </span><span class="string">'y' </span><span class="keyword">=&gt; </span><span class="default">321</span><span class="keyword">);<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">] = &amp;</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">];<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">);<br />
</span><span class="comment">/* x became it's own reference...<br />
array(2) {<br />
&nbsp; ["x"]=&gt; ∫(123)<br />
&nbsp; ["y"]=&gt; int(321)<br />
}*/<br />
<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'y'</span><span class="keyword">]=&amp;</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">];<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">);<br />
</span><span class="comment">/* now both are references<br />
array(2) {<br />
&nbsp; ["x"]=&gt; ∫(123)<br />
&nbsp; ["y"]=&gt; ∫(123)<br />
}*/<br />
<br />
</span><span class="default">$z </span><span class="keyword">= </span><span class="string">'hi'</span><span class="keyword">;<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'y'</span><span class="keyword">]=&amp;</span><span class="default">detach</span><span class="keyword">(&amp;</span><span class="default">$z</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">);<br />
</span><span class="comment">/* x is still a reference, y and z share<br />
array(2) {<br />
&nbsp; ["x"]=&gt; ∫(123)<br />
&nbsp; ["y"]=&gt; &amp;string(2) "hi"<br />
}*/<br />
<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">] = </span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">];<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'y'</span><span class="keyword">]=&amp;</span><span class="default">detach</span><span class="keyword">();<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">,</span><span class="default">$z</span><span class="keyword">);<br />
</span><span class="comment">/* x returned to normal, y is on its own, z is still "hi"<br />
array(2) {<br />
&nbsp; ["x"]=&gt; int(123)<br />
&nbsp; ["y"]=&gt; NULL<br />
}*/<br />
</span><span class="default">?&gt;<br />
</span><br />
For detach to work you need to use '&amp;' in the function declaration, and every time you call it.<br />
<br />
Use this when you know a variable is a reference, and you want to assign a new value without effecting other vars referencing that piece of memory. You can initialize it with a new constant value, or variable, or new reference all in once step.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70852""></a>
  <div class="note">
   <strong class="user">sneskid at hotmail dot com</strong>
   <a href="#70852" class="date">31-Oct-2006 09:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
in addition to what 'jw at jwscripts dot com' wrote about unset; it can also be used to "detach" the variable alias so that it may work on a unique piece of memory again.<br />
<br />
here's an example<br />
<br />
<span class="default">&lt;?php<br />
define</span><span class="keyword">(</span><span class="string">'NL'</span><span class="keyword">, </span><span class="string">"\r\n"</span><span class="keyword">);<br />
<br />
</span><span class="default">$v1 </span><span class="keyword">= </span><span class="string">'shared'</span><span class="keyword">;<br />
</span><span class="default">$v2 </span><span class="keyword">= &amp;</span><span class="default">$v1</span><span class="keyword">;<br />
</span><span class="default">$v3 </span><span class="keyword">= &amp;</span><span class="default">$v2</span><span class="keyword">;<br />
</span><span class="default">$v4 </span><span class="keyword">= &amp;</span><span class="default">$v3</span><span class="keyword">;<br />
<br />
echo </span><span class="string">'before:'</span><span class="keyword">.</span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v1=' </span><span class="keyword">. </span><span class="default">$v1 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v2=' </span><span class="keyword">. </span><span class="default">$v2 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v3=' </span><span class="keyword">. </span><span class="default">$v3 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v4=' </span><span class="keyword">. </span><span class="default">$v4 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
<br />
</span><span class="comment">// detach messy<br />
</span><span class="default">$detach </span><span class="keyword">= </span><span class="default">$v1</span><span class="keyword">;<br />
unset(</span><span class="default">$v1</span><span class="keyword">);<br />
</span><span class="default">$v1 </span><span class="keyword">= </span><span class="default">$detach</span><span class="keyword">;<br />
<br />
</span><span class="comment">// detach pretty, but slower<br />
</span><span class="keyword">eval(</span><span class="default">detach</span><span class="keyword">(</span><span class="string">'$v2'</span><span class="keyword">));<br />
<br />
</span><span class="default">$v1 </span><span class="keyword">.= </span><span class="string">'?'</span><span class="keyword">;<br />
</span><span class="default">$v2 </span><span class="keyword">.= </span><span class="string">' no more'</span><span class="keyword">;<br />
</span><span class="default">$v3 </span><span class="keyword">.= </span><span class="string">' sti'</span><span class="keyword">;<br />
</span><span class="default">$v4 </span><span class="keyword">.= </span><span class="string">'ll'</span><span class="keyword">;<br />
<br />
echo </span><span class="default">NL</span><span class="keyword">.</span><span class="string">'after:'</span><span class="keyword">.</span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v1=' </span><span class="keyword">. </span><span class="default">$v1 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v2=' </span><span class="keyword">. </span><span class="default">$v2 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v3=' </span><span class="keyword">. </span><span class="default">$v3 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v4=' </span><span class="keyword">. </span><span class="default">$v4 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
<br />
function </span><span class="default">detach</span><span class="keyword">(</span><span class="default">$v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">= </span><span class="string">'$detach = ' </span><span class="keyword">. </span><span class="default">$v </span><span class="keyword">. </span><span class="string">';'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">.= </span><span class="string">'unset('</span><span class="keyword">.</span><span class="default">$v</span><span class="keyword">.</span><span class="string">');'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">.= </span><span class="default">$v </span><span class="keyword">. </span><span class="string">' = $detach;'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$e</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
output {<br />
before:<br />
v1=shared<br />
v2=shared<br />
v3=shared<br />
v4=shared<br />
<br />
after:<br />
v1=shared?<br />
v2=shared no more<br />
v3=shared still<br />
v4=shared still<br />
}<br />
<br />
<a href="http://www.obdev.at/developers/articles/00002.html says there" rel="nofollow" target="_blank">http://www.obdev.at/developers/articles/00002.html says there</a>'s no such thing as an "object reference" in PHP, but with detaching it becomes possible.<br />
<br />
Hopefully detach, or something like it, will become a language construct in the future.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68747""></a>
  <div class="note">
   <strong class="user">gunter dot sammet at gmail dot com</strong>
   <a href="#68747" class="date">09-Aug-2006 01:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I tried to create an array with n depth using a recursive function passing array references around. So far I haven't had much luck and I couldn't find anything on the web. So I ended up using eval() and it seems to work well:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach(</span><span class="default">array_keys</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">quantity_array</span><span class="keyword">) AS </span><span class="default">$key</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">quantity_array</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] &gt; </span><span class="default">0</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$combinations </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'-'</span><span class="keyword">, </span><span class="default">$key</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$eval_string </span><span class="keyword">= </span><span class="string">'$eval_array'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach(</span><span class="default">array_keys</span><span class="keyword">(</span><span class="default">$combinations</span><span class="keyword">) AS </span><span class="default">$key2</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$option_key_value </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'_'</span><span class="keyword">, </span><span class="default">$combinations</span><span class="keyword">[</span><span class="default">$key2</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$eval_string </span><span class="keyword">.= </span><span class="string">'['</span><span class="keyword">.</span><span class="default">$option_key_value</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">].</span><span class="string">']['</span><span class="keyword">.</span><span class="default">$option_key_value</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">].</span><span class="string">']'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$eval_string </span><span class="keyword">.= </span><span class="string">' = '</span><span class="keyword">.</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">quantity_array</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">].</span><span class="string">';'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eval(</span><span class="default">$eval_string</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
This produces an n dimensional array that will be available in the $eval_array variable. Hope it helps somebody!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60986""></a>
  <div class="note">
   <strong class="user">Ed</strong>
   <a href="#60986" class="date">22-Jan-2006 11:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Responding to Slava Kudinov.&nbsp; The only reason why your script takes longer when you pass by reference is that you do not at all modify the array that your passing to your functions.&nbsp; If you do that the diffrences in execution time will be a lot smaller.&nbsp; In fact&nbsp; passing by reference will be faster if just by a little bit.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59611""></a>
  <div class="note">
   <strong class="user">cesoid at yahoo dot com</strong>
   <a href="#59611" class="date">10-Dec-2005 06:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Responding to post from nathan (who was responding to iryoku).<br />
<br />
It is important to note the difference between what php is doing from the programmer's point of view and what it is doing internally. The note that nathan refers to, about how (for example) $something = $this makes a "copy" of the current object, is talking about making a "copy" from the programmer's perspective. That is, for the programmer, for all practical purposes, $something is a copy, even if internally nothing has been copied yet. For example, changing the data in member $something-&gt;somethingVar will not change your current object's data (i.e. it will not change $this-&gt;somethingVar).<br />
<br />
What it does internally is a totally different story. I've tested&nbsp; "copying" an object which contains a 200,000 element array, it takes almost no time at all until you finally change something in one of the copies, because internally it only makes the copy when it becomes necessary. The original assignment takes less than a millisecond, but when I alter one of the copies, it takes something like a quarter of a second. But this only happens if I alter the 200,000 element array, if I alter a single integer of the object, it takes less than a microsecond again, so the interpretter seems to be smart enough to make copies of some of the objects variables and not others.<br />
<br />
The result is that when you change a function to pass by reference, it will only become more efficient if, inside the function, the passed variable is having its data altered, in which case passing by reference causes your code to alter the data of the original copy. If you are passing an object and calling a function in that object, that function may alter the object without you even knowing, which means that you should pass an object by reference as long as it is ok for the original copy to be effected by what you do with the object inside the function.<br />
<br />
I think the real moral of the story is this:<br />
1) Pass by reference anything that should refer to and affect the original copy.<br />
2) Pass not by reference things that will definitely not be altered in the function (for an object, it may be impossible to know whether it alters itself upon calling one of its functions).<br />
3) If something needs to be altered inside a function without effecting the original copy, pass it not by reference, and pass the smallest practical part that needs to change, rather than passing, for example, a huge array of which one little integer will be altered.<br />
<br />
Or a shorter version: Only pass things by reference when you need to refer to the original copy! (And don't pass huge arrays or long strings when you need to change just a small part of them!)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57732""></a>
  <div class="note">
   <strong class="user">mramirez (at) star (minus) dev (dot) com</strong>
   <a href="#57732" class="date">12-Oct-2005 09:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For php programmers that come from pascal,<br />
in object pascal (delphi),<br />
variable references are used with the "absolute" keyword.<br />
<br />
PHP example:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">global </span><span class="default">$myglobal</span><span class="keyword">;<br />
<br />
</span><span class="default">$myglobal </span><span class="keyword">= </span><span class="default">5</span><span class="keyword">;<br />
<br />
function </span><span class="default">test</span><span class="keyword">()<br />
{<br />
global </span><span class="default">$myglobal</span><span class="keyword">;<br />
<br />
</span><span class="comment">/*local*/ </span><span class="default">$mylocal </span><span class="keyword">=&amp; </span><span class="default">$myglobal</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"local: " </span><span class="keyword">. </span><span class="default">$mylocal </span><span class="keyword">. </span><span class="string">"\n"</span><span class="keyword">;<br />
echo </span><span class="string">"gloal: " </span><span class="keyword">. </span><span class="default">$myglobal </span><span class="keyword">. </span><span class="string">"\n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">test</span><span class="keyword">();<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Pascal example:<br />
<br />
program dontcare;<br />
<br />
var myglobal: integer;<br />
<br />
procedure test;<br />
var mylocal ABSOLUTE myglobal;<br />
begin<br />
&nbsp; write("local: ", mylocal);<br />
&nbsp; write("global: ", myglobal);<br />
end;<br />
<br />
begin<br />
&nbsp; myglobal := 5;<br />
&nbsp; test;<br />
end.<br />
<br />
By the way, a "local" keyword in php for local variables,<br />
could be welcome :-)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57550""></a>
  <div class="note">
   <strong class="user">y007pig at yahoo dot com dot cn</strong>
   <a href="#57550" class="date">06-Oct-2005 11:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reply to pike at kw dot nl, '&amp;' is only apply to PHP 4.<br />
PHP 5 changed the behavior and the object is defaultly passed by references and if you turn on E_STRICT, you will get a notice:<br />
Strict Standards: Assigning the return value of new by reference is deprecated in xxxx<br />
If you want to *copy* object in PHP 5, use object clone.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56115""></a>
  <div class="note">
   <strong class="user">php at REMOVEMEkennel17 dot co dot uk</strong>
   <a href="#56115" class="date">23-Aug-2005 06:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I found a very useful summary of how references work in PHP4 (and some of the common pitfalls) in this article: <a href="http://www.obdev.at/developers/articles/00002.html" rel="nofollow" target="_blank">http://www.obdev.at/developers/articles/00002.html</a><br />
<br />
It deals with some subtle situations and I recommend it to anyone having difficulty with their references.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55766""></a>
  <div class="note">
   <strong class="user">grayson at uiuc dot edu</strong>
   <a href="#55766" class="date">12-Aug-2005 08:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I found a subtle feature of references that caused a bug in one of my PHP applications.&nbsp; In short, if an object passes one of its members to an external function that takes a reference as an argument, the external function can turn that member into a reference to an anonymous point in memory.<br />
<br />
Why is this a problem?&nbsp; Later, when you copy the object with $a = $b, the copy and the original share memory.<br />
<br />
Solution: If you want to have a function that uses references to modify a member of your object, your object should never pass the member to the function directly. It should first make a copy of the member. Then give that copy to the function.&nbsp; Then copy the new value of that copy in to your original object member.<br />
<br />
Below is some code that can reporoduce the this feature and demonstrate the workaround.<br />
<br />
function modify1 ( &amp;$pointer_obj ){<br />
&nbsp; $pointer_obj-&gt;property = 'Original Value';<br />
}<br />
<br />
function modify2 ( &amp;$pointer_obj ){<br />
&nbsp; $newObj-&gt;property = 'Original Value';<br />
&nbsp; $pointer_obj = $newObj;<br />
}<br />
<br />
class a {<br />
&nbsp; var $i;&nbsp;&nbsp; # an object with properties<br />
<br />
&nbsp; function corrupt1(){<br />
&nbsp;&nbsp;&nbsp; modify1 ($this-&gt;i);<br />
&nbsp; }<br />
<br />
&nbsp; function doNotCorrupt1(){<br />
&nbsp;&nbsp;&nbsp; $tmpi = $this-&gt;i;<br />
&nbsp;&nbsp;&nbsp; modify1 ($tmpi);<br />
&nbsp;&nbsp;&nbsp; $this-&gt;i = $tmpi;<br />
&nbsp; }<br />
<br />
&nbsp; function corrupt2(){<br />
&nbsp;&nbsp;&nbsp; modify2 ($this-&gt;i);<br />
&nbsp; }<br />
<br />
&nbsp; function doNotCorrupt2(){<br />
&nbsp;&nbsp;&nbsp; $tmpi = $this-&gt;i;<br />
&nbsp;&nbsp;&nbsp; modify2 ($tmpi);<br />
&nbsp;&nbsp;&nbsp; $this-&gt;i = $tmpi;<br />
&nbsp; }<br />
<br />
}<br />
<br />
$functions = array ('corrupt1', 'corrupt2', 'doNotCorrupt1', 'doNotCorrupt2');<br />
<br />
foreach ($functions as $func){<br />
<br />
&nbsp; $original = new a;<br />
<br />
&nbsp; ### Load some data in to the orginal with one of the four $functions<br />
&nbsp; $original-&gt;$func();<br />
<br />
&nbsp; $copy = $original;<br />
<br />
&nbsp; $copy-&gt;i-&gt;property = "Changed after the copy was made.";<br />
<br />
&nbsp; echo "\n{$func}: \$original-&gt;i-&gt;property = '" . $original-&gt;i-&gt;property . "'";<br />
}<br />
<br />
The script generates output:<br />
<br />
corrupt1: $original-&gt;i-&gt;property = 'Changed after the copy was made.'<br />
corrupt2: $original-&gt;i-&gt;property = 'Changed after the copy was made.'<br />
doNotCorrupt1: $original-&gt;i-&gt;property = 'Original Value'<br />
doNotCorrupt2: $original-&gt;i-&gt;property = 'Original Value'</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50994""></a>
  <div class="note">
   <strong class="user">nslater at gmail dot com</strong>
   <a href="#50994" class="date">15-Mar-2005 07:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In addition to the note made by "Francis dot a at gmx dot net" you should not normally be using a function such as sizeof() or count() in a control structure such as FOR because the same value is being calculated repeatedly for each iteration. This can slow things down immensely, regardless of whether you pass by value or reference.<br />
<br />
It is generally much better to calculate the static values before the defining the looping control structure.<br />
<br />
Example:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$intSize </span><span class="keyword">= </span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$arrData</span><span class="keyword">);<br />
<br />
for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$intSize</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Do stuff<br />
</span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50950""></a>
  <div class="note">
   <strong class="user">Carlos</strong>
   <a href="#50950" class="date">14-Mar-2005 12:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
in the example below, you would get the same result if you change the function to something like:<br />
<br />
function test_ref(&amp;$arr) {<br />
&nbsp;&nbsp; $time = time();<br />
&nbsp;&nbsp; $size = sizeof($arr);&nbsp; &nbsp; &nbsp;&nbsp; // &lt;--- this makes difference...<br />
&nbsp;&nbsp; for($n=0; $n&lt;$size; $n++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; $x = 1;<br />
&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; echo "&lt;br /&gt;The function using a reference took ".(time() - $time)." s";<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49829""></a>
  <div class="note">
   <strong class="user">Francis dot a at gmx dot net</strong>
   <a href="#49829" class="date">09-Feb-2005 10:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I don't know if this is a bug (I'm using PHP 5.01) but you should be careful when using&nbsp; references on arrays.<br />
I had a for-loop that was incredibly slow and it took me some time to find out that most of the time was wasted with the&nbsp; function sizeof() at every loop, and even more time I spent&nbsp; finding out that this problem it must be somehow related to the fact, that I used a reference of the array. Take a look at the following example:<br />
<br />
function test_ref(&amp;$arr) {<br />
&nbsp;&nbsp;&nbsp; $time = time();<br />
&nbsp;&nbsp;&nbsp; for($n=0; $n&lt;sizeof($arr); $n++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $x = 1;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; echo "&lt;br /&gt;The function using a reference took ".(time() - $time)." s";<br />
}<br />
<br />
function test_val($arr) {<br />
&nbsp;&nbsp;&nbsp; $time = time();<br />
&nbsp;&nbsp;&nbsp; for($n=0; $n&lt;sizeof($arr); $n++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $x = 1;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; echo "&lt;br /&gt;The funktion using a value took: ".(time() - $time)." s";<br />
}<br />
<br />
// fill array<br />
for($n=0; $n&lt;2000; $n++) {<br />
&nbsp;&nbsp;&nbsp; $ar[] = "test".$n;<br />
}<br />
<br />
test_ref($ar);<br />
test_val($ar);<br />
echo "&lt;br /&gt;Done";<br />
<br />
When I tested it, the first function was done after 9 seconds, while the second (although the array must be copied) was done in not even one.<br />
<br />
The difference is inproportional smaller when the array size is reduced:<br />
When using 1000 loops the first function was running for 1 second, when using 4000 it wasn't even done after 30 Seconds.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46590""></a>
  <div class="note">
   <strong class="user">jw at jwscripts dot com</strong>
   <a href="#46590" class="date">16-Oct-2004 05:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Re-using variables which where references before, without unsetting them first, leads to unexpected behaviour.<br />
<br />
The following code:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$numbers </span><span class="keyword">= array();<br />
<br />
for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">4</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$numbers</span><span class="keyword">[] = </span><span class="default">null</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$num </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$numbers</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$index </span><span class="keyword">=&amp; </span><span class="default">$numbers</span><span class="keyword">[</span><span class="default">$num </span><span class="keyword">? </span><span class="default">$num </span><span class="keyword">- </span><span class="default">1 </span><span class="keyword">: </span><span class="default">$num</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$index </span><span class="keyword">= </span><span class="default">$i</span><span class="keyword">;<br />
}<br />
<br />
foreach (</span><span class="default">$numbers </span><span class="keyword">as </span><span class="default">$index</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"</span><span class="default">$index</span><span class="string">\n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Does not produce:<br />
1<br />
2<br />
3<br />
<br />
But instead:<br />
1<br />
2<br />
2<br />
<br />
Applying unset($index) before re-using the variable fixes this and the expected list will be produced:<br />
1<br />
2<br />
3</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45696""></a>
  <div class="note">
   <strong class="user">hkmaly at bigfoot dot com</strong>
   <a href="#45696" class="date">15-Sep-2004 08:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems like PHP has problems with references, like that it can't work properly with circular references or free properly structure with more references. See <a href="http://bugs.php.net/?id=30053." rel="nofollow" target="_blank">http://bugs.php.net/?id=30053.</a><br />
<br />
I have big problem with this and I hope someone from PHP add proper warning with explanation IN manual, if they can't fix it.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="44203""></a>
  <div class="note">
   <strong class="user">jlaing at gmail dot com</strong>
   <a href="#44203" class="date">17-Jul-2004 08:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
While trying to do object references with the special $this variable I found that this will not work:<br />
class foo {<br />
&nbsp; function bar() {<br />
&nbsp;&nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; $this =&amp; $some_other_foo_obj;<br />
&nbsp; }<br />
}<br />
<br />
If you want to emulate this functionality you must iterate through the vars of the class and assign references like this:<br />
<br />
$vars = get_class_vars('foo');<br />
foreach (array_keys($vars) as $field) {<br />
&nbsp; $this-&gt;$field =&amp; $some_other_foo_obj-&gt;$field;<br />
}<br />
<br />
Now if you modify values within $this they will be modified within $some_other_foo_obj and vice versa.<br />
<br />
Hope that helps some people!<br />
<br />
p.s.<br />
developer at sirspot dot com's note about object references doesn't seem correct to me.<br />
<br />
&nbsp; $temp =&amp; $object;<br />
&nbsp; $object =&amp; $temp-&gt;getNext();<br />
<br />
Does the same exact thing as:<br />
<br />
&nbsp; $object =&amp; $object-&gt;getNext();<br />
<br />
when you refernce $temp to $object all it does is make $temp an alias to the same memory as $object, so doing $temp-&gt;getNext(); and $object-&gt;getNext(); are calling the same function on the same object.&nbsp; Try it out if you don't believe me.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="41300""></a>
  <div class="note">
   <strong class="user">nathan</strong>
   <a href="#41300" class="date">05-Apr-2004 10:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On the post that says php4 automagically makes references, this appears to *not* apply to objects:<br />
<br />
<a href="http://www.php.net/manual/en/language.references.whatdo.php" rel="nofollow" target="_blank">http://www.php.net/manual/en/language.references.whatdo.php</a><br />
<br />
"Note:&nbsp; Not using the &amp; operator causes a copy of the object to be made. If you use $this in the class it will operate on the current instance of the class. The assignment without &amp; will copy the instance (i.e. the object) and $this will operate on the copy, which is not always what is desired. Usually you want to have a single instance to work with, due to performance and memory consumption issues."</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="41114""></a>
  <div class="note">
   <strong class="user">iryoku at terra dot es</strong>
   <a href="#41114" class="date">30-Mar-2004 10:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You should have in mind that php4 keep assigned variables "automagically" referenced until they are overwritten. So the variable copy is not executed on assignment, but on modification. Say you have this:<br />
<br />
$var1 = 5;<br />
$var2 = $var1; // In this point these two variables share the same memory location<br />
$var1 = 3; // Here $var1 and $var2 have they own memory locations with values 3 and 5 respectively<br />
<br />
Don't use references in function parameters to speed up aplications, because this is automatically done. I think that this should be in the manual, because it can lead to confusion.<br />
<br />
More about this here:<br />
<a href="http://www.zend.com/zend/art/ref-count.php" rel="nofollow" target="_blank">http://www.zend.com/zend/art/ref-count.php</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
