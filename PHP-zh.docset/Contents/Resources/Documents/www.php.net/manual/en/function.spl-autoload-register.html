<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>注册给定的函数作为 __autoload 的实现</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.spl-autoload-functions.html">? spl_autoload_functions</a></li>
      <li style="float: right;"><a href="function.spl-autoload-unregister.html">spl_autoload_unregister ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.spl.html">SPL 函数</a></li>
    <li>注册给定的函数作为 __autoload 的实现</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.spl-autoload-register" class="refentry">
 <div class="refnamediv">
 <h1 class="refname">spl_autoload_register</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.1.0, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">spl_autoload_register</span> &mdash; <span class="dc-title">注册给定的函数作为 __autoload 的实现</span></p>

 </div>
  <div class="refsect1 description" id="refsect1-function.spl-autoload-register-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>spl_autoload_register</strong></span>(<span class="methodparam"><span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span> <code class="parameter">$autoload_function</code><span class="initializer"> = ?</span></span>, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$throw</code><span class="initializer"> = true</span></span>, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$prepend</code><span class="initializer"> = false</span></span>): <span class="type">bool</span></div>

  <p class="para rdfs-comment">
  将函数注册到SPL __autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。
  </p>
  <p class="para">
   如果在你的程序中已经实现了<span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span>函数，它必须显式注册到<span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span>队列中。因为
  <span class="function"><strong>spl_autoload_register()</strong></span>函数会将Zend Engine中的<span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span>函数取代为<span class="function"><a href="function.spl-autoload.html" class="function">spl_autoload()</a></span>或<span class="function"><a href="function.spl-autoload-call.html" class="function">spl_autoload_call()</a></span>。
  </p>
  <p class="para">
   如果需要多条 autoload 函数，<span class="function"><strong>spl_autoload_register()</strong></span> 
    满足了此类需求。
   它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下，
   <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> 只可以定义一次。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.spl-autoload-register-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
     <dt>
<code class="parameter">autoload_function</code></dt>

     <dd>

      <p class="para">
       欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数<span class="function"><a href="function.spl-autoload.html" class="function">spl_autoload()</a></span>。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">throw</code></dt>

     <dd>

      <p class="para">
       此参数设置了 <code class="parameter">autoload_function</code> 无法成功注册时，
       <span class="function"><strong>spl_autoload_register()</strong></span>是否抛出异常。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">prepend</code></dt>

     <dd>

      <p class="para">
       如果是 true，<span class="function"><strong>spl_autoload_register()</strong></span> 会添加函数到队列之首，而不是队列尾部。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.spl-autoload-register-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   成功时返回 <strong><code>true</code></strong>， 或者在失败时返回 <strong><code>false</code></strong>。
  </p>
 </div>



 <div class="refsect1 changelog" id="refsect1-function.spl-autoload-register-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.3.0</td>
       <td>
        引入了命名空间的支持。
       </td>
      </tr>

      <tr>
       <td>5.3.0</td>
       <td>
        添加了 <code class="parameter">prepend</code> 参数。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.spl-autoload-register-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-3583">
    <p><strong>Example #1 <span class="function"><strong>spl_autoload_register()</strong></span> 作为 <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> 函数的替代</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #FF8000">//&nbsp;function&nbsp;__autoload($class)&nbsp;{<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;'classes/'&nbsp;.&nbsp;$class&nbsp;.&nbsp;'.class.php';<br />//&nbsp;}<br /><br /></span><span style="color: #007700">function&nbsp;</span><span style="color: #0000BB">my_autoloader</span><span style="color: #007700">(</span><span style="color: #0000BB">$class</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;</span><span style="color: #DD0000">'classes/'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$class&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">'.class.php'</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(</span><span style="color: #DD0000">'my_autoloader'</span><span style="color: #007700">);<br /><br /></span><span style="color: #FF8000">//&nbsp;或者，自&nbsp;PHP&nbsp;5.3.0&nbsp;起可以使用一个匿名函数<br /></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(function&nbsp;(</span><span style="color: #0000BB">$class</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;</span><span style="color: #DD0000">'classes/'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$class&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">'.class.php'</span><span style="color: #007700">;<br />});<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
   <div class="example" id="example-3584">
    <p><strong>Example #2 class 未能加载的 <span class="function"><strong>spl_autoload_register()</strong></span> 例子</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #007700">namespace&nbsp;</span><span style="color: #0000BB">Foobar</span><span style="color: #007700">;<br /><br />class&nbsp;</span><span style="color: #0000BB">Foo&nbsp;</span><span style="color: #007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;public&nbsp;function&nbsp;</span><span style="color: #0000BB">test</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;</span><span style="color: #DD0000">'[['</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$name&nbsp;</span><span style="color: #007700">.</span><span style="color: #DD0000">']]'</span><span style="color: #007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(</span><span style="color: #0000BB">__NAMESPACE__&nbsp;</span><span style="color: #007700">.</span><span style="color: #DD0000">'\Foo::test'</span><span style="color: #007700">);&nbsp;</span><span style="color: #FF8000">//&nbsp;自&nbsp;PHP&nbsp;5.3.0&nbsp;起<br /><br /></span><span style="color: #007700">new&nbsp;</span><span style="color: #0000BB">InexistentClass</span><span style="color: #007700">;<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上例程的输出类似于：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
[[Foobar\InexistentClass]]
Fatal error: Class &#039;Foobar\InexistentClass&#039; not found in ...
</pre></div>
    </div>
   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.spl-autoload-register-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.autoload.html" class="function" rel="rdfs-seeAlso">__autoload()</a> - 尝试加载未定义的类</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="126119""></a>
  <div class="note">
   <strong class="user">kuzawinski dot marcin at nospam dot gmail dot com</strong>
   <a href="#126119" class="date">29-May-2021 05:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Since PHP 8.0 spl_autoload_register() will always throw a TypeError on invalid arguments, therefore the second argument `throw` is ignored and a notice will be emitted if it is set to False.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="122175""></a>
  <div class="note">
   <strong class="user">n0mAd at example dot com</strong>
   <a href="#122175" class="date">24-Dec-2017 07:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need to register the function when using namespaces, use the __NAMESPACE__ constant to define the name.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">namespace </span><span class="default">Foobar</span><span class="keyword">;<br />
<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'MyFunction'</span><span class="keyword">); </span><span class="comment">// incorrect<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'\MyFunction'</span><span class="keyword">);</span><span class="comment">// incorrect<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">__NAMESPACE__ </span><span class="keyword">. </span><span class="string">'\MyFunction'</span><span class="keyword">); </span><span class="comment">// correct<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121435""></a>
  <div class="note">
   <strong class="user">nemanja</strong>
   <a href="#121435" class="date">26-Jul-2017 08:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Even when autoloading (SPL) is used, class inheritance does not seem to work. Simply the PHP engine is unable to find parent (inherited) class. PHP 5.6 and 7.0 behave exactly same on this, which beats the purpose of autoloading.<br />
<br />
And IMHO it's easy to fix as the autoloader is able to find all first level classes w/o problems, it just needs to follow same path recursively on parents too.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">//Using default SPL autoloader, with namespaces mapping 1:1 to directory structure, with file names being all lowercase. <br />
//This works with first level classes only, for inheritance it does NOT work, it cannot find parent classes.<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">();<br />
<br />
</span><span class="comment">//This is ugly but working code if you want to be able to autoload parent classes too.<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(function (</span><span class="default">$class</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; require_once </span><span class="default">__DIR__ </span><span class="keyword">. </span><span class="string">'/' </span><span class="keyword">. </span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'\\'</span><span class="keyword">, </span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$class</span><span class="keyword">) . </span><span class="string">'.php'</span><span class="keyword">);<br />
});</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121141""></a>
  <div class="note">
   <strong class="user">rnealxp at yahoo dot com</strong>
   <a href="#121141" class="date">27-May-2017 06:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I now utilize spl_autoload_register and there's no turning back. So let me gather here for you what I've learned...<br />
1.) the issue mentioned in these docs about case-sensitivity of filenames (Windows vs Linux/Mac): it only comes into play if you don't provide your own custom function as an argument when calling spl_autoload_register. Your function is to accept a single argument which will be the class name that your code is currently trying to access. I observe that the class name comes in with the same letter-casing as that you are actually using in your code base (mixed-case or not). I am not doing/using namespaces, but as a best practice, and to make your implementation straight-forward and predictable, go with fileName===className (1:1).<br />
2.) I often refactor my code-base's directory structure as my code base morphs. I'm not using namespaces, but even if I were, I would want a decoupling between my namespace hierarchy and my directory structure hierarchy. I like my directory hierarchies to be intuitive for getting to code I want to work with. To save myself from having to manually tell my autoloader the path to each file/class, I cache a couple of arrays in static variables that store just the file/class name in the one array and the folder path to the file in the other. After the cache (static vars) have been set on the first call to my function, it's just a matter of looking up in the filename array. For safety, and to be problem-free, no two php filenames should be identical across all of your directory hierarchy (your namespace)--I favor this practice anyways, and accordingly, I favor unique class names across my single namespace (despite it not yet explicitly defined). I did build in a check in my function to ensure all php file names/classes are unique.<br />
3.) I converted many, many files that once had sets of functions in the global space to *abstract classes* that have private static variables and methods and of course also public static methods. So those sets of functions are now encapsulated in objects, and those objects are now auto-loaded. Simply for this benefit I will never again have a function in the global space other than my auto-loader function and other exceptions such as that.<br />
4.) My auto-loader function uses only built-in php language constructs and operations and has no outside dependencies.<br />
5.) If you utilize the function class_exists() in your codebase somewhere, realize that unless you are passing the second arg as false, you will trigger the autoloader to load that class. I stumbled on this of course. My use-case is that I don't want the class loaded: I only wanted to take some action if the class was being used (in an error-handler method).<br />
6.) If you use the function method_exists(), you will definitely trigger the class to be loaded (which makes sense since you have already decided to drill down to looking for a specific method).<br />
7.) I credit someone else's idea here: I also elected to call an init() method for the class being loaded should it exist. This saves me from having to manually call from the outside, let alone managing how and from where the call should be made. It is so useful to get your object set up and ready to do work in an automated fashion such as this.<br />
8.) as another said, I also use require() and not require_once() as the first is enough to generate an error and if already loaded the function will not have been called.<br />
9.) If for some reason I fail to find a class name in my cached arrays, I knowingly still call require(), passing the class name I had not accounted for in order to generate and reveal the problem (which of course is not anticipated!).<br />
10.) Again, I ensure uniqueness across all class names. If I observe non-uniqueness, I again do a faulty call to require() like this: require('FoundMultiplesOfClassFile.php'); to reveal the problem. (I don't yet, and you likely should not, have any sophisticated error-handler registered so this is as good as anything else to me).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118787""></a>
  <div class="note">
   <strong class="user">joneschrisan at aol dot com</strong>
   <a href="#118787" class="date">05-Feb-2016 04:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Looks like on the latest update of debian php passing no params to spl_autoload doesn't work on linux any more.<br />
<br />
It is failing to replace the \'s in the namespace with /'s for file paths.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118061""></a>
  <div class="note">
   <strong class="user">kakkau at grr dot la</strong>
   <a href="#118061" class="date">28-Sep-2015 05:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A note on registering autoloading functions with additional parameters.<br />
<br />
./alf.home.php<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/*<br />
&nbsp;* class containing an autoloading function alias ALF :)<br />
&nbsp;*/<br />
</span><span class="keyword">class </span><span class="default">ALF </span><span class="keyword">{<br />
&nbsp; public function </span><span class="default">haaahaaahaaa</span><span class="keyword">(</span><span class="default">$class </span><span class="keyword">= </span><span class="string">"ALF"</span><span class="keyword">, </span><span class="default">$param </span><span class="keyword">= </span><span class="string">"Melmac"</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"I am "</span><span class="keyword">.</span><span class="default">$class</span><span class="keyword">.</span><span class="string">" from "</span><span class="keyword">.</span><span class="default">$param</span><span class="keyword">.</span><span class="string">".\n"</span><span class="keyword">;<br />
&nbsp; }<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
./kate.melmac.php<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">require_once(</span><span class="string">"alf.home.php"</span><span class="keyword">);<br />
</span><span class="comment">/*<br />
&nbsp;* the normal way is to get ALF <br />
&nbsp;* and register an autoloading function<br />
&nbsp;*/<br />
</span><span class="default">$alf </span><span class="keyword">= new </span><span class="default">ALF</span><span class="keyword">();<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$alf</span><span class="keyword">,</span><span class="string">'haaahaaahaaa'</span><span class="keyword">));<br />
</span><span class="default">$alf</span><span class="keyword">-&gt;</span><span class="default">haaahaaahaaa</span><span class="keyword">(); </span><span class="comment">// ALF is from Melmac :)<br />
/*<br />
&nbsp;* now lets try to autoload a class<br />
&nbsp;*/<br />
</span><span class="keyword">@</span><span class="default">$kate </span><span class="keyword">= new </span><span class="default">Kate</span><span class="keyword">(); </span><span class="comment">// this throws a fatal error because<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Kate is NOT from Melmac :)<br />
</span><span class="default">?&gt;<br />
</span>I am ALF from Melmac.<br />
I am Kate from Melmac.<br />
<br />
./kate.earth.php<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">require_once(</span><span class="string">"alf.home.php"</span><span class="keyword">);<br />
</span><span class="comment">/*<br />
&nbsp;* BUT what if we want to correct Kates origin ?<br />
&nbsp;*&nbsp; &nbsp;&nbsp; How can one pass parameters to an autoloading function <br />
&nbsp;*&nbsp; &nbsp;&nbsp; upon registering?<br />
&nbsp;*<br />
&nbsp;* spl_autoload_register is not suitable for that <br />
&nbsp;*&nbsp;&nbsp; but we can try is to define a callable during registration<br />
&nbsp;*/<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(function(</span><span class="default">$class</span><span class="keyword">){ <br />
&nbsp; </span><span class="default">call_user_func</span><span class="keyword">(array(new </span><span class="default">ALF</span><span class="keyword">(),</span><span class="string">'haaahaaahaaa'</span><span class="keyword">), </span><span class="default">$class</span><span class="keyword">, </span><span class="string">"Earth"</span><span class="keyword">); });<br />
</span><span class="comment">/*<br />
&nbsp;* now lets try again to autoload a class<br />
&nbsp;* Kate will still not be found but we corrected her origin :)<br />
&nbsp;*/<br />
</span><span class="keyword">@</span><span class="default">$kate </span><span class="keyword">= new </span><span class="default">Kate</span><span class="keyword">(); </span><span class="comment">// Kate is from Earth :)<br />
/*<br />
&nbsp;* NOTE: that you cannot pass $this or another object created <br />
&nbsp;*&nbsp; &nbsp; &nbsp;&nbsp; outside of the callable context using the <br />
&nbsp;*&nbsp; &nbsp; &nbsp;&nbsp; registering way above. therefor you should swap your autoloading<br />
&nbsp;*&nbsp; &nbsp; &nbsp;&nbsp; function to a seperate class as done at the beginning with ALF.<br />
&nbsp;*<br />
&nbsp;* NOTE: you may not able to unregister your autoloading function<br />
&nbsp;*&nbsp; &nbsp; &nbsp;&nbsp; directly as an instance was created in another context<br />
&nbsp;*/<br />
</span><span class="default">?&gt;<br />
</span>I am Kate from Earth.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="117805""></a>
  <div class="note">
   <strong class="user">eyeofmidas at gmail dot com</strong>
   <a href="#117805" class="date">12-Aug-2015 03:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When switching from using __autoload() to using spl_autoload_register keep in mind that deserialization of the session can trigger class lookups.<br />
<br />
This works as expected: <br />
<span class="default">&lt;?php<br />
session_start</span><span class="keyword">();<br />
function </span><span class="default">__autoload</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br />
...<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
This will result in "__PHP_Incomplete_Class_Name" errors when using classes deserialized from the session.<br />
<span class="default">&lt;?php<br />
session_start</span><span class="keyword">();<br />
function </span><span class="default">customAutoloader</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br />
...<br />
}<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">"customAutoloader"</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
So you need to make sure the spl_autoload_register is done BEFORE session_start() is called.<br />
<br />
CORRECT:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">customAutoloader</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br />
...<br />
}<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">"customAutoloader"</span><span class="keyword">);<br />
</span><span class="default">session_start</span><span class="keyword">();<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="117241""></a>
  <div class="note">
   <strong class="user">iam at thatguy dot co dot za</strong>
   <a href="#117241" class="date">08-May-2015 07:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Example to auto-load class files from multiple directories using the SPL_AUTOLOAD_REGISTER method.<br />
&nbsp;&nbsp;&nbsp; // It auto-loads any file it finds starting with class.&lt;classname&gt;.php (LOWERCASE), eg: class.from.php, class.db.php<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(function(</span><span class="default">$class_name</span><span class="keyword">) {<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Define an array of directories in the order of their priority to iterate through.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$dirs </span><span class="keyword">= array(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'project/'</span><span class="keyword">, </span><span class="comment">// Project specific classes (+Core Overrides)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'classes/'</span><span class="keyword">, </span><span class="comment">// Core classes example<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'tests/'</span><span class="keyword">,&nbsp;&nbsp; </span><span class="comment">// Unit test classes, if using PHP-Unit<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Looping through each directory to load all the class files. It will only require a file once.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // If it finds the same class in a directory later on, IT WILL IGNORE IT! Because of that require once!<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach( </span><span class="default">$dirs </span><span class="keyword">as </span><span class="default">$dir </span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">file_exists</span><span class="keyword">(</span><span class="default">$dir</span><span class="keyword">.</span><span class="string">'class.'</span><span class="keyword">.</span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">$class_name</span><span class="keyword">).</span><span class="string">'.php'</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; require_once(</span><span class="default">$dir</span><span class="keyword">.</span><span class="string">'class.'</span><span class="keyword">.</span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">$class_name</span><span class="keyword">).</span><span class="string">'.php'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; });</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="116811""></a>
  <div class="note">
   <strong class="user">xavier dot bouhours at free dot fr</strong>
   <a href="#116811" class="date">03-Mar-2015 03:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
// Get last class version <br />
<br />
&nbsp;&nbsp;&nbsp; if( !function_exists('classAutoLoader') )<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function classAutoLoader($className)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $classFiles&nbsp; &nbsp;&nbsp; = array() ;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $classFile&nbsp; &nbsp;&nbsp; = FALSE ;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $classDir&nbsp; &nbsp; &nbsp; &nbsp; = __DIR__ .'/'&nbsp; ;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Get all files<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $files&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = scandir( $classDir ) ;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach ( $files as $url )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Verifie if file is : Name + class + version + extension<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( is_file($classDir.$url) &amp;&amp; preg_match('/([^\.]+)\.class\.([\d\.]+)\.(.+)$/', $url, $m ) )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {&nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Verifie finded file<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( $className == $m[1] )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Get previous version or init<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $previous = isset( $classFiles[$m[1]] ) ? $classFiles[$m[1]] : 0 ;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Get last version<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( $previous&lt;$m[2] )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $classFiles[ $m[1] ] = $m[2] ; // version<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $classFile = $classDir.$url ;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }&nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } ;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( !class_exists($className) ) include( $classFile );<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; spl_autoload_register('classAutoLoader') ;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="116706""></a>
  <div class="note">
   <strong class="user">neolium at gmail dot com</strong>
   <a href="#116706" class="date">13-Feb-2015 01:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This autoload will find every class you call if you put each one in a different file.<br />
<br />
It walks into every directory recursivly from the root you specify in the $root var.<br />
<br />
You can specify the folders ou don't want to walk in (e.g you won't find any class in a 'view' folder on an MVC project) in the $dir_to_not_look_in array;<br />
<br />
spl_autoload_register(function($class) {<br />
<br />
&nbsp;&nbsp;&nbsp; $root = 'my/root/path';<br />
&nbsp;&nbsp;&nbsp; $file = $class . '.php';<br />
&nbsp;&nbsp;&nbsp; $dir_to_not_look_in = array($directories, $to, $not, $look, $in);<br />
<br />
&nbsp;&nbsp;&nbsp; if(!function_exists('load')) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; function load($dir, $file) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(file_exists($dir . '/' . $file)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; require_once $dir . '/' . $file;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach(scandir($dir) as $value) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(is_dir($dir. '/' . $value) &amp;&amp; !in_array($value, $dir_to_no_look_in))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; load($dir. '/' . $value, $file);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; };&nbsp; <br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; load($root, $file);<br />
&nbsp;&nbsp;&nbsp; <br />
});</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115154""></a>
  <div class="note">
   <strong class="user">nmmm at nmmm dot nu</strong>
   <a href="#115154" class="date">04-Jun-2014 02:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
spl_autoload_register() can be used with include_path.<br />
<br />
suppose in current directory we have directory "a", and inside there is directory "test" and inside is test.php :<br />
<br />
&lt;?<br />
namespace test;<br />
class test{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function __construct(){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo "Test created\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
}<br />
?&gt; <br />
<br />
then we can use following code to load the class:<br />
&lt;?<br />
ini_set("include_path", "./a/");<br />
<br />
spl_autoload_register();<br />
<br />
$t = new \test\test();<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114042""></a>
  <div class="note">
   <strong class="user">hajo-p</strong>
   <a href="#114042" class="date">05-Jan-2014 05:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if you have a dir-structure like "/abc/def/ghi", your index.php lies in the top directory, but you want to use namespaces starting with "def" or "ghi":
<br />

<br />
you can switch the namespace root directory of php with e.g. set_include_path(__DIR__ . '/abc') and afterwards define + use your namespaces with the simple spl_autoload_register() function without any arguments supplied.
<br />

<br />
remember that php handlers "cli" and "cli-server" are special cases.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113362""></a>
  <div class="note">
   <strong class="user">Kurd the Great</strong>
   <a href="#113362" class="date">01-Oct-2013 04:13</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if(!defined('BASE_PATH')) {<br />
&nbsp;&nbsp;&nbsp; define('BASE_PATH', dirname(__FILE__) . '/');<br />
&nbsp;&nbsp;&nbsp; require BASE_PATH . 'Autoloader.php';<br />
&nbsp;&nbsp;&nbsp; Autoloader::Register();<br />
}<br />
<br />
class Autoloader<br />
{<br />
&nbsp;&nbsp;&nbsp; public static function Register() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return spl_autoload_register(array('Autoloader', 'Load'));<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; public static function Load($strObjectName) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(class_exists($strObjectName) === false) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return false;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $strObjectFilePath = BASE_PATH . $strObjectName . '.php';<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if((file_exists($strObjectFilePath) === false) || (is_readable($strObjectFilePath) === false)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return false;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; require($strObjectFilePath);<br />
&nbsp;&nbsp;&nbsp; }<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113251""></a>
  <div class="note">
   <strong class="user">phil at propcom dot co dot uk</strong>
   <a href="#113251" class="date">18-Sep-2013 08:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is important to note that the autoloader will NOT be called if an E_STRICT error triggers the error handler which, in turn, tries to use classes which are not yet loaded. <br />
<br />
In this instance, you should manually load classes required by the error handler.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112804""></a>
  <div class="note">
   <strong class="user">ali dot taheri dot m at gmail dot com</strong>
   <a href="#112804" class="date">24-Jul-2013 02:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've made a little function that makes and registers a loader that seems to be safe and reliable although I'm not sure but it feels like a good idea to share, it took me some time to come up with it I hope it saves someone some time, <br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">Loader</span><span class="keyword">(</span><span class="default">$root </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$loaderFunction </span><span class="keyword">= </span><span class="default">create_function</span><span class="keyword">(</span><span class="string">'$class'</span><span class="keyword">, </span><span class="string">'include&nbsp; "' </span><span class="keyword">. </span><span class="default">$root </span><span class="keyword">. </span><span class="string">'$class.php";'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$loaderFunction</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
if you have a file system exactly like your directory tree this function works perfectly, I haven't tested it on unix, but on windows, the default loader fails when your webpage isn't in the root directory, this makes sure that it won't cause a problem if your webpage is on a subdir too just pass ../ or more drived ../../ as root and it will work like a charm, note that i couldn't use anonymous functions because then the $root variable wouldn't have the same scope as the Loader function, so the function must be created on the fly. this is a good example of this functions usage<br />
<br />
your class:<br />
root/classes/support/classic.php<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">namespace </span><span class="default">classes</span><span class="keyword">/</span><span class="default">support</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; class </span><span class="default">classic </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// class def<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
root/support/index.php<br />
<span class="default">&lt;?php<br />
<br />
Loader</span><span class="keyword">(</span><span class="string">'../'</span><span class="keyword">);<br />
<br />
use </span><span class="default">classes</span><span class="keyword">/</span><span class="default">support</span><span class="keyword">/</span><span class="default">classic</span><span class="keyword">;<br />
<br />
</span><span class="default">$cls </span><span class="keyword">= new </span><span class="default">classic</span><span class="keyword">();<br />
</span><span class="comment">//use $cls<br />
</span><span class="default">?&gt;<br />
</span><br />
the loader will make a function like this:<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function(</span><span class="default">$class</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; include&nbsp; </span><span class="string">"../</span><span class="default">$class</span><span class="string">.php"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">//when and when the class is needed this will run the script which is indeed what we need:<br />
<br />
</span><span class="keyword">include </span><span class="string">'../classes/support/classic.php'</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
hope this helps folks;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112260""></a>
  <div class="note">
   <strong class="user">sebastian at 34n dot de</strong>
   <a href="#112260" class="date">24-May-2013 09:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can also use it like this:<br />
<br />
&gt; spl_autoload_register ( array( new AutoloaderClass, 'method') );<br />
<br />
or in PHP &gt; 5.3:<br />
<br />
&gt; spl_autoload_register ( [ new My\Namespace\Autoloader, 'method'] );<br />
<br />
On this way you dont have to create a variable, which is used once.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111875""></a>
  <div class="note">
   <strong class="user">a dot schaffhirt at sedna-soft dot de</strong>
   <a href="#111875" class="date">07-Apr-2013 01:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
What I said here previously is only true on Windows. The built-in default autoloader that is registered when you call spl_autoload_register() without any arguments simply adds the qualified class name plus the registered file extension (.php) to each of the include paths and tries to include that file.<br />
<br />
Example (on Windows):<br />
<br />
include paths:<br />
- "."<br />
- "d:/projects/phplib"<br />
<br />
qualified class name to load:<br />
network\http\rest\Resource<br />
<br />
Here's what happens:<br />
<br />
PHP tries to load<br />
'.\\network\\http\\rest\\Resource.php'<br />
-&gt; file not found<br />
<br />
PHP tries to load<br />
'd:/projects/phplib\\network\\http\\rest\\Resource.php'<br />
-&gt; file found and included<br />
<br />
Note the slashes and backslashes in the file path. On Windows this works perfectly, but on a Linux machine, the backslashes won't work and additionally the file names are case-sensitive.<br />
<br />
That's why on Linux the quick-and-easy way would be to convert these qualified class names to slashes and to lowercase and pass them to the built-in autoloader like so:<br />
<br />
<span class="default">&lt;?php<br />
spl_autoload_register</span><span class="keyword">(<br />
&nbsp; function (</span><span class="default">$pClassName</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload</span><span class="keyword">(</span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">"\\"</span><span class="keyword">, </span><span class="string">"/"</span><span class="keyword">, </span><span class="default">$pClassName</span><span class="keyword">)));<br />
&nbsp; }<br />
);<br />
</span><span class="default">?&gt;<br />
</span><br />
But this means, you have to save all your classes with lowercase file names. Otherwise, if you omit the strtolower call, you have to use the class names exactly as specified by the file name, which can be annoying for class names that are defined with non-straightforward case like e. g. XMLHttpRequest.<br />
<br />
I prefer the lowercase approach, because it is easier to use and the file name conversion can be done automatically on deploying.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="110382""></a>
  <div class="note">
   <strong class="user">daniel at amnistechnology dot com</strong>
   <a href="#110382" class="date">17-Oct-2012 09:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Cleverly - and usefully - I have noticed that (on PHP 5.3 at least) these autoloaders "kick in" even when you call a public static method of an as-yet-unloaded all static class.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107362""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#107362" class="date">03-Feb-2012 04:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that when specifying the third parameter (prepend), the function will fail badly in PHP 5.2</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102180""></a>
  <div class="note">
   <strong class="user">(delphists) at (apollo) dot (lv)</strong>
   <a href="#102180" class="date">01-Feb-2011 01:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When using spl_autoload_register() with class methods, it might seem that it can use only public methods, though it can use private/protected methods as well, if registered from inside the class:<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">ClassAutoloader </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public function </span><span class="default">__construct</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$this</span><span class="keyword">, </span><span class="string">'loader'</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; private function </span><span class="default">loader</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">'Trying to load '</span><span class="keyword">, </span><span class="default">$className</span><span class="keyword">, </span><span class="string">' via '</span><span class="keyword">, </span><span class="default">__METHOD__</span><span class="keyword">, </span><span class="string">"()\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; include </span><span class="default">$className </span><span class="keyword">. </span><span class="string">'.php'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$autoloader </span><span class="keyword">= new </span><span class="default">ClassAutoloader</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Class1</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Class2</span><span class="keyword">();<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Output:<br />
--------<br />
Trying to load Class1 via ClassAutoloader::loader()<br />
Class1::__construct()<br />
Trying to load Class2 via ClassAutoloader::loader()<br />
Class2::__construct()</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98746""></a>
  <div class="note">
   <strong class="user">anthon at piwik dot org</strong>
   <a href="#98746" class="date">04-Jul-2010 09:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Think twice about throwing an exception from a registered autoloader.<br />
<br />
If you have multiple autoloaders registered, and one (or more) throws an exception before a later autoloader loads the class, stacked exceptions are thrown (and must be caught) even though the class was loaded successfully.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96952""></a>
  <div class="note">
   <strong class="user">sebastian dot krebs at kingcrunch dot de</strong>
   <a href="#96952" class="date">24-Mar-2010 10:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems, that&nbsp; spl_autoload tests, if the class exists, after calling every registered loader. So it breaks the chain, if the class exists and will not call the other loaders
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">a </span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) {
<br />
&nbsp; echo </span><span class="string">"a\n"</span><span class="keyword">;
<br />
&nbsp; class </span><span class="default">Bla </span><span class="keyword">{} </span><span class="comment">// Usually "include 'path/to/file.php';"
<br />
</span><span class="keyword">}
<br />
function </span><span class="default">b </span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) {
<br />
&nbsp; echo </span><span class="string">"b\n"</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'a'</span><span class="keyword">);
<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'b'</span><span class="keyword">);
<br />

<br />
</span><span class="default">$c </span><span class="keyword">= new </span><span class="default">Bla</span><span class="keyword">();
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96804""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#96804" class="date">16-Mar-2010 08:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be careful using this function on case sensitive file systems.<br />
<br />
<span class="default">&lt;?php<br />
spl_autoload_extensions</span><span class="keyword">(</span><span class="string">'.php'</span><span class="keyword">);<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
I develop on OS X and everything was working fine. But when releasing to my linux server, none of my class files were loading. I had to lowercase all my filenames, because calling a class "DatabaseObject" would try including "databaseobject.php", instead of "DatabaseObject.php"<br />
<br />
I think i'll go back to using the slower __autoload() function, just so i can keep my class files readable</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95456""></a>
  <div class="note">
   <strong class="user">rayro at gmx dot de</strong>
   <a href="#95456" class="date">04-Jan-2010 03:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is never a good idea and a unconscienable concept to create the classes in the autoload function via eval. <br />
It should be a nice feature with these Exception, but i think anyone is able to handle it without this method although. Atm i dont realize for what this is good for...<br />
<br />
As i might note, class_exists() will ever define the classes u only want to check for existance, and will therefor ever return true:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">EvalIsEvil</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br />
&nbsp; eval(</span><span class="string">'class '</span><span class="keyword">.</span><span class="default">$className</span><span class="keyword">.</span><span class="string">'{}'</span><span class="keyword">);<br />
}<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'EvalIsEvil'</span><span class="keyword">);<br />
if (</span><span class="default">class_exists</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">=</span><span class="string">"IsMyModuleHere"</span><span class="keyword">)) {<br />
&nbsp; </span><span class="comment">// this is no module, but get there with eval()...<br />
&nbsp; </span><span class="keyword">return new </span><span class="default">$s</span><span class="keyword">();<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92514""></a>
  <div class="note">
   <strong class="user">a dot schaffhirt at sedna-soft dot de</strong>
   <a href="#92514" class="date">27-Jul-2009 07:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Good news for PHP 5.3 users with namespaced classes:<br />
<br />
When you create a subfolder structure matching the namespaces of the containing classes, you will never even have to define an autoloader.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; spl_autoload_extensions</span><span class="keyword">(</span><span class="string">".php"</span><span class="keyword">); </span><span class="comment">// comma-separated list<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
It is recommended to use only one extension for all classes. PHP (more exactly spl_autoload) does the rest for you and is even quicker than a semantically equal self-defined autoload function like this one:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">my_autoload </span><span class="keyword">(</span><span class="default">$pClassName</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; include(</span><span class="default">__DIR__ </span><span class="keyword">. </span><span class="string">"/" </span><span class="keyword">. </span><span class="default">$pClassName </span><span class="keyword">. </span><span class="string">".php"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">"my_autoload"</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
I compared them with the following setting: There are 10 folders, each having 10 subfolders, each having 10 subfolders, each containing 10 classes.<br />
<br />
To load and instantiate these 1000 classes (parameterless no-action constructor), the user-definded autoload function approach took 50ms longer in average than the spl_autoload function in a series of 10 command-line calls for each approach.<br />
<br />
I made this benchmark to ensure that I don't recommend something that could be called "nice, but slow" later.<br />
<br />
Best regards,</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="78122""></a>
  <div class="note">
   <strong class="user">stanlemon at mac dot com</strong>
   <a href="#78122" class="date">28-Sep-2007 10:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Editorial note: The appropriate PHP bug that requests behavior this function emulates is <a href="http://bugs.php.net/bug.php?id=42823 . This function does NOT work if there has been an array($obj, " rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=42823 . This function does NOT work if there has been an array($obj, </a>'nonStaticMethod') registered in the autoload stack--while the autoload will be removed, it will be re-registered incorrectly.
<br />

<br />
The spl_autoload_register() method registers functions in its stack in the order that spl_autoload_register() was called, and subsequently if you want an autoload function to override previous autoload functions you will either need to unregister the previous ones or change the order of the autoload stack.
<br />

<br />
For example, say in your default implementation of an autoload function you throw an exception if the class cannot be found, or perhaps a fatal error.&nbsp; Later on in your code you add a second implementation of an autoload function which will load a library that the previous method would fail on.&nbsp; This will not call the second autoloader method first, but rather will continue to error out on the first method.
<br />

<br />
As previously mentioned, you can unregister the existing autoloader that errors out, or you can create a mechanism for unregistering and re-registering the autoloaders in the order you want.
<br />

<br />
Here is a sample/example of how you might consider re-registering autoloaders so that the newest autoloader is called first, and the oldest last:
<br />

<br />
<span class="default">&lt;?php
<br />

<br />
</span><span class="comment">// Editorial notes: Small bug and compatibility fixes
<br />
// added to the function
<br />

<br />
</span><span class="keyword">function </span><span class="default">spl_autoload_preregister</span><span class="keyword">( </span><span class="default">$autoload </span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// No functions currently in the stack.
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if ( (</span><span class="default">$funcs </span><span class="keyword">= </span><span class="default">spl_autoload_functions</span><span class="keyword">()) === </span><span class="default">false </span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$autoload</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; } else {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Unregister existing autoloaders...
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$compat </span><span class="keyword">=
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">version_compare</span><span class="keyword">(</span><span class="default">PHP_VERSION</span><span class="keyword">, </span><span class="string">'5.1.2'</span><span class="keyword">, </span><span class="string">'&lt;='</span><span class="keyword">) &amp;&amp;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">version_compare</span><span class="keyword">(</span><span class="default">PHP_VERSION</span><span class="keyword">, </span><span class="string">'5.1.0'</span><span class="keyword">, </span><span class="string">'&gt;='</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$funcs </span><span class="keyword">as </span><span class="default">$func</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">)) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// :TRICKY: There are some compatibility issues and some
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // places where we need to error out
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$reflector </span><span class="keyword">= new </span><span class="default">ReflectionMethod</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">$func</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!</span><span class="default">$reflector</span><span class="keyword">-&gt;</span><span class="default">isStatic</span><span class="keyword">()) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; throw new </span><span class="default">Exception</span><span class="keyword">(</span><span class="string">'
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; This function is not compatible
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; with non-static object methods due to PHP Bug #44144.
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; '</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Suprisingly, spl_autoload_register supports the
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Class::staticMethod callback format, although call_user_func doesn't
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$compat</span><span class="keyword">) </span><span class="default">$func </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">(</span><span class="string">'::'</span><span class="keyword">, </span><span class="default">$func</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_unregister</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Register the new one, thus putting it at the front of the stack...
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$autoload</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Now, go back and re-register all of our old ones.
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach (</span><span class="default">$funcs </span><span class="keyword">as </span><span class="default">$func</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; }
<br />
}
<br />

<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Note: I have not tested this for overhead, so I am not 100% sure what the performance implication of the above example are.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73146""></a>
  <div class="note">
   <strong class="user">harvey dot NO_SPAM dot robin at gmail dot com</strong>
   <a href="#73146" class="date">10-Feb-2007 05:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function is smart enough not to add the same loader twice.&nbsp; This seems to work for all of the different loader formats.&nbsp; Example:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">ALoader<br />
</span><span class="keyword">{<br />
&nbsp; static function </span><span class="default">load</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) { return </span><span class="default">true</span><span class="keyword">; }<br />
}<br />
<br />
function </span><span class="default">anotherLoader</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br />
&nbsp; return </span><span class="default">true</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">$F </span><span class="keyword">= new </span><span class="default">ALoader</span><span class="keyword">;<br />
<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'ALoader'</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'ALoader'</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$F</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'anotherLoader'</span><span class="keyword">);<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'anotherLoader'</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">spl_autoload_functions</span><span class="keyword">());<br />
<br />
</span><span class="comment">/*<br />
&nbsp;* Results on PHP5.2 CLI, linux.<br />
&nbsp;* array(2) {<br />
&nbsp;*&nbsp; [0]=&gt;<br />
&nbsp;*&nbsp; array(2) {<br />
&nbsp;*&nbsp; &nbsp; [0]=&gt;<br />
&nbsp;*&nbsp; &nbsp; string(7) "ALoader"<br />
&nbsp;*&nbsp; &nbsp; [1]=&gt;<br />
&nbsp;*&nbsp; &nbsp; string(4) "load"<br />
&nbsp;*&nbsp; }<br />
&nbsp;*&nbsp; [1]=&gt;<br />
&nbsp;*&nbsp; string(13) "anotherLoader"<br />
&nbsp;* }<br />
&nbsp;*/<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71155""></a>
  <div class="note">
   <strong class="user">florent at mediagonale dot com</strong>
   <a href="#71155" class="date">14-Nov-2006 01:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If your autoload function is a class method, you can call spl_autoload_register with an array specifying the class and the method to run.<br />
<br />
* You can use a static method :<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">class </span><span class="default">MyClass </span><span class="keyword">{<br />
&nbsp; public static function </span><span class="default">autoload</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// ...<br />
&nbsp; </span><span class="keyword">}<br />
}<br />
<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'MyClass'</span><span class="keyword">, </span><span class="string">'autoload'</span><span class="keyword">));<br />
</span><span class="default">?&gt;<br />
</span><br />
* Or you can use an instance :<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">MyClass </span><span class="keyword">{<br />
&nbsp; public function </span><span class="default">autoload</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// ...<br />
&nbsp; </span><span class="keyword">}<br />
}<br />
<br />
</span><span class="default">$instance </span><span class="keyword">= new </span><span class="default">MyClass</span><span class="keyword">();<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$instance</span><span class="keyword">, </span><span class="string">'autoload'</span><span class="keyword">));<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
