<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>PCNTL 函数</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="pcntl.example.html">? </a></li>
      <li style="float: right;"><a href="function.pcntl-alarm.html">pcntl_alarm ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="book.pcntl.html">PCNTL</a></li>
    <li>PCNTL 函数</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="ref.pcntl" class="reference">
 <h1 class="title">PCNTL 函数</h1>

 <div class="partintro">
  <h1 class="title">参见</h1>
  <p class="para">
   参考一下
   <a href="ref.posix.html" class="link">POSIX functions</a>
   对有助于理解使用。
  </p>
 </div>

 












































































































































<h2>Table of Contents</h2><ul class="chunklist chunklist_reference"><li><a href="function.pcntl-alarm.html">pcntl_alarm</a> &mdash; 为进程设置一个alarm闹钟信号</li><li><a href="function.pcntl-async-signals.html">pcntl_async_signals</a> &mdash; Enable/disable asynchronous signal handling or return the old setting</li><li><a href="function.pcntl-errno.html">pcntl_errno</a> &mdash; 别名 pcntl_get_last_error</li><li><a href="function.pcntl-exec.html">pcntl_exec</a> &mdash; 在当前进程空间执行指定程序</li><li><a href="function.pcntl-fork.html">pcntl_fork</a> &mdash; 在当前进程当前位置产生分支（子进程）。译注：fork是创建了一个子进程，父进程和子进程
  都从fork的位置开始向下继续执行，不同的是父进程执行过程中，得到的fork返回值为子进程
  号，而子进程得到的是0。</li><li><a href="function.pcntl-get-last-error.html">pcntl_get_last_error</a> &mdash; Retrieve the error number set by the last pcntl function which failed</li><li><a href="function.pcntl-getpriority.html">pcntl_getpriority</a> &mdash; 获取任意进程的优先级</li><li><a href="function.pcntl-setpriority.html">pcntl_setpriority</a> &mdash; 修改任意进程的优先级</li><li><a href="function.pcntl-signal-dispatch.html">pcntl_signal_dispatch</a> &mdash; 调用等待信号的处理器</li><li><a href="function.pcntl-signal-get-handler.html">pcntl_signal_get_handler</a> &mdash; Get the current handler for specified signal</li><li><a href="function.pcntl-signal.html">pcntl_signal</a> &mdash; 安装一个信号处理器</li><li><a href="function.pcntl-sigprocmask.html">pcntl_sigprocmask</a> &mdash; 设置或检索阻塞信号</li><li><a href="function.pcntl-sigtimedwait.html">pcntl_sigtimedwait</a> &mdash; 带超时机制的信号等待</li><li><a href="function.pcntl-sigwaitinfo.html">pcntl_sigwaitinfo</a> &mdash; 等待信号</li><li><a href="function.pcntl-strerror.html">pcntl_strerror</a> &mdash; Retrieve the system error message associated with the given errno</li><li><a href="function.pcntl-wait.html">pcntl_wait</a> &mdash; 等待或返回 fork 的子进程状态</li><li><a href="function.pcntl-waitpid.html">pcntl_waitpid</a> &mdash; 等待或返回fork的子进程状态</li><li><a href="function.pcntl-wexitstatus.html">pcntl_wexitstatus</a> &mdash; 返回一个中断的子进程的返回代码</li><li><a href="function.pcntl-wifexited.html">pcntl_wifexited</a> &mdash; 检查状态代码是否代表一个正常的退出。</li><li><a href="function.pcntl-wifsignaled.html">pcntl_wifsignaled</a> &mdash; 检查子进程状态码是否代表由于某个信号而中断</li><li><a href="function.pcntl-wifstopped.html">pcntl_wifstopped</a> &mdash; 检查子进程当前是否已经停止</li><li><a href="function.pcntl-wstopsig.html">pcntl_wstopsig</a> &mdash; 返回导致子进程停止的信号</li><li><a href="function.pcntl-wtermsig.html">pcntl_wtermsig</a> &mdash; 返回导致子进程中断的信号</li></ul>
</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="123915""></a>
  <div class="note">
   <strong class="user">debasiss at mindfiresolutions dot com</strong>
   <a href="#123915" class="date">07-Jun-2019 04:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
&nbsp;* @file<br />
&nbsp;* Working demo of simulating parallel process in PHP.<br />
&nbsp;*/<br />
<br />
// ****&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; **** //<br />
</span><span class="keyword">print </span><span class="string">"Main program started.... \n"</span><span class="keyword">;<br />
</span><span class="comment">// Start two child processes.<br />
</span><span class="default">createProcess</span><span class="keyword">(</span><span class="string">"Job1"</span><span class="keyword">);<br />
</span><span class="default">createProcess</span><span class="keyword">(</span><span class="string">"Job2"</span><span class="keyword">);<br />
print </span><span class="string">" *** Child Process started *** \n"</span><span class="keyword">;<br />
<br />
while (</span><span class="default">TRUE</span><span class="keyword">) {<br />
<br />
&nbsp;</span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_waitpid</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">, </span><span class="default">$status</span><span class="keyword">, </span><span class="default">WNOHANG</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$pid </span><span class="keyword">&gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">childProcessComplete</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }else if(</span><span class="default">$pid </span><span class="keyword">=== -</span><span class="default">1</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; print </span><span class="string">" *** Child Process Completed *** \n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">allChildProcessComplete</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exit();<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
}<br />
print </span><span class="string">"Main program end. \n"</span><span class="keyword">;<br />
<br />
</span><span class="comment">/**<br />
&nbsp;* Method to start child process.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">startChildProcess</span><span class="keyword">(</span><span class="default">$childProcessName</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$executionTime </span><span class="keyword">= </span><span class="default">rand</span><span class="keyword">(</span><span class="default">5</span><span class="keyword">, </span><span class="default">10</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$childProcessName </span><span class="keyword">=== </span><span class="string">"Job1"</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; print </span><span class="string">"Starting Job1 on processId " </span><span class="keyword">.</span><span class="default">getmypid</span><span class="keyword">().</span><span class="string">"&nbsp; at " </span><span class="keyword">. </span><span class="default">date</span><span class="keyword">(</span><span class="string">'l jS \of F Y h:i:s A'</span><span class="keyword">) . </span><span class="string">" expected time </span><span class="default">$executionTime</span><span class="string"> seconds\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }else if(</span><span class="default">$childProcessName </span><span class="keyword">=== </span><span class="string">"Job2"</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; print </span><span class="string">"Starting Job2 on processId " </span><span class="keyword">.</span><span class="default">getmypid</span><span class="keyword">().</span><span class="string">"&nbsp; at " </span><span class="keyword">. </span><span class="default">date</span><span class="keyword">(</span><span class="string">'l jS \of F Y h:i:s A'</span><span class="keyword">) . </span><span class="string">" expected time </span><span class="default">$executionTime</span><span class="string"> seconds\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Simulate doing actual work with sleep().<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">$executionTime</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="comment">/**<br />
&nbsp;* Method to notify when system unable to start a process.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">errorOnProcessLunch</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"Failed to lunch process \n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">/**<br />
&nbsp;* Method to notify when a child process complete the task.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">childProcessComplete</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"Child processing is done for </span><span class="default">$pid</span><span class="string">&nbsp; at " </span><span class="keyword">. </span><span class="default">date</span><span class="keyword">(</span><span class="string">'l jS \of F Y h:i:s A'</span><span class="keyword">) . </span><span class="string">" \n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">/**<br />
&nbsp;* Method to create a new process.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">createProcess</span><span class="keyword">(</span><span class="default">$pname</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">errorOnProcessLunch</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else if (</span><span class="default">$pid </span><span class="keyword">=== </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">startChildProcess</span><span class="keyword">(</span><span class="default">$pname</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exit(); </span><span class="comment">// Make sure to exit.<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
&nbsp;&nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">startParentProcess</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
}<br />
<br />
</span><span class="comment">/**<br />
&nbsp;* Method to notify when parent thread execute.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">startParentProcess</span><span class="keyword">(</span><span class="default">$childProcessID</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"In parent thread created child processid </span><span class="default">$childProcessID</span><span class="string"> \n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">/**<br />
&nbsp;* Method to notify when all child process has completed the task.<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">allChildProcessComplete</span><span class="keyword">(){<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"All child processing completed \n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85558""></a>
  <div class="note">
   <strong class="user">kevin at vanzonneveld dot net</strong>
   <a href="#85558" class="date">05-Sep-2008 03:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to create a daemon in PHP, consider using System_Daemon <a href="http://pear.php.net/package/System_Daemon" rel="nofollow" target="_blank">http://pear.php.net/package/System_Daemon</a><br />
<br />
Install it like this:<br />
pear install -f system_daemon<br />
<br />
Then use it like this:<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// Include PEAR's Daemon Class<br />
</span><span class="keyword">require_once </span><span class="string">"System/Daemon.php"</span><span class="keyword">;<br />
<br />
</span><span class="comment">// Bare minimum setup<br />
</span><span class="default">System_Daemon</span><span class="keyword">::</span><span class="default">setOption</span><span class="keyword">(</span><span class="string">"appName"</span><span class="keyword">, </span><span class="string">"mydaemonname"</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Spawn Deamon!<br />
</span><span class="default">System_Daemon</span><span class="keyword">::</span><span class="default">start</span><span class="keyword">();<br />
<br />
</span><span class="comment">// Your PHP Here!<br />
</span><span class="keyword">while (</span><span class="default">true</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">doTask</span><span class="keyword">();<br />
}<br />
<br />
</span><span class="comment">// Stop daemon!<br />
</span><span class="default">System_Daemon</span><span class="keyword">::</span><span class="default">stop</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
More examples can be found inside the PEAR package.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82373""></a>
  <div class="note">
   <strong class="user">m dot quinton at gmail dot com</strong>
   <a href="#82373" class="date">08-Apr-2008 12:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
a nice example of a class framework to manage tasks using pcntl_fork.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">/**<br />
&nbsp;* author : Marc Quinton / April 2008.<br />
&nbsp;*<br />
&nbsp;*&nbsp; a simple task management framework using pcntl_fork, pcntl_wait.<br />
&nbsp;*<br />
&nbsp;*&nbsp; - see at bottom for a sample usage.<br />
&nbsp;*&nbsp; - you shoud overring Task class (SleepingClass is an example), and manage them in a pool, using taskManager<br />
&nbsp;*/<br />
<br />
</span><span class="default">error_reporting</span><span class="keyword">(</span><span class="default">E_ALL</span><span class="keyword">);<br />
<br />
class </span><span class="default">Task </span><span class="keyword">{<br />
<br />
&nbsp;&nbsp;&nbsp; protected </span><span class="default">$pid</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; protected </span><span class="default">$ppid</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">__construct</span><span class="keyword">(){<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">fork</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; throw new </span><span class="default">Exception </span><span class="keyword">(</span><span class="string">'fork error on Task object'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; elseif (</span><span class="default">$pid</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># we are in parent class<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pid </span><span class="keyword">= </span><span class="default">$pid</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># echo "&lt; in parent with pid {$his-&gt;pid}\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">} else{<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># we are is child<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">run</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">run</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># echo "&gt; in child {$this-&gt;pid}\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; # sleep(rand(1,3));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">ppid </span><span class="keyword">= </span><span class="default">posix_getppid</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pid </span><span class="keyword">= </span><span class="default">posix_getpid</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment"># call when a task in finished (in parent)<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">finish</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"task finished </span><span class="keyword">{</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pid</span><span class="keyword">}</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">pid</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pid</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
class </span><span class="default">SleepingTask </span><span class="keyword">extends </span><span class="default">Task</span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">run</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">parent</span><span class="keyword">::</span><span class="default">run</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"&gt; in child </span><span class="keyword">{</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pid</span><span class="keyword">}</span><span class="string">\n"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># print_r($this);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">rand</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">,</span><span class="default">5</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"&gt; child done </span><span class="keyword">{</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pid</span><span class="keyword">}</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exit(</span><span class="default">0</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
class </span><span class="default">TaskManager</span><span class="keyword">{<br />
<br />
&nbsp;&nbsp;&nbsp; protected </span><span class="default">$pool</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">__construct</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pool </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">add_task</span><span class="keyword">(</span><span class="default">$task</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pool</span><span class="keyword">[] = </span><span class="default">$task</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">run</span><span class="keyword">(){<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pool </span><span class="keyword">as </span><span class="default">$task</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$task</span><span class="keyword">-&gt;</span><span class="default">fork</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment"># print_r($this);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; # sleep(60);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">while(</span><span class="default">1</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"waiting\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_wait</span><span class="keyword">(</span><span class="default">$extra</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">": task done : </span><span class="default">$pid</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">finish_task</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"processes done ; exiting\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exit(</span><span class="default">0</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">finish_task</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$task </span><span class="keyword">= </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pid_to_task</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$task</span><span class="keyword">-&gt;</span><span class="default">finish</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">pid_to_task</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pool </span><span class="keyword">as </span><span class="default">$task</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$task</span><span class="keyword">-&gt;</span><span class="default">pid</span><span class="keyword">() == </span><span class="default">$pid</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$task</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
</span><span class="default">$manager </span><span class="keyword">= new </span><span class="default">TaskManager</span><span class="keyword">();<br />
<br />
for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0 </span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">10 </span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$manager</span><span class="keyword">-&gt;</span><span class="default">add_task</span><span class="keyword">(new </span><span class="default">SleepingTask</span><span class="keyword">());<br />
<br />
</span><span class="default">$manager</span><span class="keyword">-&gt;</span><span class="default">run</span><span class="keyword">();<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77603""></a>
  <div class="note">
   <strong class="user">registrazioni at XSPAMX dot tassetti dot net</strong>
   <a href="#77603" class="date">05-Sep-2007 09:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
(PHP 5.2.4) <br />
<br />
This is an example of multithreading keeping different connections to a mysql database: when children exit they close the connection and others can't use it any more generating problems. In this example I used variable variables to make a different connection per each child. <br />
<br />
This scripts loops forever with one mother detached from the terminal and five children 'named' from 1 to 5. When one children sees it's name in the database (one table 'test.tb' with only one field 'test') he lets himself die. To kill children insert their value in the db. The mother suicides only when all children are dead.<br />
<br />
What a sad but interesting story...<br />
<br />
&nbsp;&nbsp;&nbsp; $npid = pcntl_fork(); // DETACH FROM TERMINAL AND BE REAPED BY INIT<br />
<br />
&nbsp;&nbsp;&nbsp; if ($npid==-1) die("Error: impossible to pcntl_fork()\n");<br />
&nbsp;&nbsp;&nbsp; else if ($npid) exit(0); // THE GRANPA DIES<br />
&nbsp;&nbsp;&nbsp; else // MOTHER GOES ON TO MAKE CHILDREN<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $children = 5;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for ($i=1; $i&lt;=$children; $i++)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $pid = pcntl_fork();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ($pid==-1) die("Error: impossible to pcntl_fork()\n");<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if ($pid)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $pid_arr[$i] = $pid;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!$pid) // CHILDREN<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; global $vconn;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $vconn = "vconn$i";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; global $$vconn;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $$vconn = @mysql_connect("mydbhost","mydbuser","mydbpwd");<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!($$vconn)) echo mysql_error();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!($$vconn)) exit;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while (1)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $query = "SELECT test FROM test.tb";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $rs = mysql_query($query,$$vconn);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $rw = mysql_fetch_row($rs);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ($rw[0]==$i) exit;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo "Database is $rw[0] and I am $i, it's not my time, I will wait....\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sleep(1);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach ($pid_arr as $pid)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // we are the parent and we wait for all children to die<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pcntl_waitpid($pid, $status);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo "All my children died, I will suicide...\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exit();<br />
&nbsp;&nbsp;&nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77047""></a>
  <div class="note">
   <strong class="user">flyingguillotine1968 at yahoo dot com</strong>
   <a href="#77047" class="date">12-Aug-2007 05:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
ok, heres what ya do to handle child process's ... :&gt; <br />
<br />
you want to pfork your main program, and let it exit, <br />
allowing the new child to become the main program (parent process).<br />
<br />
example psudo code : <br />
main program start;<br />
&nbsp;&nbsp; &nbsp; ....<br />
&nbsp;&nbsp; &nbsp; if pfork'd child ok<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; then exit ;<br />
<br />
&nbsp;&nbsp;&nbsp; // now your new child process is in control... <br />
&nbsp;&nbsp;&nbsp; // use a signal handler to make it exit (sigkill or sigterm probably)<br />
&nbsp;&nbsp;&nbsp; // when this new process pforks, store the new child PID's in an<br />
&nbsp;&nbsp;&nbsp; // array.&nbsp;&nbsp; when your process&nbsp; catch's the sigterm&nbsp; signal<br />
&nbsp;&nbsp;&nbsp; // loop thru the array of its child PID's sending each child<br />
&nbsp;&nbsp;&nbsp; // sigkill , then call&nbsp; pwait on them to wait for them to exit.<br />
&nbsp;&nbsp;&nbsp; // this will make sure any child process are cleaned up ok<br />
&nbsp;&nbsp;&nbsp; // THEN .. now here's the trick.... <br />
&nbsp;&nbsp;&nbsp; // reset yer sigterm handler BACK to its original default handler, <br />
&nbsp;&nbsp; // thennnnn&nbsp;&nbsp; raise sigterm , main program will exit ok now tooooo :&gt; <br />
<br />
&nbsp; <br />
example: <br />
when your pfork'd main process gets sigterm ... then do something <br />
like this : <br />
<br />
foreach ($this-&gt;pForkList as $kiddie) {<br />
$deadPID&nbsp; &nbsp; = 0;<br />
$this-&gt;sendSignal(SIGKILL,$kiddie);<br />
do {<br />
$deadPID = pcntl_waitpid(-1,WNOHANG);<br />
if ($deadPID &gt; 0) {<br />
// kiddie has exited now ... <br />
unset($this-&gt;pForkList[ array_search($deadPID,$this-&gt;pForkList)]);<br />
break;<br />
} // end if<br />
} while ($deadPID == 0);<br />
<br />
} // end for<br />
<br />
// now reset sigterm ... <br />
$this-&gt;signalSet($sigNum,SIG_DFL);<br />
// RAISE sigterm now ... <br />
$this-&gt;sendSignal(SIGTERM,$this-&gt;myPID);<br />
<br />
this will allow your main process and all its child process's to exit properly and not leave and zombies or other bad stuff behind !</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72004""></a>
  <div class="note">
   <strong class="user">kementeusNOSPAM at gmail dot com</strong>
   <a href="#72004" class="date">28-Dec-2006 09:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In the example of the documentation we need to put the pctnl_signal statements BEFORE the while loop.<br />
<br />
In that way we can execute whatever we put in the signal handler functions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47103""></a>
  <div class="note">
   <strong class="user">corychristison at lavacube dot com</strong>
   <a href="#47103" class="date">02-Nov-2004 06:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
An easier way than what was first suggested in the first comment, to retrieve what signal your application is being sent would be to use get_defined_constants() to list all constants, loop through and strip out those that are not signals, and to check if it matches the value.<br />
<br />
Here is my code for doing this, written for PHP5 only.<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// php5 Specfic<br />
<br />
</span><span class="keyword">function </span><span class="default">pcntl_sig_identify </span><span class="keyword">( </span><span class="default">$sig_no </span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$get_constants </span><span class="keyword">= </span><span class="default">get_defined_constants</span><span class="keyword">(</span><span class="default">true</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pcntl_contstants </span><span class="keyword">= </span><span class="default">$get_constants</span><span class="keyword">[</span><span class="string">"pcntl"</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$keys </span><span class="keyword">= </span><span class="default">array_keys</span><span class="keyword">( </span><span class="default">$pcntl_contstants </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; foreach(</span><span class="default">$keys </span><span class="keyword">as </span><span class="default">$key</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">strstr</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">, </span><span class="string">"SIG"</span><span class="keyword">) &amp;&amp; !</span><span class="default">strstr</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">, </span><span class="string">"_"</span><span class="keyword">) &amp;&amp; </span><span class="default">$pcntl_contstants</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] == </span><span class="default">$sig_no</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">$key</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; } </span><span class="comment">// end loop<br />
</span><span class="keyword">} </span><span class="comment">// end function pcntl_sig_identify<br />
<br />
// <br />
// This example will output "SIGTERM"<br />
//<br />
<br />
</span><span class="keyword">print </span><span class="default">pcntl_sig_identify</span><span class="keyword">(</span><span class="default">15</span><span class="keyword">) . </span><span class="string">"\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="44937""></a>
  <div class="note">
   <strong class="user">andy at cbeyond dot net</strong>
   <a href="#44937" class="date">20-Aug-2004 09:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Suppose you want to fork off children to handle a few hundred different targets (like, say, SNMP polling, but that's just one example).&nbsp; Since you don't want to fork-bomb yourself, here's one method of limiting the number of children you have in play at any one time:<br />
<br />
#!/usr/bin/php -q<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">declare(</span><span class="default">ticks </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">);<br />
<br />
</span><span class="default">$max</span><span class="keyword">=</span><span class="default">10</span><span class="keyword">;<br />
</span><span class="default">$child</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;<br />
<br />
</span><span class="comment">// function for signal handler<br />
</span><span class="keyword">function </span><span class="default">sig_handler</span><span class="keyword">(</span><span class="default">$signo</span><span class="keyword">) {<br />
&nbsp; global </span><span class="default">$child</span><span class="keyword">;<br />
&nbsp; switch (</span><span class="default">$signo</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; case </span><span class="default">SIGCHLD</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp;&nbsp; echo </span><span class="string">"SIGCHLD received\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$child </span><span class="keyword">-= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp; }<br />
}<br />
<br />
</span><span class="comment">// install signal handler for dead kids<br />
</span><span class="default">pcntl_signal</span><span class="keyword">(</span><span class="default">SIGCHLD</span><span class="keyword">, </span><span class="string">"sig_handler"</span><span class="keyword">);<br />
<br />
for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;=</span><span class="default">20</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; while (</span><span class="default">$child </span><span class="keyword">&gt;= </span><span class="default">$max</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">5</span><span class="keyword">); echo </span><span class="string">"\t Maximum children allowed\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$child</span><span class="keyword">++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid</span><span class="keyword">=</span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; die(</span><span class="string">"could not fork"</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else if (</span><span class="default">$pid</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// we are the parent<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">} else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// we are the child<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">echo </span><span class="string">"child number </span><span class="default">$i</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// presumably doing something interesting<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">15</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exit;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
}</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="38020""></a>
  <div class="note">
   
   <a href="#38020" class="date">04-Dec-2003 03:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
in example 1, i found unless i create function sig_handler _BEFORE_ pcnt_signal, it wouldnt work.. and would just fall to the floor bleeding to death<br />
<br />
(note for people having these kinda probs)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37518""></a>
  <div class="note">
   <strong class="user">cameronNO_SPAM at tripdubdev dot com</strong>
   <a href="#37518" class="date">18-Nov-2003 12:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I'm currently working on some code for this, but in case I forget to come back to post to the board, or in case it takes me a while, why not just have a separate background job running (started up via the shell) that tracks which sockets are available to clients ?&nbsp; Then all you'd have to do is communicate with the one job (or perhaps its own mini-server) run in the background that keeps an array of the available sockets for the server.&nbsp; This seems the most natural alternative since PHP disclaims that process control functionality should not be used in a web-server environment.&nbsp; I would hate to build a server, especially one with high traffic, that had to run through a loop in order to find an available socket.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37369""></a>
  <div class="note">
   <strong class="user">luca dot mariano at email dot it</strong>
   <a href="#37369" class="date">12-Nov-2003 06:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi folks,<br />
if someone uses PHP-CLI onWin32 and wants to experiment the PCNTL stuff, I've packed a binary version of PHP with built-in pcntl, shmop, sysvshm and other typical Unix extensions... (thanks to Cygwin DLLs).<br />
Download it: <a href="http://phplet.sf.net/modules.php?name=Web_Links&amp;l_op=visit&amp;lid=4" rel="nofollow" target="_blank">http://phplet.sf.net/modules.php?name=Web_Links&amp;l_op=visit&amp;lid=4</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="36603""></a>
  <div class="note">
   <strong class="user">jeremy at nirvani dot net</strong>
   <a href="#36603" class="date">15-Oct-2003 08:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
#!/usr/local/bin/php -q<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment"># Jeremy Brand &lt;jeremy@nirvani.net&gt;<br />
# <a href="http://www.nirvani.net/" rel="nofollow" target="_blank">http://www.nirvani.net/</a><br />
<br />
# ./configure --enable-pcntl --enable-sigchild<br />
# make<br />
# make install<br />
<br />
# This code example shows how to use a script to do multiprocessing.&nbsp; Each time<br />
# this script is ran, the result is 5 (in this example) processes running to<br />
# accomplish a specified task.<br />
<br />
# Examples could be a messaging queue.&nbsp; You could get the number of messages in<br />
# a queue and handle any or all of them asynchronously.<br />
<br />
# Get the number of children you want to be born by running this<br />
# script once.<br />
</span><span class="default">$children </span><span class="keyword">= </span><span class="default">5</span><span class="keyword">; </span><span class="comment"># likely a function call here.<br />
<br />
</span><span class="keyword">for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;=</span><span class="default">$children</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)<br />
{<br />
<br />
&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp; if (</span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">)<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; die(</span><span class="string">"could not fork\n"</span><span class="keyword">);<br />
&nbsp; }<br />
&nbsp; else if (</span><span class="default">$pid</span><span class="keyword">)<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment"># If we are the parent, we did our job of giving birth,<br />
&nbsp;&nbsp;&nbsp; # now lets finish our job and die!<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">exit(</span><span class="default">0</span><span class="keyword">);<br />
&nbsp; }<br />
&nbsp; else<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment"># Since we are the child, fork so that init will become our parent.&nbsp; Init<br />
&nbsp;&nbsp;&nbsp; # is good at wait()ing on children - ie: reaping.<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$cpid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$cpid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp;&nbsp; die(</span><span class="string">"could not fork in child process\n"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (!</span><span class="default">$cpid</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="comment"># We have now forked off from our parent and also are not waiting on any<br />
&nbsp;&nbsp; &nbsp;&nbsp; # other children to process, however other children are running<br />
&nbsp;&nbsp; &nbsp;&nbsp; # simutaniously to us.&nbsp; Make sure the code you write here is safe to run<br />
&nbsp;&nbsp; &nbsp;&nbsp; # in this environment of multiprocessing - ie: proper locking, etc.<br />
&nbsp;&nbsp; &nbsp;&nbsp; # Write the custom code here that you want to multiprocess.<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; # ADD CODE HERE TO MULTIPROCESS<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">print </span><span class="string">"we are child number </span><span class="default">$i</span><span class="string">\n"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="comment"># Don't forget to exit after the child processing is done.&nbsp; Certainly<br />
&nbsp;&nbsp; &nbsp;&nbsp; # change this exit code if you need to however.<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">exit(</span><span class="default">0</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35777""></a>
  <div class="note">
   <strong class="user">David Koopman</strong>
   <a href="#35777" class="date">14-Sep-2003 01:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had a hard time finding a complete example of using PHP as a multi-process (or multi-threaded - I don't understand the difference in these two terms) daemon using connection pooling.&nbsp; I put pieces of the puzzle together and came up with the program below.&nbsp; I hope it helps someone.&nbsp; Notes about making this work:<br />
<br />
1) I rebuilt PHP on my machine with these config options:<br />
./configure --enable-sockets --enable-pcntl --enable-sigchild<br />
make<br />
make install<br />
<br />
2) I have problems when tried to handle SIGTERM and SIGHUP myself, so I removed these from my code, don't use them unless you have a special need for this:<br />
pcntl_signal(SIGTERM, "sig_handler");<br />
pcntl_signal(SIGHUP, "sig_handler");<br />
<br />
What I do is: <br />
1. start the program, then fork to detach from the terminal (kill the parent and make the child the session leader).<br />
<br />
2. bind to address and port and start listening.<br />
<br />
3. fork $poolNum times, creating $poolNum children (this is the pool of daemons running.&nbsp; The children handle the incoming connections).<br />
<br />
4. keep the parent process running in a loop, constantly checking to see if it should create a new child.&nbsp; It will always keep $poolNum spare children ready (as long as the total pooled connections doesn't exceed $maxDaemon).&nbsp; As connections come in, more children are spawned. <br />
<br />
5. When a new connection comes in, it is handed off to the first child.&nbsp; This child then sends a SIGUSR1 signal back to the parent.&nbsp; The parent has a signal handler for SIGUSR1, which will increment the $numActive variable by one.&nbsp; The loop that is running (see 4 above) will note the increment in $numActive and automatically create a new child process to keep the process pool going.<br />
<br />
I have to post the code in the next note, the note engine on this site won't allow such a long note to be posted, but I think this code example is well worth a comment on this...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35440""></a>
  <div class="note">
   <strong class="user">schst at php dot net</strong>
   <a href="#35440" class="date">01-Sep-2003 07:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To get rid of the zombies when child processes terminate you do not have to write a lot of code that uses complex stuff like message queues.<br />
Instead you only set a signal handler:<br />
<br />
pcntl_signal(SIGCHLD, SIG_IGN);<br />
<br />
Stephan</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="33035""></a>
  <div class="note">
   <strong class="user">Patrice Levesque</strong>
   <a href="#33035" class="date">14-Jun-2003 01:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
So, you want to create multiple child processes and don't want any zombies, don't you?<br />
<br />
You can use IPC to achieve just that.&nbsp; Every child that is spawned has to tell its parent that time has come for him to be terminated.&nbsp; So, yes, zombies will be created, but once in a while the parent will 'clean up' after his kids.&nbsp; Code:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; </span><span class="keyword">declare(</span><span class="default">ticks </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// create a IPC message queue<br />
&nbsp; </span><span class="default">$msgqueue </span><span class="keyword">= </span><span class="default">msg_get_queue</span><span class="keyword">(</span><span class="default">ftok</span><span class="keyword">(</span><span class="string">"/tmp/php_msgqueue.stat"</span><span class="keyword">, </span><span class="string">'R'</span><span class="keyword">),</span><span class="default">0666 </span><span class="keyword">| </span><span class="default">IPC_CREAT</span><span class="keyword">);<br />
&nbsp; </span><span class="comment">// loop for 1000 children <br />
&nbsp; </span><span class="keyword">for (</span><span class="default">$c </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$c </span><span class="keyword">&lt; </span><span class="default">1000</span><span class="keyword">; </span><span class="default">$c</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// fork<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pcid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$pcid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; die(</span><span class="string">"Could not fork!"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; elseif (</span><span class="default">$pcid</span><span class="keyword">) { </span><span class="comment">// we are the parent, look for zombie kids and terminate 'em<br />
&nbsp;&nbsp; &nbsp;&nbsp; // look in the IPC message queue if there are any entries<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$currentqueue </span><span class="keyword">= </span><span class="default">msg_stat_queue</span><span class="keyword">(</span><span class="default">$msgqueue</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$n </span><span class="keyword">= </span><span class="default">$currentqueue</span><span class="keyword">[</span><span class="string">'msg_qnum'</span><span class="keyword">]; </span><span class="comment">// number of messages (number of kids to terminate)<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$n </span><span class="keyword">&gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"There are </span><span class="default">$n</span><span class="string"> kids to terminate.\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$n</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// pop the kid's PID from the IPC message queue<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (!</span><span class="default">msg_receive </span><span class="keyword">(</span><span class="default">$msgqueue</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">, </span><span class="default">$msg_type</span><span class="keyword">, </span><span class="default">16384</span><span class="keyword">, </span><span class="default">$msg</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$msg_error</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"MSG_RECV ERROR: </span><span class="default">$errmsg</span><span class="string"> \n"</span><span class="keyword">; </span><span class="comment">// something has gone wrong<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">}<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">pcntl_waitpid</span><span class="keyword">(</span><span class="default">$msg</span><span class="keyword">, </span><span class="default">$tmpstat</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">); </span><span class="comment">// terminate kid for real.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">};<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; };<br />
&nbsp;&nbsp; &nbsp;&nbsp; };<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else { </span><span class="comment">// we are the child!<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">if (!</span><span class="default">posix_setsid</span><span class="keyword">()) { die (</span><span class="string">"Could not detach"</span><span class="keyword">); }; </span><span class="comment">// detach<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">echo </span><span class="string">"I am child number </span><span class="default">$c</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">5</span><span class="keyword">); </span><span class="comment">// do something useful<br />
&nbsp;&nbsp; &nbsp;&nbsp; // tell dad I'm finished via IPC: send him my PID<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">if (!</span><span class="default">msg_send</span><span class="keyword">(</span><span class="default">$msgqueue</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">, </span><span class="default">posix_getpid</span><span class="keyword">(), </span><span class="default">true</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">, </span><span class="default">$errmsg</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"MSG_SEND ERROR: </span><span class="default">$errmsg</span><span class="string"> \n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; };<br />
&nbsp;&nbsp; &nbsp;&nbsp; exit(); </span><span class="comment">// become a zombie until dad kills me&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">};<br />
&nbsp; };<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25918""></a>
  <div class="note">
   <strong class="user">van[at]webfreshener[dot]com</strong>
   <a href="#25918" class="date">10-Oct-2002 07:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Forking your PHP daemon will cause it to zombie on exit.
<br />

<br />
...or so I've seen on:
<br />
FreeBSD (PHP4.2.x)
<br />
Debian (PHP4.3.0-dev)
<br />
Darwin (PHP4.3.0-dev)
<br />

<br />
This was tested with the example code above and other scripts created for evaluation.
<br />

<br />
Seems adding --enable-sigchild to your configure will get rid of the problem.
<br />

<br />
Hope that saves some hair tearing :]</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="21856""></a>
  <div class="note">
   <strong class="user">keksov[at]gmx.de</strong>
   <a href="#21856" class="date">29-May-2002 10:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You have to use socket_select before socket_accept, so your code will wait for connection with select. socket_select can be interrupted by signals easily. Below is an example from my library (methods of class TNetSocket):<br />
&nbsp; //-- select<br />
&nbsp; function select($aread=NULL,$awrite=NULL,$aexcept=NULL,$timeout=NULL)<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; while(1)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp;&nbsp; $res="";<br />
&nbsp;&nbsp; &nbsp;&nbsp; $res=socket_select($aread, $awrite, $aexcept, $timeout);<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; // if errno===0 it means what select was interrrupted by SysV signal<br />
&nbsp;&nbsp; &nbsp;&nbsp; if($res===false &amp;&amp; socket_last_error($this-&gt;socket())!==0)<br />
&nbsp;&nbsp; &nbsp;&nbsp; { // error occured, interrupted not by a signal<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $this-&gt;set_socket_error(__LINE__);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return(false);<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return(true);<br />
&nbsp; }<br />
<br />
&nbsp; //-- accept, wait for incomming connection<br />
&nbsp; function accept()<br />
&nbsp; {<br />
&nbsp;&nbsp;&nbsp; $this-&gt;clear_socket_error();<br />
&nbsp;&nbsp;&nbsp; $this-&gt;set_io_socket(_SOCKET_);<br />
<br />
&nbsp;&nbsp;&nbsp; $socket=$this-&gt;socket();<br />
&nbsp;&nbsp;&nbsp; $aread=array($socket);<br />
&nbsp;&nbsp;&nbsp; if ($this-&gt;select($a=&amp;$aread)===false)<br />
&nbsp;&nbsp; &nbsp;&nbsp; return(false);<br />
<br />
&nbsp;&nbsp;&nbsp; $child_socket=socket_accept($this-&gt;socket);<br />
&nbsp;&nbsp;&nbsp; if($child_socket &lt;= 0)<br />
&nbsp;&nbsp;&nbsp; { // error occured<br />
&nbsp;&nbsp; &nbsp;&nbsp; $this-&gt;set_socket_error(__LINE__);<br />
&nbsp;&nbsp; &nbsp;&nbsp; return(false);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; $this-&gt;child_socket=$child_socket;<br />
&nbsp;&nbsp;&nbsp; $this-&gt;sockets[_CHILD_SOCKET_]=&amp;$this-&gt;child_socket;<br />
&nbsp;&nbsp;&nbsp; $this-&gt;set_io_socket(_CHILD_SOCKET_);<br />
<br />
&nbsp;&nbsp;&nbsp; $a=&amp;$this-&gt;peername;<br />
&nbsp;&nbsp;&nbsp; $res=socket_getpeername($child_socket,$a);<br />
<br />
&nbsp;&nbsp;&nbsp; if($res &lt;= 0)<br />
&nbsp;&nbsp;&nbsp; { // error occured<br />
&nbsp;&nbsp; &nbsp;&nbsp; $this-&gt;set_socket_error(__LINE__);<br />
&nbsp;&nbsp; &nbsp;&nbsp; return(false);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; $this-&gt;get_address_and_port(_CHILD_SOCKET_);<br />
&nbsp;&nbsp;&nbsp; TLogManager::phpserv("Connection accepted. ADDRESS $this-&gt;address, PORT $this-&gt;port","net_socket",__FILE__,__LINE__);<br />
<br />
&nbsp;&nbsp;&nbsp; $this-&gt;connected=true;<br />
&nbsp;&nbsp;&nbsp; return(true); // return new object of TNetSocket type<br />
&nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19447""></a>
  <div class="note">
   <strong class="user">daniel[at]lorch.cc</strong>
   <a href="#19447" class="date">27-Feb-2002 03:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This piece of code helped me to find out what signals are being sent to my process:<br />
<br />
function sig_identify($signo) {<br />
&nbsp; switch($signo) {<br />
&nbsp;&nbsp;&nbsp; case SIGFPE:&nbsp; &nbsp; return 'SIGFPE';<br />
&nbsp;&nbsp;&nbsp; case SIGSTOP:&nbsp;&nbsp; return 'SIGSTOP';<br />
&nbsp;&nbsp;&nbsp; case SIGHUP:&nbsp; &nbsp; return 'SIGHUP';<br />
&nbsp;&nbsp;&nbsp; case SIGINT:&nbsp; &nbsp; return 'SIGINT';<br />
&nbsp;&nbsp;&nbsp; case SIGQUIT:&nbsp;&nbsp; return 'SIGQUIT';<br />
&nbsp;&nbsp;&nbsp; case SIGILL:&nbsp; &nbsp; return 'SIGILL';<br />
&nbsp;&nbsp;&nbsp; case SIGTRAP:&nbsp;&nbsp; return 'SIGTRAP';<br />
&nbsp;&nbsp;&nbsp; case SIGABRT:&nbsp;&nbsp; return 'SIGABRT';<br />
&nbsp;&nbsp;&nbsp; case SIGIOT:&nbsp; &nbsp; return 'SIGIOT';<br />
&nbsp;&nbsp;&nbsp; case SIGBUS:&nbsp; &nbsp; return 'SIGBUS';<br />
&nbsp;&nbsp;&nbsp; case SIGPOLL:&nbsp;&nbsp; return 'SIGPOLL';<br />
&nbsp;&nbsp;&nbsp; case SIGSYS:&nbsp; &nbsp; return 'SIGSYS';<br />
&nbsp;&nbsp;&nbsp; case SIGCONT:&nbsp;&nbsp; return 'SIGCONT';<br />
&nbsp;&nbsp;&nbsp; case SIGUSR1:&nbsp;&nbsp; return 'SIGUSR1';<br />
&nbsp;&nbsp;&nbsp; case SIGUSR2:&nbsp;&nbsp; return 'SIGUSR2';<br />
&nbsp;&nbsp;&nbsp; case SIGSEGV:&nbsp;&nbsp; return 'SIGSEGV';<br />
&nbsp;&nbsp;&nbsp; case SIGPIPE:&nbsp;&nbsp; return 'SIGPIPE';<br />
&nbsp;&nbsp;&nbsp; case SIGALRM:&nbsp;&nbsp; return 'SIGALRM';<br />
&nbsp;&nbsp;&nbsp; case SIGTERM:&nbsp;&nbsp; return 'SIGTERM';<br />
&nbsp;&nbsp;&nbsp; case SIGSTKFLT: return 'SIGSTKFLT';<br />
&nbsp;&nbsp;&nbsp; case SIGCHLD:&nbsp;&nbsp; return 'SIGCHLD';<br />
&nbsp;&nbsp;&nbsp; case SIGCLD:&nbsp; &nbsp; return 'SIGCLD';<br />
&nbsp;&nbsp;&nbsp; case SIGIO:&nbsp; &nbsp;&nbsp; return 'SIGIO';<br />
&nbsp;&nbsp;&nbsp; case SIGKILL:&nbsp;&nbsp; return 'SIGKILL';<br />
&nbsp;&nbsp;&nbsp; case SIGTSTP:&nbsp;&nbsp; return 'SIGTSTP';<br />
&nbsp;&nbsp;&nbsp; case SIGTTIN:&nbsp;&nbsp; return 'SIGTTIN';<br />
&nbsp;&nbsp;&nbsp; case SIGTTOU:&nbsp;&nbsp; return 'SIGTTOU';<br />
&nbsp;&nbsp;&nbsp; case SIGURG:&nbsp; &nbsp; return 'SIGURG';<br />
&nbsp;&nbsp;&nbsp; case SIGXCPU:&nbsp;&nbsp; return 'SIGXCPU';<br />
&nbsp;&nbsp;&nbsp; case SIGXFSZ:&nbsp;&nbsp; return 'SIGXFSZ';<br />
&nbsp;&nbsp;&nbsp; case SIGVTALRM: return 'SIGVTALRM';<br />
&nbsp;&nbsp;&nbsp; case SIGPROF:&nbsp;&nbsp; return 'SIGPROF';<br />
&nbsp;&nbsp;&nbsp; case SIGWINCH:&nbsp; return 'SIGWINCH';<br />
&nbsp;&nbsp;&nbsp; case SIGPWR:&nbsp; &nbsp; return 'SIGPWR';<br />
&nbsp; }<br />
}<br />
<br />
function sig_handler($signo) {<br />
&nbsp; echo "Caught " . sig_identify($signo) . " (" . $signo&nbsp; . ") on " . posix_getpid() . "\n";<br />
}<br />
<br />
pcntl_signal(SIGFPE, "sig_handler");<br />
pcntl_signal(SIGHUP, "sig_handler");<br />
// pcntl_signal(SIGINT, "sig_handler");<br />
pcntl_signal(SIGQUIT, "sig_handler");<br />
pcntl_signal(SIGILL, "sig_handler");<br />
pcntl_signal(SIGTRAP, "sig_handler");<br />
pcntl_signal(SIGABRT, "sig_handler");<br />
pcntl_signal(SIGIOT, "sig_handler");<br />
pcntl_signal(SIGBUS, "sig_handler");<br />
pcntl_signal(SIGPOLL, "sig_handler");<br />
pcntl_signal(SIGSYS, "sig_handler");<br />
pcntl_signal(SIGCONT, "sig_handler");<br />
pcntl_signal(SIGUSR1, "sig_handler");<br />
pcntl_signal(SIGUSR2, "sig_handler");<br />
pcntl_signal(SIGSEGV, "sig_handler");<br />
pcntl_signal(SIGPIPE, "sig_handler");<br />
pcntl_signal(SIGALRM, "sig_handler");<br />
pcntl_signal(SIGTERM, "sig_handler");<br />
pcntl_signal(SIGSTKFLT, "sig_handler");<br />
pcntl_signal(SIGCHLD, "sig_handler");<br />
pcntl_signal(SIGCLD, "sig_handler");<br />
pcntl_signal(SIGIO, "sig_handler");<br />
pcntl_signal(SIGTSTP, "sig_handler");<br />
pcntl_signal(SIGTTIN, "sig_handler");<br />
pcntl_signal(SIGTTOU, "sig_handler");<br />
pcntl_signal(SIGURG, "sig_handler");<br />
pcntl_signal(SIGXCPU, "sig_handler");<br />
pcntl_signal(SIGXFSZ, "sig_handler");<br />
pcntl_signal(SIGVTALRM, "sig_handler");<br />
pcntl_signal(SIGPROF, "sig_handler");<br />
pcntl_signal(SIGWINCH, "sig_handler");<br />
pcntl_signal(SIGPWR, "sig_handler");<br />
<br />
I commented out SIGNIT, as it is the signal which is sent to your process when you press CTRL-C. If you catch this signal, you must handle it properly:<br />
<br />
function sig_handler($signo) {<br />
&nbsp; switch($signo) {<br />
&nbsp;&nbsp;&nbsp; case SIGINT:<br />
&nbsp;&nbsp; &nbsp;&nbsp; // customized cleanup code<br />
&nbsp;&nbsp; &nbsp;&nbsp; exit; // now exit<br />
&nbsp;&nbsp; &nbsp;&nbsp; break;<br />
&nbsp; }<br />
}<br />
<br />
Otherwise the only possibility to stop your process is by sending a SIGKILL signal - you can do this on the shell by typing "kill -9 PID" (where -9 is the numerical value for SIGKILL).<br />
<br />
Note: You cannot add a handler (i.e. ignore signals) for SIGSTOP and SIGKILL - for obvious reasons.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
