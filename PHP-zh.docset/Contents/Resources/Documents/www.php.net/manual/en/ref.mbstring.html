<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>多字节字符串 函数</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="mbstring.php4.req.html">? PHP字符编码的要求</a></li>
      <li style="float: right;"><a href="function.mb-check-encoding.html">mb_check_encoding ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="book.mbstring.html">多字节字符串</a></li>
    <li>多字节字符串 函数</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="ref.mbstring" class="reference">
  <h1 class="title">多字节字符串 函数</h1> 

  <div class="partintro">
    <h1 class="title">参考资料</h1>
    <p class="para">
     多字节字符编码方案和他们相关的问题相当复杂，超越了本文档的范围。
     关于这些话题的更多信息请参考以下 URL 和其他资源。
     <ul class="itemizedlist">
      <li class="listitem">
       <p class="para">
        Unicode materials
       </p>
       <p class="para">
        <a href="http://www.unicode.org/" class="link external" title="Link : http://www.unicode.org/">&raquo;&nbsp;http://www.unicode.org/</a>
       </p>
      </li>
      <li class="listitem">
       <p class="para">
        Japanese/Korean/Chinese 字符信息
       </p>
       <p class="para">
        <a href="http://examples.oreilly.com/cjkvinfo/doc/cjk.inf" class="link external" title="Link : http://examples.oreilly.com/cjkvinfo/doc/cjk.inf">&raquo;&nbsp;http://examples.oreilly.com/cjkvinfo/doc/cjk.inf</a>
       </p>
      </li>
     </ul>
    </p>
  </div>

 









































































































































































































































 











































































































































































































































 <h2>Table of Contents</h2><ul class="chunklist chunklist_reference"><li><a href="function.mb-check-encoding.html">mb_check_encoding</a> &mdash; 检查字符串在指定的编码里是否有效</li><li><a href="function.mb-chr.html">mb_chr</a> &mdash; Get a specific character</li><li><a href="function.mb-convert-case.html">mb_convert_case</a> &mdash; 对字符串进行大小写转换</li><li><a href="function.mb-convert-encoding.html">mb_convert_encoding</a> &mdash; 转换字符的编码</li><li><a href="function.mb-convert-kana.html">mb_convert_kana</a> &mdash; Convert &quot;kana&quot; one from another (&quot;zen-kaku&quot;, &quot;han-kaku&quot; and more)</li><li><a href="function.mb-convert-variables.html">mb_convert_variables</a> &mdash; 转换一个或多个变量的字符编码</li><li><a href="function.mb-decode-mimeheader.html">mb_decode_mimeheader</a> &mdash; 解码 MIME 头字段中的字符串</li><li><a href="function.mb-decode-numericentity.html">mb_decode_numericentity</a> &mdash; 根据 HTML 数字字符串解码成字符</li><li><a href="function.mb-detect-encoding.html">mb_detect_encoding</a> &mdash; 检测字符的编码</li><li><a href="function.mb-detect-order.html">mb_detect_order</a> &mdash; 设置/获取 字符编码的检测顺序</li><li><a href="function.mb-encode-mimeheader.html">mb_encode_mimeheader</a> &mdash; 为 MIME 头编码字符串</li><li><a href="function.mb-encode-numericentity.html">mb_encode_numericentity</a> &mdash; Encode character to HTML numeric string reference</li><li><a href="function.mb-encoding-aliases.html">mb_encoding_aliases</a> &mdash; Get aliases of a known encoding type</li><li><a href="function.mb-ereg-match.html">mb_ereg_match</a> &mdash; Regular expression match for multibyte string</li><li><a href="function.mb-ereg-replace-callback.html">mb_ereg_replace_callback</a> &mdash; Perform a regular expression search and replace with multibyte support using a callback</li><li><a href="function.mb-ereg-replace.html">mb_ereg_replace</a> &mdash; Replace regular expression with multibyte support</li><li><a href="function.mb-ereg-search-getpos.html">mb_ereg_search_getpos</a> &mdash; Returns start point for next regular expression match</li><li><a href="function.mb-ereg-search-getregs.html">mb_ereg_search_getregs</a> &mdash; Retrieve the result from the last multibyte regular expression match</li><li><a href="function.mb-ereg-search-init.html">mb_ereg_search_init</a> &mdash; Setup string and regular expression for a multibyte regular expression match</li><li><a href="function.mb-ereg-search-pos.html">mb_ereg_search_pos</a> &mdash; Returns position and length of a matched part of the multibyte regular expression for a predefined multibyte string</li><li><a href="function.mb-ereg-search-regs.html">mb_ereg_search_regs</a> &mdash; Returns the matched part of a multibyte regular expression</li><li><a href="function.mb-ereg-search-setpos.html">mb_ereg_search_setpos</a> &mdash; Set start point of next regular expression match</li><li><a href="function.mb-ereg-search.html">mb_ereg_search</a> &mdash; Multibyte regular expression match for predefined multibyte string</li><li><a href="function.mb-ereg.html">mb_ereg</a> &mdash; Regular expression match with multibyte support</li><li><a href="function.mb-eregi-replace.html">mb_eregi_replace</a> &mdash; Replace regular expression with multibyte support ignoring case</li><li><a href="function.mb-eregi.html">mb_eregi</a> &mdash; Regular expression match ignoring case with multibyte support</li><li><a href="function.mb-get-info.html">mb_get_info</a> &mdash; 获取 mbstring 的内部设置</li><li><a href="function.mb-http-input.html">mb_http_input</a> &mdash; 检测 HTTP 输入字符编码</li><li><a href="function.mb-http-output.html">mb_http_output</a> &mdash; 设置/获取 HTTP 输出字符编码</li><li><a href="function.mb-internal-encoding.html">mb_internal_encoding</a> &mdash; 设置/获取内部字符编码</li><li><a href="function.mb-language.html">mb_language</a> &mdash; 设置/获取当前的语言</li><li><a href="function.mb-list-encodings.html">mb_list_encodings</a> &mdash; 返回所有支持编码的数组</li><li><a href="function.mb-ord.html">mb_ord</a> &mdash; Get code point of character</li><li><a href="function.mb-output-handler.html">mb_output_handler</a> &mdash; 在输出缓冲中转换字符编码的回调函数</li><li><a href="function.mb-parse-str.html">mb_parse_str</a> &mdash; 解析 GET/POST/COOKIE 数据并设置全局变量</li><li><a href="function.mb-preferred-mime-name.html">mb_preferred_mime_name</a> &mdash; 获取 MIME 字符串</li><li><a href="function.mb-regex-encoding.html">mb_regex_encoding</a> &mdash; Set/Get character encoding for multibyte regex</li><li><a href="function.mb-regex-set-options.html">mb_regex_set_options</a> &mdash; Set/Get the default options for mbregex functions</li><li><a href="function.mb-scrub.html">mb_scrub</a> &mdash; Description</li><li><a href="function.mb-send-mail.html">mb_send_mail</a> &mdash; 发送编码过的邮件</li><li><a href="function.mb-split.html">mb_split</a> &mdash; 使用正则表达式分割多字节字符串</li><li><a href="function.mb-strcut.html">mb_strcut</a> &mdash; 获取字符的一部分</li><li><a href="function.mb-strimwidth.html">mb_strimwidth</a> &mdash; 获取按指定宽度截断的字符串</li><li><a href="function.mb-stripos.html">mb_stripos</a> &mdash; 大小写不敏感地查找字符串在另一个字符串中首次出现的位置</li><li><a href="function.mb-stristr.html">mb_stristr</a> &mdash; 大小写不敏感地查找字符串在另一个字符串里的首次出现</li><li><a href="function.mb-strlen.html">mb_strlen</a> &mdash; 获取字符串的长度</li><li><a href="function.mb-strpos.html">mb_strpos</a> &mdash; 查找字符串在另一个字符串中首次出现的位置</li><li><a href="function.mb-strrchr.html">mb_strrchr</a> &mdash; 查找指定字符在另一个字符串中最后一次的出现</li><li><a href="function.mb-strrichr.html">mb_strrichr</a> &mdash; 大小写不敏感地查找指定字符在另一个字符串中最后一次的出现</li><li><a href="function.mb-strripos.html">mb_strripos</a> &mdash; 大小写不敏感地在字符串中查找一个字符串最后出现的位置</li><li><a href="function.mb-strrpos.html">mb_strrpos</a> &mdash; 查找字符串在一个字符串中最后出现的位置</li><li><a href="function.mb-strstr.html">mb_strstr</a> &mdash; 查找字符串在另一个字符串里的首次出现</li><li><a href="function.mb-strtolower.html">mb_strtolower</a> &mdash; 使字符串小写</li><li><a href="function.mb-strtoupper.html">mb_strtoupper</a> &mdash; 使字符串大写</li><li><a href="function.mb-strwidth.html">mb_strwidth</a> &mdash; 返回字符串的宽度</li><li><a href="function.mb-substitute-character.html">mb_substitute_character</a> &mdash; 设置/获取替代字符</li><li><a href="function.mb-substr-count.html">mb_substr_count</a> &mdash; 统计字符串出现的次数</li><li><a href="function.mb-substr.html">mb_substr</a> &mdash; 获取部分字符串</li></ul>
</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="123948""></a>
  <div class="note">
   <strong class="user">abidul dot rmdn at gmail dot com</strong>
   <a href="#123948" class="date">18-Jun-2019 10:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Having to migrate to MB functions can be a bit of pain if you have a big project. it took us a while at my company but then we made a small script and explained it in a small blog.<br />
https://link.medium.com/25w1LronCX<br />
<br />
which makes it really easy to migrate to mb_ functions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="122872""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#122872" class="date">23-Jun-2018 01:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
SOME multibyte encodings can safely be used in str_replace() and the like, others cannot. It's not enough to ensure that all the strings involved use the same encoding: obviously they have to, but it's not enough. It has to be the right sort of encoding.<br />
<br />
UTF-8 is one of the safe ones, because it was designed to be unambiguous about where each encoded character begins and ends in the string of bytes that makes up the encoded text. Some encodings are not safe: the last bytes of one character in a text followed by the first bytes of the next character may together make a valid character. str_replace() knows nothing about "characters", "character encodings" or "encoded text". It only knows about the string of bytes. To str_replace(), two adjacent characters with two-byte encodings just looks like a sequence of four bytes and it's not going to know it shouldn't try to match the middle two bytes.<br />
<br />
While real-world examples can be found of str_replace() mangling text, it can be illustrated by using the HTML-ENTITIES encoding. It's not one of the safe ones. All of the strings being passed to str_replace() are valid HTML-ENTITIES-encoded text so the "all inputs use the same encoding" rule is satisfied.<br />
<br />
The text is "x&lt;y". It is represented by the byte string [78 26 6c 74 3b 79]. Note that the text has three characters, but the string has six bytes.<br />
<br />
<span class="default">&lt;?php<br />
<br />
$string </span><span class="keyword">= </span><span class="string">'x&amp;lt;y'</span><span class="keyword">;<br />
</span><span class="default">mb_internal_encoding</span><span class="keyword">(</span><span class="string">'HTML-ENTITIES'</span><span class="keyword">);<br />
<br />
echo </span><span class="string">"Text length: "</span><span class="keyword">, </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">), </span><span class="string">"\tString length: "</span><span class="keyword">, </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">), </span><span class="string">" ... "</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">, </span><span class="string">"\n"</span><span class="keyword">;<br />
</span><span class="comment">// Three characters, six bytes; the text reads "x&lt;y".<br />
<br />
</span><span class="default">$newstring </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'l'</span><span class="keyword">, </span><span class="string">'g'</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br />
echo </span><span class="string">"Text length: "</span><span class="keyword">, </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$newstring</span><span class="keyword">), </span><span class="string">"\tString length: "</span><span class="keyword">, </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$newstring</span><span class="keyword">), </span><span class="string">" ... "</span><span class="keyword">, </span><span class="default">$newstring</span><span class="keyword">, </span><span class="string">"\n"</span><span class="keyword">;<br />
</span><span class="comment">// Three characters, six bytes, but now the text reads "x&gt;y"; the wrong characters have changed.<br />
<br />
</span><span class="default">$newstring </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">';'</span><span class="keyword">, </span><span class="string">':'</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br />
echo </span><span class="string">"Text length: "</span><span class="keyword">, </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$newstring</span><span class="keyword">), </span><span class="string">"\tString length: "</span><span class="keyword">, </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$newstring</span><span class="keyword">), </span><span class="string">" ... "</span><span class="keyword">, </span><span class="default">$newstring</span><span class="keyword">, </span><span class="string">"\n"</span><span class="keyword">;<br />
</span><span class="comment">// Now even the length of the text is wrong and the text is trashed.<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Even though neither 'l' nor ';' appear in the text "x&lt;y", str_replace() still found and changed bytes. In one case, it changed the text to "x&gt;y" and in the other it broke the encoding completely.<br />
<br />
One more reason to use UTF-8 if you can, I guess.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="121807""></a>
  <div class="note">
   <strong class="user">v dot r dot sanaty at gmail dot com</strong>
   <a href="#121807" class="date">29-Oct-2017 05:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The multibyte version of substr_replace function:<br />
(Inspired by roydukkey's note with some corrections)<br />
<br />
function mb_substr_replace($string, $replacement, $start, $length){<br />
&nbsp;&nbsp;&nbsp; return mb_substr($string, 0, $start).$replacement.mb_substr($string, $start+$length);<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="120332""></a>
  <div class="note">
   <strong class="user">rr_news at live dot de</strong>
   <a href="#120332" class="date">14-Dec-2016 01:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The suggestion from "mt at mediamedics dot nl" is not that bad like the down votes indicate. There is only one small bug which can be easily fixed to make it work. <br />
The head of the "for" need to be modified by replacing $i + $split_length by $i += $split_length.<br />
<br />
Here is the full working code, with additional check to verify that the method doesn't exists already:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if ( !</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'mb_str_split'</span><span class="keyword">) )<br />
{<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">mb_str_split</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$split_length </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">mb_internal_encoding</span><span class="keyword">(</span><span class="string">'UTF-8'</span><span class="keyword">); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">mb_regex_encoding</span><span class="keyword">(</span><span class="string">'UTF-8'</span><span class="keyword">);&nbsp; <br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$split_length </span><span class="keyword">= (</span><span class="default">$split_length </span><span class="keyword">&lt;= </span><span class="default">0</span><span class="keyword">) ? </span><span class="default">1 </span><span class="keyword">: </span><span class="default">$split_length</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$mb_strlen </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="string">'utf-8'</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array </span><span class="keyword">= array();<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$mb_strlen</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">$split_length</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">$split_length</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$array</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="120120""></a>
  <div class="note">
   <strong class="user">php at kamiware dot org</strong>
   <a href="#120120" class="date">05-Nov-2016 10:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
str_replace is NOT multi-bite safe.<br />
<br />
This Ukrainian word gives a bug when used in the next code: в?део<br />
<br />
$rubishcharacters='[#|\[{}\]′`≠,;.:-\\_&lt;&gt;=*+"\'?()!§$&amp;%';<br />
$searchstring='в?део';<br />
<br />
$result = str_replace(str_split($rubishcharacters), ' ', $searchstring);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115080""></a>
  <div class="note">
   <strong class="user">treilor at gmail dot com</strong>
   <a href="#115080" class="date">23-May-2014 08:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A small note for those who will follow rawsrc at gmail dot com's advice: mb_split uses regular expressions, in which case it may make sense to use built-in function mb_ereg_replace.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115050""></a>
  <div class="note">
   <strong class="user">mattr at telebody dot com</strong>
   <a href="#115050" class="date">19-May-2014 07:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A brief note on Daniel Rhodes' mb_punctuation_trim().<br />
The regular expression modifier u does not mean ungreedy, rather it means the pattern is in UTF-8 encoding. Instead the U modifier should be used to get ungreedy behavior. (I have not otherwise tested his code.)<br />
See <a href="http://php.net/manual/en/reference.pcre.pattern.modifiers.php" rel="nofollow" target="_blank">http://php.net/manual/en/reference.pcre.pattern.modifiers.php</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113569""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#113569" class="date">30-Oct-2013 11:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Yet another single-line mb_trim() function<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">mb_trim</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$trim_chars </span><span class="keyword">= </span><span class="string">'\s'</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/^['</span><span class="keyword">.</span><span class="default">$trim_chars</span><span class="keyword">.</span><span class="string">']*(?U)(.*)['</span><span class="keyword">.</span><span class="default">$trim_chars</span><span class="keyword">.</span><span class="string">']*$/u'</span><span class="keyword">, </span><span class="string">'\\1'</span><span class="keyword">,</span><span class="default">$string</span><span class="keyword">);<br />
}<br />
</span><span class="default">$string </span><span class="keyword">= </span><span class="string">'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "some text."&nbsp; &nbsp; &nbsp; '</span><span class="keyword">;<br />
echo </span><span class="default">mb_trim</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="string">'\s".'</span><span class="keyword">);<br />
</span><span class="comment">//some text<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113245""></a>
  <div class="note">
   <strong class="user">Daniel Rhodes</strong>
   <a href="#113245" class="date">17-Sep-2013 01:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a cheap and cheeky function to remove leading and trailing *punctuation* (or more specifically "non-word characters") from a UTF-8 string in whatever language. (At least it works well enough for Japanese and English.)<br />
<br />
/**<br />
&nbsp;* Trim singlebyte and multibyte punctuation from the start and end of a string<br />
&nbsp;* <br />
&nbsp;* @author Daniel Rhodes<br />
&nbsp;* @note we want the first non-word grabbing to be greedy but then<br />
&nbsp;* @note we want the dot-star grabbing (before the last non-word grabbing)<br />
&nbsp;* @note to be ungreedy<br />
&nbsp;* <br />
&nbsp;* @param string $string input string in UTF-8<br />
&nbsp;* @return string as $string but with leading and trailing punctuation removed<br />
&nbsp;*/<br />
function mb_punctuation_trim($string)<br />
{<br />
&nbsp;&nbsp;&nbsp; preg_match('/^[^\w]{0,}(.*?)[^\w]{0,}$/iu', $string, $matches); //case-'i'nsensitive and 'u'ngreedy<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(count($matches) &lt; 2)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //some strange error so just return the original input<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $string;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return $matches[1];<br />
}<br />
<br />
Hope you like it!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113238""></a>
  <div class="note">
   <strong class="user">Daniel Rhodes</strong>
   <a href="#113238" class="date">16-Sep-2013 02:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a cheap and cheeky function to remove leading and trailing *punctuation* (or more specifically "non-word characters") from a UTF-8 string in whatever language. (At least it works well enough for Japanese and English.)<br />
<br />
/**<br />
&nbsp;* Trim singlebyte and multibyte punctuation from the start and end of a string<br />
&nbsp;* <br />
&nbsp;* @author Daniel Rhodes<br />
&nbsp;* @note we want the first non-word grabbing to be greedy but then<br />
&nbsp;* @note we want the dot-star grabbing (before the last non-word grabbing)<br />
&nbsp;* @note to be ungreedy<br />
&nbsp;* <br />
&nbsp;* @param string $string input string in UTF-8<br />
&nbsp;* @return string as $string but with leading and trailing punctuation removed<br />
&nbsp;*/<br />
function mb_punctuation_trim($string)<br />
{<br />
&nbsp;&nbsp;&nbsp; preg_match('/^[^\w]{0,}(.*?)[^\w]{0,}$/iu', $string, $matches); //case-'i'nsensitive and 'u'ngreedy<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(count($matches) &lt; 2)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //some strange error so just return the original input<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $string;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return $matches[1];<br />
}<br />
<br />
Hope you like it!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113235""></a>
  <div class="note">
   <strong class="user">Daniel Rhodes</strong>
   <a href="#113235" class="date">16-Sep-2013 12:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a cheap and cheeky function to remove leading and trailing *punctuation* (or more specifically "non-word characters") from a UTF-8 string in whatever language. (At least it works well enough for Japanese and English.)<br />
<br />
/**<br />
&nbsp;* Trim singlebyte and multibyte punctuation from the start and end of a string<br />
&nbsp;* <br />
&nbsp;* @author Daniel Rhodes<br />
&nbsp;* @note we want the first non-word grabbing to be greedy but then<br />
&nbsp;* @note we want the dot-star grabbing (before the last non-word grabbing)<br />
&nbsp;* @note to be ungreedy<br />
&nbsp;* <br />
&nbsp;* @param string $string input string in UTF-8<br />
&nbsp;* @return string as $string but with leading and trailing punctuation removed<br />
&nbsp;*/<br />
function mb_punctuation_trim($string)<br />
{<br />
&nbsp;&nbsp;&nbsp; preg_match('/^[^\w]{0,}(.*?)[^\w]{0,}$/iu', $string, $matches); //case-'i'nsensitive and 'u'ngreedy<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(count($matches) &lt; 2)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //some strange error so just return the original input<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $string;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return $matches[1];<br />
}<br />
<br />
Hope you like it!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109937""></a>
  <div class="note">
   <strong class="user">deceze at gmail dot com</strong>
   <a href="#109937" class="date">04-Sep-2012 10:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that all the discussion about mb_str_replace in the comments is pretty pointless. str_replace works just fine with multibyte strings:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$string&nbsp; </span><span class="keyword">= </span><span class="string">'h字はユニコ`ド'</span><span class="keyword">;<br />
</span><span class="default">$needle&nbsp; </span><span class="keyword">= </span><span class="string">'は'</span><span class="keyword">;<br />
</span><span class="default">$replace </span><span class="keyword">= </span><span class="string">'Foo'</span><span class="keyword">;<br />
<br />
echo </span><span class="default">str_replace</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br />
</span><span class="comment">// outputs: h字Fooユニコ`ド<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
The usual problem is that the string is evaluated as binary string, meaning PHP is not aware of encodings at all. Problems arise if you are getting a value "from outside" somewhere (database, POST request) and the encoding of the needle and the haystack is not the same. That typically means the source code is not saved in the same encoding as you are receiving "from outside". Therefore the binary representations don't match and nothing happens.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="105328""></a>
  <div class="note">
   <strong class="user">rawsrc at gmail dot com</strong>
   <a href="#105328" class="date">09-Aug-2011 02:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi,<br />
<br />
For those who are looking for mb_str_replace, here's a simple function :<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$replacement</span><span class="keyword">, </span><span class="default">$haystack</span><span class="keyword">) {<br />
&nbsp;&nbsp; return </span><span class="default">implode</span><span class="keyword">(</span><span class="default">$replacement</span><span class="keyword">, </span><span class="default">mb_split</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$haystack</span><span class="keyword">));<br />
}<br />
</span><span class="default">?&gt;<br />
</span>I haven't found a simpliest way to proceed :-)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102141""></a>
  <div class="note">
   <strong class="user">efesar</strong>
   <a href="#102141" class="date">28-Jan-2011 02:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This small mb_trim function works for me. 
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">mb_trim</span><span class="keyword">( </span><span class="default">$string </span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$string </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">( </span><span class="string">"/(^\s+)|(\s+$)/us"</span><span class="keyword">, </span><span class="string">""</span><span class="keyword">, </span><span class="default">$string </span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; 
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$string</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100459""></a>
  <div class="note">
   <strong class="user">johannesponader at dontspamme dot googlemail dot co</strong>
   <a href="#100459" class="date">17-Oct-2010 09:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that when migrating code to handle UTF-8 encoding, not only the functions mentioned here are useful, but also the function htmlentities() has to be changed to htmlentities($var, ENT_COMPAT, "UTF-8") or similar. I didn't scan the manual for it, but there could be some more functions that need adjustments like this.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95192""></a>
  <div class="note">
   <strong class="user">mt at mediamedics dot nl</strong>
   <a href="#95192" class="date">17-Dec-2009 05:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A multibyte one-to-one alternative for the str_split function (<a href="http://php.net/manual/en/function.str-split.php" rel="nofollow" target="_blank">http://php.net/manual/en/function.str-split.php</a>):<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">mb_str_split</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$split_length </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">mb_internal_encoding</span><span class="keyword">(</span><span class="string">'UTF-8'</span><span class="keyword">); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">mb_regex_encoding</span><span class="keyword">(</span><span class="string">'UTF-8'</span><span class="keyword">);&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$split_length </span><span class="keyword">= (</span><span class="default">$split_length </span><span class="keyword">&lt;= </span><span class="default">0</span><span class="keyword">) ? </span><span class="default">1 </span><span class="keyword">: </span><span class="default">$split_length</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$mb_strlen </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="string">'utf-8'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array </span><span class="keyword">= array();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$mb_strlen</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$split_length</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">$split_length</span><span class="keyword">); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$array</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94356""></a>
  <div class="note">
   <strong class="user">peter AT(no spam) dezzignz dot com</strong>
   <a href="#94356" class="date">29-Oct-2009 04:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The function trim() has not failed me so far in my multibyte applications, but in case one needs a truly multibyte function, here it is. The nice thing is that the character to remove can be whitespace or any other specified character, even a multibyte character.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// multibyte string split<br />
<br />
</span><span class="keyword">function </span><span class="default">mbStringToArray </span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; if (empty(</span><span class="default">$str</span><span class="keyword">)) return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$len </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$array</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="comment">// removes $rem at both ends<br />
<br />
</span><span class="keyword">function </span><span class="default">mb_trim </span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$rem </span><span class="keyword">= </span><span class="string">' '</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; if (empty(</span><span class="default">$str</span><span class="keyword">)) return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// convert to array<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$arr </span><span class="keyword">= </span><span class="default">mbStringToArray</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$len </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// left side<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] === </span><span class="default">$rem</span><span class="keyword">) </span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// right side<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">$len</span><span class="keyword">-</span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt;= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">--) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] === </span><span class="default">$rem</span><span class="keyword">) </span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// convert to string<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">implode </span><span class="keyword">(</span><span class="string">''</span><span class="keyword">, </span><span class="default">$arr</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94220""></a>
  <div class="note">
   <strong class="user">roydukkey at roydukkey dot com</strong>
   <a href="#94220" class="date">22-Oct-2009 09:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This would be one way to create a multibyte substr_replace function
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">mb_substr_replace</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$posOpen</span><span class="keyword">, </span><span class="default">$posClose</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$posOpen</span><span class="keyword">).</span><span class="default">$replace</span><span class="keyword">.</span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">, </span><span class="default">$posClose</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; }
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91810""></a>
  <div class="note">
   <strong class="user">sakai at d4k dot net</strong>
   <a href="#91810" class="date">26-Jun-2009 05:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I hope this mb_str_replace will work for arrays.&nbsp; Please use mb_internal_encoding() beforehand, if you need to change the encoding.<br />
<br />
Thanks to marc at ermshaus dot org for the original.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if(!</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'mb_str_replace'</span><span class="keyword">)) {<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$search</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$subject</span><span class="keyword">) {<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= array();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach(</span><span class="default">$subject </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$val</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$search</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$val</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$ret</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach((array) </span><span class="default">$search </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$s </span><span class="keyword">== </span><span class="string">''</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$r </span><span class="keyword">= !</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$replace</span><span class="keyword">) ? </span><span class="default">$replace </span><span class="keyword">: (</span><span class="default">array_key_exists</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">) ? </span><span class="default">$replace</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] : </span><span class="string">''</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$s</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while(</span><span class="default">$pos </span><span class="keyword">!== </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$subject </span><span class="keyword">= </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">) . </span><span class="default">$r </span><span class="keyword">. </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$s</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$r</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$subject</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90611""></a>
  <div class="note">
   <strong class="user">mitgath at gmail dot com</strong>
   <a href="#90611" class="date">30-Apr-2009 06:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
according to:
<br />
<a href="http://bugs.php.net/bug.php?id=21317" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=21317</a>
<br />
here's missing function
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">mb_str_pad </span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">, </span><span class="default">$pad_length</span><span class="keyword">, </span><span class="default">$pad_string</span><span class="keyword">, </span><span class="default">$pad_style</span><span class="keyword">, </span><span class="default">$encoding</span><span class="keyword">=</span><span class="string">"UTF-8"</span><span class="keyword">) {
<br />
&nbsp;&nbsp; return </span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">,
<br />
</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">)-</span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">,</span><span class="default">$encoding</span><span class="keyword">)+</span><span class="default">$pad_length</span><span class="keyword">, </span><span class="default">$pad_string</span><span class="keyword">, </span><span class="default">$pad_style</span><span class="keyword">);
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87047""></a>
  <div class="note">
   <strong class="user">Ben XO</strong>
   <a href="#87047" class="date">16-Nov-2008 05:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP5 has no mb_trim(), so here's one I made. It work just as trim(), but with the added bonus of PCRE character classes (including, of course, all the useful Unicode ones such as \pZ).
<br />

<br />
Unlike other approaches that I've seen to this problem, I wanted to emulate the full functionality of trim() - in particular, the ability to customise the character list.
<br />

<br />
<span class="default">&lt;?php
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**
<br />
&nbsp;&nbsp; &nbsp; * Trim characters from either (or both) ends of a string in a way that is
<br />
&nbsp;&nbsp; &nbsp; * multibyte-friendly.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * Mostly, this behaves exactly like trim() would: for example supplying 'abc' as
<br />
&nbsp;&nbsp; &nbsp; * the charlist will trim all 'a', 'b' and 'c' chars from the string, with, of
<br />
&nbsp;&nbsp; &nbsp; * course, the added bonus that you can put unicode characters in the charlist.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * We are using a PCRE character-class to do the trimming in a unicode-aware
<br />
&nbsp;&nbsp; &nbsp; * way, so we must escape ^, \, - and ] which have special meanings here.
<br />
&nbsp;&nbsp; &nbsp; * As you would expect, a single \ in the charlist is interpretted as
<br />
&nbsp;&nbsp; &nbsp; * "trim backslashes" (and duly escaped into a double-\ ). Under most circumstances
<br />
&nbsp;&nbsp; &nbsp; * you can ignore this detail.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * As a bonus, however, we also allow PCRE special character-classes (such as '\s')
<br />
&nbsp;&nbsp; &nbsp; * because they can be extremely useful when dealing with UCS. '\pZ', for example,
<br />
&nbsp;&nbsp; &nbsp; * matches every 'separator' character defined in Unicode, including non-breaking
<br />
&nbsp;&nbsp; &nbsp; * and zero-width spaces.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * It doesn't make sense to have two or more of the same character in a character
<br />
&nbsp;&nbsp; &nbsp; * class, therefore we interpret a double \ in the character list to mean a
<br />
&nbsp;&nbsp; &nbsp; * single \ in the regex, allowing you to safely mix normal characters with PCRE
<br />
&nbsp;&nbsp; &nbsp; * special classes.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * *Be careful* when using this bonus feature, as PHP also interprets backslashes
<br />
&nbsp;&nbsp; &nbsp; * as escape characters before they are even seen by the regex. Therefore, to
<br />
&nbsp;&nbsp; &nbsp; * specify '\\s' in the regex (which will be converted to the special character
<br />
&nbsp;&nbsp; &nbsp; * class '\s' for trimming), you will usually have to put *4* backslashes in the
<br />
&nbsp;&nbsp; &nbsp; * PHP code - as you can see from the default value of $charlist.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * @param string 
<br />
&nbsp;&nbsp; &nbsp; * @param charlist list of characters to remove from the ends of this string.
<br />
&nbsp;&nbsp; &nbsp; * @param boolean trim the left?
<br />
&nbsp;&nbsp; &nbsp; * @param boolean trim the right?
<br />
&nbsp;&nbsp; &nbsp; * @return String
<br />
&nbsp;&nbsp; &nbsp; */
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">mb_trim</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$charlist</span><span class="keyword">=</span><span class="string">'\\\\s'</span><span class="keyword">, </span><span class="default">$ltrim</span><span class="keyword">=</span><span class="default">true</span><span class="keyword">, </span><span class="default">$rtrim</span><span class="keyword">=</span><span class="default">true</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$both_ends </span><span class="keyword">= </span><span class="default">$ltrim </span><span class="keyword">&amp;&amp; </span><span class="default">$rtrim</span><span class="keyword">;
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$char_class_inner </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; array( </span><span class="string">'/[\^\-\]\\\]/S'</span><span class="keyword">, </span><span class="string">'/\\\{4}/S' </span><span class="keyword">),
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; array( </span><span class="string">'\\\\\\0'</span><span class="keyword">, </span><span class="string">'\\' </span><span class="keyword">),
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$charlist
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$work_horse </span><span class="keyword">= </span><span class="string">'[' </span><span class="keyword">. </span><span class="default">$char_class_inner </span><span class="keyword">. </span><span class="string">']+'</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ltrim </span><span class="keyword">&amp;&amp; </span><span class="default">$left_pattern </span><span class="keyword">= </span><span class="string">'^' </span><span class="keyword">. </span><span class="default">$work_horse</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$rtrim </span><span class="keyword">&amp;&amp; </span><span class="default">$right_pattern </span><span class="keyword">= </span><span class="default">$work_horse </span><span class="keyword">. </span><span class="string">'$'</span><span class="keyword">;
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$both_ends</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pattern_middle </span><span class="keyword">= </span><span class="default">$left_pattern </span><span class="keyword">. </span><span class="string">'|' </span><span class="keyword">. </span><span class="default">$right_pattern</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; elseif(</span><span class="default">$ltrim</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pattern_middle </span><span class="keyword">= </span><span class="default">$left_pattern</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pattern_middle </span><span class="keyword">= </span><span class="default">$right_pattern</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/</span><span class="default">$pattern_middle</span><span class="string">/usSD"</span><span class="keyword">, </span><span class="string">''</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">) );
<br />
&nbsp;&nbsp;&nbsp; }
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="86120""></a>
  <div class="note">
   <strong class="user">marc at ermshaus dot org</strong>
   <a href="#86120" class="date">03-Oct-2008 03:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A small correction to patrick at hexane dot org's mb_str_replace function. The original function does not work as intended in case $replacement contains $needle.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$replacement</span><span class="keyword">, </span><span class="default">$haystack</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$needle_len </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$replacement_len </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$replacement</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">$needle</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">$pos </span><span class="keyword">!== </span><span class="default">false</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$haystack </span><span class="keyword">= </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">) . </span><span class="default">$replacement<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">. </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">$needle_len</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">$replacement_len</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$haystack</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84099""></a>
  <div class="note">
   <strong class="user">patrick at hexane dot org</strong>
   <a href="#84099" class="date">27-Jun-2008 08:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I wonder why there isn't a mb_str_replace().&nbsp; Here's one for now:<br />
<br />
function mb_str_replace( $needle, $replacement, $haystack ) {<br />
&nbsp; $needle_len = mb_strlen($needle);<br />
&nbsp; $pos = mb_strpos( $haystack, $needle);<br />
&nbsp; while (!($pos ===false)) {<br />
&nbsp;&nbsp;&nbsp; $front = mb_substr( $haystack, 0, $pos );<br />
&nbsp;&nbsp;&nbsp; $back&nbsp; = mb_substr( $haystack, $pos + $needle_len);<br />
&nbsp;&nbsp;&nbsp; $haystack = $front.$replacement.$back;<br />
&nbsp;&nbsp;&nbsp; $pos = mb_strpos( $haystack, $needle);<br />
&nbsp; }<br />
&nbsp; return $haystack;<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74722""></a>
  <div class="note">
   <strong class="user">chris at maedata dot com</strong>
   <a href="#74722" class="date">24-Apr-2007 09:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The opposite of what Eugene Murai wrote in a previous comment is true when importing/uploading a file. For instance, if you export an Excel spreadsheet using the Save As Unicode Text option, you can use the following to convert it to UTF-8 after uploading:<br />
<br />
//Convert file to UTF-8 in case Windows mucked it up<br />
$file = explode( "\n", mb_convert_encoding( trim( file_get_contents( $_FILES['file']['tmp_name'] ) ), 'UTF-8', 'UTF-16' ) );</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73889""></a>
  <div class="note">
   <strong class="user">mdoocy at u dot washington dot edu</strong>
   <a href="#73889" class="date">14-Mar-2007 10:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that some of the multi-byte functions run in O(n) time, rather than constant time as is the case for their single-byte equivalents. This includes any functionality requiring access at a specific index, since random access is not possible in a string whose number of bytes will not necessarily match the number of characters. Affected functions include: mb_substr(), mb_strstr(), mb_strcut(), mb_strpos(), etc.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72472""></a>
  <div class="note">
   <strong class="user">motin at demomusic dot nu</strong>
   <a href="#72472" class="date">19-Jan-2007 05:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As peter dot albertsson at spray dot se already pointed out, overloading strlen may break code that handles binary data and relies upon strlen for bytelengths. <br />
<br />
The problem occurs when a file is filled with a string using fwrite in the following manner:<br />
<br />
$len = strlen($data);<br />
fwrite($fp, $data, $len);<br />
<br />
fwrite takes amount of bytes as the third parameter, but mb_strlen returns the amount of characters in the string. Since multibyte characters are possibly more than one byte in length each - this will result in that the last characters of $data never gets written to the file. <br />
<br />
After hours of investigating why PEAR::Cache_Lite didn't work - the above is what I found. <br />
<br />
I made an attempt at using single byte functions, but it doesn't work. Posting here anyway in case it helps someone else:<br />
<br />
/**<br />
* PHP Singe byte functions simulation (non successful)<br />
* <br />
* Usage: sb_string(functionname, arg1, arg2, etc);<br />
* Example: sb_string("strlen", "tu?é?"); returns 8 (should...)<br />
*/<br />
function sb_string() {<br />
<br />
&nbsp; $arguments = func_get_args(); <br />
<br />
&nbsp; $func_overloading = ini_get("mbstring.func_overload");<br />
<br />
&nbsp; ini_set("mbstring.func_overload", 0);<br />
<br />
&nbsp; $ret = call_user_func_array(array_shift($arguments), $arguments);<br />
<br />
&nbsp; ini_set("mbstring.func_overload", $func_overloading);<br />
<br />
&nbsp; return $ret;<br />
<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70294""></a>
  <div class="note">
   <strong class="user">pdezwart .at. snocap</strong>
   <a href="#70294" class="date">10-Oct-2006 11:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are trying to emulate the UnicodeEncoding.Unicode.GetBytes() function in .NET, the encoding you want to use is: UCS-2LE</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68976""></a>
  <div class="note">
   <strong class="user">hayk at mail dot ru</strong>
   <a href="#68976" class="date">17-Aug-2006 12:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Since PHP 5.1.0 and PHP 4.4.2 there is an Armenian ArmSCII-8 (ArmSCII-8, ArmSCII8, ARMSCII-8, ARMSCII8) encoding avaliable.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68349""></a>
  <div class="note">
   <strong class="user">daniel at softel dot jp</strong>
   <a href="#68349" class="date">24-Jul-2006 04:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that although "multi-byte" hints at total internationalization, the mb_ API was designed by a Japanese person to support the Japanese language.<br />
<br />
Some of the functions, for example mb_convert_kana(), make absolutely no sense outside of a Japanese language environment.<br />
<br />
It should perhaps be considered "lucky" if the functions work with non-Japanese multi-byte languages.<br />
<br />
I don't mean any disrespect to the mb_ API because I'm using it everyday and I appreciate its usefulness, but maybe a better name would be the jp_ API.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63113""></a>
  <div class="note">
   <strong class="user">Aardvark</strong>
   <a href="#63113" class="date">13-Mar-2006 11:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Since not all hosted servces currently support the multi-byte function set, it may still be necessary to process Unicode strings using standard single byte functions.&nbsp; The function at the following link - <a href="http://www.kanolife.com/escape/2006/03/php-unicode-processing.html - shows by example how to do this.&nbsp; While this only covers UTF-8, the standard PHP function " rel="nofollow" target="_blank">http://www.kanolife.com/escape/2006/03/php-unicode-processing.html - shows by example how to do this.&nbsp; While this only covers UTF-8, the standard PHP function </a>"iconv" allows conversion into and out of UTF-8 if strings need to be input or output in other encodings.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="62787""></a>
  <div class="note">
   <strong class="user">peter kehl</strong>
   <a href="#62787" class="date">09-Mar-2006 08:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
UTF-16LE solution for CSV for Excel by Eugene Murai works well:<br />
$unicode_str_for_Excel = chr(255).chr(254).mb_convert_encoding( $utf8_str, 'UTF-16LE', 'UTF-8');<br />
<br />
However, then Excel on Mac OS X doesn't identify columns properly and its puts each whole row in its own cell. In order to fix that, use TAB "\\t" character as CSV delimiter rather than comma or colon.<br />
<br />
You may also want to use HTTP encoding header, such as<br />
header( "Content-type: application/vnd.ms-excel; charset=UTF-16LE" );</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55832""></a>
  <div class="note">
   
   <a href="#55832" class="date">14-Aug-2005 07:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
get the string octet-size, when mbstring.func_overload is set to 2 :<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">str_sizeof</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">count</span><span class="keyword">(</span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">"`.`"</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">)) - </span><span class="default">1 </span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
answering to peter albertsson, once you got your data octet-size, you can access each octet with something<br />
$string[0] ... $string[$size-1], since the [ operator doesn't complies with multibytes strings.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="53032""></a>
  <div class="note">
   <strong class="user">peter dot albertsson at spray dot se</strong>
   <a href="#53032" class="date">21-May-2005 03:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Setting mbstring.func_overload = 2 may break your applications that deal with binary data.<br />
<br />
After having set mbstring.func_overload = 2 and&nbsp; mbstring.internal_encoding = UTF-8 I can't even read a binary file and print/echo it to output without corrupting it.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51887""></a>
  <div class="note">
   <strong class="user">nzkiwi at NOSPAMmte dot biglobe dot ne dot jp</strong>
   <a href="#51887" class="date">13-Apr-2005 04:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A friend has pointed out that the entry <br />
"mbstring.http_input PHP_INI_ALL" in Table 1 on the mbstring page appears to be wrong: above Example 4 it says that "There is no way to control HTTP input character conversion from PHP script. To disable HTTP input character conversion, it has to be done in php.ini". <br />
Also the table shows the old-PHP-version defaults: <br />
;; Disable HTTP Input conversion <br />
mbstring.http_input = pass&nbsp; *BUT* (for PHP 4.3.0 or higher) <br />
;; Disable HTTP Input conversion <br />
mbstring.encoding_translation = Off</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50298""></a>
  <div class="note">
   <strong class="user">Eugene Murai</strong>
   <a href="#50298" class="date">23-Feb-2005 10:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP can input and output Unicode, but a little different from what Microsoft means: when Microsoft says "Unicode", it unexplicitly means little-endian UTF-16 with BOM(FF FE = chr(255).chr(254)), whereas PHP's "UTF-16" means big-endian with BOM. For this reason, PHP does not seem to be able to output Unicode CSV file for Microsoft Excel. Solving this problem is quite simple: just put BOM infront of UTF-16LE string.<br />
<br />
Example:<br />
<br />
$unicode_str_for_Excel = chr(255).chr(254).mb_convert_encoding( $utf8_str, 'UTF-16LE', 'UTF-8');</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
