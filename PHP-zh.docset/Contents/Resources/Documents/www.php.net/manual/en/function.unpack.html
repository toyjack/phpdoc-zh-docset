<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>Unpack data from binary string</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.uniqid.html">? uniqid</a></li>
      <li style="float: right;"><a href="function.usleep.html">usleep ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.misc.html">杂项 函数</a></li>
    <li>Unpack data from binary string</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.unpack" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">unpack</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7)</p><p class="refpurpose"><span class="refname">unpack</span> &mdash; <span class="dc-title">Unpack data from binary string</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.unpack-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>unpack</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$format</code></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$data</code></span>
   [, <span class="methodparam"><span class="type">int</span> <code class="parameter">$offset</code><span class="initializer"> = 0</span></span>
  ] ) : <span class="type">array</span></div>

  <p class="para rdfs-comment">
   Unpacks from a binary string into an array according to the given
   <code class="parameter">format</code>. 
  </p>
  <p class="para">
   The unpacked data is stored in an associative array. To
   accomplish this you have to name the different format codes and
   separate them by a slash /. If a repeater argument is present,
   then each of the array keys will have a sequence number behind
   the given name.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.unpack-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">format</code></dt>

     <dd>

      <p class="para">
       See <span class="function"><a href="function.pack.html" class="function">pack()</a></span> for an explanation of the format codes.
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">data</code></dt>

     <dd>

      <p class="para">
       The packed data.
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">offset</code></dt>

     <dd>

      <p class="para">
       The offset to begin unpacking from.
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.unpack-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   Returns an associative array containing unpacked elements of binary
   string.
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.unpack-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.2.0</td>
       <td>
        <span class="type"><a href="language.types.float.html" class="type float">float</a></span> and <span class="type"><a href="language.types.float.html" class="type double">double</a></span> types supports both Big Endian and Little Endian.
       </td>
      </tr>

      <tr>
       <td>7.1.0</td>
       <td>
        The optional <code class="parameter">offset</code> has been added.
       </td>
      </tr>

      <tr>
       <td>5.5.0</td>
       <td>
        <p class="para">
         Changes were made to bring this function into line with Perl:
        </p>
        <p class="para">
         The &quot;a&quot; code now retains trailing NULL bytes.
        </p>
        <p class="para">
         The &quot;A&quot; code now strips all trailing ASCII whitespace (spaces, tabs,
         newlines, carriage returns, and NULL bytes).
        </p>
        <p class="para">
         The &quot;Z&quot; code was added for NULL-padded strings, and removes trailing
         NULL bytes.
        </p>
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.unpack-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-4598">
    <p><strong>Example #1 <span class="function"><strong>unpack()</strong></span> example</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"cchars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>以上例程会输出：</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
Array
(
    [chars] =&gt; 4
    [int] =&gt; 160
)
</pre></div>
    </div>
   </div>
  </p>

  <p class="para">
   <div class="example" id="example-4599">
    <p><strong>Example #2 <span class="function"><strong>unpack()</strong></span> example with a repeater</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2chars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>以上例程会输出：</p></div>
     <div class="example-contents screen">
<div class="cdata"><pre>
Array
(
    [chars1] =&gt; 4
    [chars2] =&gt; 0
    [int] =&gt; 40960
)
</pre></div>
     </div>
    </div>
   </p>
  </div>


 <div class="refsect1 notes" id="refsect1-function.unpack-notes">
  <h3 class="title">注释</h3>
  <div class="caution"><strong class="caution">Caution</strong>
   <p class="para">
    Note that PHP internally stores integral values as signed. If you
    unpack a large unsigned long and it is of the same size as PHP
    internally stored values the result will be a negative number
    even though unsigned unpacking was specified.
   </p>
  </div>
  <div class="caution"><strong class="caution">Caution</strong>
   <p class="para">
    If you do not name an element, numeric indices starting from <em>1</em> are used.
    Be aware that if you have more than one unnamed element, some data is
    overwritten because the numbering restarts from <em>1</em> for each element.
   </p>
   <p class="para">
    <div class="example" id="example-4600">
     <p><strong>Example #3 <span class="function"><strong>unpack()</strong></span> example with unnamed keys</strong></p>
     <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x32\x42\x00\xa0"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2/n"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>以上例程会输出：</p></div>
     <div class="example-contents screen">
<div class="cdata"><pre>
array(2) {
  [1]=&gt;
  int(160)
  [2]=&gt;
  int(66)
}
</pre></div>
     </div>
     <div class="example-contents"><p>
      Note that the
      first value from the <em>c</em> specifier is 
      overwritten by the first value from the <em>n</em>
      specifier.
     </p></div>
    </div>
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.unpack-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.pack.html" class="function" rel="rdfs-seeAlso">pack()</a> - 将数据打包成二进制字符串</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="124664""></a>
  <div class="note">
   <strong class="user">ludwig at kni-online dot de</strong>
   <a href="#124664" class="date">30-Jan-2020 11:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Don't forget to decode user-defined-pseudo-byte-sequences before unpacking...<br />
<span class="default">&lt;?php<br />
&nbsp; $byte_code_string </span><span class="keyword">=&nbsp; </span><span class="string">'00004040'</span><span class="keyword">;<br />
&nbsp; </span><span class="default">var_dump </span><span class="keyword">( </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'f'</span><span class="keyword">, </span><span class="default">$byte_code_string </span><span class="keyword">) );<br />
</span><span class="default">?&gt;<br />
</span>Result:<br />
&nbsp; array(1) {<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; float(6.4096905560973E-10)<br />
&nbsp; }<br />
<br />
whereas<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp; $byte_code_string </span><span class="keyword">=&nbsp; </span><span class="string">'00004040'</span><span class="keyword">;<br />
&nbsp;&nbsp; </span><span class="default">var_dump </span><span class="keyword">( </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'f'</span><span class="keyword">, </span><span class="default">hex2bin </span><span class="keyword">( </span><span class="default">$byte_code_string </span><span class="keyword">) ) );<br />
</span><span class="default">?&gt;<br />
</span>Result:<br />
&nbsp; array(1) {<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; float(3)<br />
&nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="119403""></a>
  <div class="note">
   <strong class="user">stanislav dot eckert at vizson dot de</strong>
   <a href="#119403" class="date">29-May-2016 03:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A helper class to convert integer to binary strings and vice versa. Useful for writing and reading integers to / from files or sockets.<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">int_helper<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int8</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"c"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"c"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt8</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"C"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int16</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"s"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"s"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt16</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">, </span><span class="default">$endianness</span><span class="keyword">=</span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="string">"pack" </span><span class="keyword">: </span><span class="string">"unpack"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">true</span><span class="keyword">) {&nbsp; </span><span class="comment">// big-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"n"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">false</span><span class="keyword">) {&nbsp; </span><span class="comment">// little-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"v"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">null</span><span class="keyword">) {&nbsp; </span><span class="comment">// machine byte order<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"S"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">$i</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] : </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int32</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"l"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"l"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt32</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">, </span><span class="default">$endianness</span><span class="keyword">=</span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="string">"pack" </span><span class="keyword">: </span><span class="string">"unpack"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">true</span><span class="keyword">) {&nbsp; </span><span class="comment">// big-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"N"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">false</span><span class="keyword">) {&nbsp; </span><span class="comment">// little-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"V"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">null</span><span class="keyword">) {&nbsp; </span><span class="comment">// machine byte order<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">$i</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] : </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">int64</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"q"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">) : </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"q"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">)[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function </span><span class="default">uInt64</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">, </span><span class="default">$endianness</span><span class="keyword">=</span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">is_int</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="string">"pack" </span><span class="keyword">: </span><span class="string">"unpack"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">true</span><span class="keyword">) {&nbsp; </span><span class="comment">// big-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"J"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">false</span><span class="keyword">) {&nbsp; </span><span class="comment">// little-endian<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"P"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$endianness </span><span class="keyword">=== </span><span class="default">null</span><span class="keyword">) {&nbsp; </span><span class="comment">// machine byte order<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$f</span><span class="keyword">(</span><span class="string">"Q"</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) ? </span><span class="default">$i</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] : </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Usage example:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; Header</span><span class="keyword">(</span><span class="string">"Content-Type: text/plain"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; include(</span><span class="string">"int_helper.php"</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt8</span><span class="keyword">(</span><span class="default">0x6b</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// k<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt8</span><span class="keyword">(</span><span class="default">107</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// k<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt8</span><span class="keyword">(</span><span class="string">"\x6b"</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 107<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt16</span><span class="keyword">(</span><span class="default">4101</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// \x05\x10<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt16</span><span class="keyword">(</span><span class="string">"\x05\x10"</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 4101<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt16</span><span class="keyword">(</span><span class="string">"\x05\x10"</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 1296<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt32</span><span class="keyword">(</span><span class="default">2147483647</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// \xff\xff\xff\x7f<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt32</span><span class="keyword">(</span><span class="string">"\xff\xff\xff\x7f"</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 2147483647<br />
<br />
&nbsp;&nbsp;&nbsp; // Note: Test this with 64-bit build of PHP<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt64</span><span class="keyword">(</span><span class="default">9223372036854775807</span><span class="keyword">) . </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// \xff\xff\xff\xff\xff\xff\xff\x7f<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">echo </span><span class="default">int_helper</span><span class="keyword">::</span><span class="default">uInt64</span><span class="keyword">(</span><span class="string">"\xff\xff\xff\xff\xff\xff\xff\x7f"</span><span class="keyword">) . </span><span class="default">PHP_EOL </span><span class="keyword">. </span><span class="default">PHP_EOL</span><span class="keyword">;&nbsp; </span><span class="comment">// 9223372036854775807<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113359""></a>
  <div class="note">
   <strong class="user">yvan dot burrie at hotmail dot com</strong>
   <a href="#113359" class="date">01-Oct-2013 11:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a demonstration concerning the speed of unpacking files:<br />
So let's see which method is fastest between FREAD or SUBSTR?<br />
<br />
I was creating a script that could read scenario files from a game, and render a preview of its terrain. The terrain structure within each file was huge (between 100,000 - 1,000,000 blocks containing 3 bits of data each). Therefore, I spent much effort to ensure it was fast and robust.<br />
<br />
Method 1: This method retrieves the 3 bits of data found in each block. It uses the loop of widthxheight and implode+unpack+substr each block:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">for ( </span><span class="default">$Y </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$Y </span><span class="keyword">&lt; ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) ; </span><span class="default">$Y </span><span class="keyword">++ ) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">TerrainID </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">Elevation </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">Unknown </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br />
}<br />
</span><span class="comment">//The average microtime was: 2.9 sec<br />
</span><span class="default">?&gt;<br />
</span>Note that it takes even more time if you use a custom function to implement the implode+unpack+substr functions.<br />
<br />
Now... This method uses the FREAD function:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">for ( </span><span class="default">$Y </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$Y </span><span class="keyword">&lt; ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) ; </span><span class="default">$Y </span><span class="keyword">++ ) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] = </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c3' </span><span class="keyword">, </span><span class="default">fread </span><span class="keyword">( </span><span class="default">$sc </span><span class="keyword">, </span><span class="default">3 </span><span class="keyword">) ) ;<br />
}<br />
</span><span class="comment">//Average microtime was: 0.7 sec<br />
</span><span class="default">?&gt;<br />
</span>I recommend using the FREAD method instead of SUBSTR.<br />
<br />
Another test!!! This method is 10x faster than the above. This does not use the FOR loop:<br />
<span class="default">&lt;?php<br />
$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">Data </span><span class="keyword">] = </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c' </span><span class="keyword">. ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) , </span><span class="default">stream_get_contents </span><span class="keyword">( </span><span class="default">$sc </span><span class="keyword">) ) ;<br />
</span><span class="comment">//Average microtime: 0.08 - 0.05 sec<br />
</span><span class="default">?&gt;<br />
</span><br />
If you want to read files much faster, you should try to reduce the number of loops and use the unpack function to its simplest and robust method.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="110102""></a>
  <div class="note">
   <strong class="user">googlybash24 at aol dot com</strong>
   <a href="#110102" class="date">19-Sep-2012 05:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To convert big endian to little endian or to convert little endian to big endian, use the following approach as an example:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// file_get_contents() returns a binary value, unpack("V*", _ ) returns an unsigned long 32-bit little endian decimal value, but bin2hex() after that would just give the hex data in the file if alone, so instead we use:<br />
// file_get_contents(), unpack("V*", _ ), then dechex(), in that order, to get the byte-swapping effect.<br />
</span><span class="default">?&gt;<br />
</span><br />
With the logic of the approach in this example, you can discover how to swap the endian byte order as you need.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108599""></a>
  <div class="note">
   <strong class="user">kobrasrealm at gmail dot com</strong>
   <a href="#108599" class="date">09-May-2012 05:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I wrote a quick pair of functions using pack/unpack for converting between raw binary (e.g. openssl_random_pseudo_bytes() output) and hexadecimal (e.g. hash() output):<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">raw2hex</span><span class="keyword">(</span><span class="default">$raw</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$m </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">, </span><span class="default">$raw</span><span class="keyword">);<br />
&nbsp; return </span><span class="default">$m</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
}<br />
<br />
function </span><span class="default">hex2raw</span><span class="keyword">(</span><span class="default">$hex</span><span class="keyword">) { <br />
&nbsp; return </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">, </span><span class="default">$hex</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Feel free to suggest any improvements, but I thought this was worth sharing.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="106041""></a>
  <div class="note">
   <strong class="user">rogier</strong>
   <a href="#106041" class="date">05-Oct-2011 07:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
be aware of the behavior of your system that PHP resides on.
<br />

<br />
On x86, unpack MAY not yield the result you expect for UInt32
<br />

<br />
This is due to the internal nature of PHP, being that integers are internally stored as SIGNED!
<br />

<br />
For x86 systems, unpack('N', "\xff\xff\xff\xff") results in -1
<br />
For (most?) x64 systems, unpack('N', "\xff\xff\xff\xff") results in 4294967295.
<br />

<br />
This can be verified by checking the value of PHP_INT_SIZE.
<br />
If this value is 4, you have a PHP that internally stores 32-bit.
<br />
A value of 8 internally stores 64-bit.
<br />

<br />
To work around this 'problem', you can use the following code to avoid problems with unpack.
<br />
The code is for big endian order but can easily be adjusted for little endian order (also, similar code works for 64-bit integers):
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">_uint32be</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// $bin is the binary 32-bit BE string that represents the integer
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">PHP_INT_SIZE </span><span class="keyword">&lt;= </span><span class="default">4</span><span class="keyword">){
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$l</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'n*'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return (</span><span class="default">$l </span><span class="keyword">+ (</span><span class="default">$h</span><span class="keyword">*</span><span class="default">0x010000</span><span class="keyword">));
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; else{
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$int</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$int</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Do note that you *could* also use sprintf('%u', $x) to show the unsigned real value.
<br />
Also note that (at least when PHP_INT_SIZE = 4) the result WILL be a float value when the input is larger then 0x7fffffff (just check with gettype);
<br />

<br />
Hope this helps people.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103634""></a>
  <div class="note">
   <strong class="user">David Gero dave at havidave dot com</strong>
   <a href="#103634" class="date">25-Apr-2011 07:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You might find these functions useful:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">byteStr2byteArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">byteArray2byteStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"C*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
function </span><span class="default">lsbStr2ushortArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"v*"</span><span class="keyword">, </span><span class="string">"\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">ushortArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"v*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
function </span><span class="default">lsbStr2ulongArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V*"</span><span class="keyword">, </span><span class="string">"\0\0\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">ulongArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"V*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Of course, you can address byte strings as if they're arrays with numerical indexes, but the other functions are helpful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100548""></a>
  <div class="note">
   <strong class="user">zac at picolink dot net</strong>
   <a href="#100548" class="date">22-Oct-2010 08:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The documentation is clear that an integer read using an unsigned format character will still be stored as a signed integer.&nbsp; The often-cited work-around is to use sprintf('%u', $bigint) to properly display integers with the MSB set.<br />
<br />
In the case where the numeric value is more important than how it's displayed, you can still work with other large integers using intval() to "upgrade" your existing unsigned integers.<br />
<br />
I had a problem comparing 32-bit integers read from files with hard-coded constants (file signatures tend to need this).&nbsp; Here's what I did to avoid converting everything into strings:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$bigint </span><span class="keyword">= </span><span class="default">0x89504E47</span><span class="keyword">;<br />
<br />
</span><span class="default">$packed </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bigint</span><span class="keyword">);<br />
<br />
list(</span><span class="default">$unpacked</span><span class="keyword">) = </span><span class="default">array_values</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$packed</span><span class="keyword">));<br />
<br />
</span><span class="comment">//The $bigint remains an unsigned integer.<br />
//Even though their bit-wise values are identical, comparison fails.<br />
<br />
</span><span class="keyword">echo </span><span class="string">'bigint '</span><span class="keyword">,<br />
&nbsp; (</span><span class="default">$bigint </span><span class="keyword">== </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br />
&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br />
<br />
</span><span class="comment">//intval() triggers a re-interpretation of $bigint.<br />
//$bigint is internally compared as a signed integer.<br />
//Since the bit-wise value of $bigint never changes, comparison succeeds.<br />
<br />
</span><span class="keyword">echo </span><span class="string">'intval(bigint) '</span><span class="keyword">,<br />
&nbsp; (</span><span class="default">intval</span><span class="keyword">(</span><span class="default">$bigint</span><span class="keyword">) == </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br />
&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
It works, but it's a little backwards.&nbsp; If anyone has any ideas on how to "downgrade" a signed integer into an unsigned integer without using strings, that would be a valuable note to add to the documentation.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100326""></a>
  <div class="note">
   <strong class="user">Aaron Wells</strong>
   <a href="#100326" class="date">08-Oct-2010 03:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another option for converting binary data into PHP data types, is to use the Zend Framework's Zend_Io_Reader class:<br />
<a href="http://bit.ly/9zAhgz" rel="nofollow" target="_blank">http://bit.ly/9zAhgz</a><br />
<br />
There's also a Zend_Io_Writer class that does the reverse.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="97177""></a>
  <div class="note">
   <strong class="user">norwood at computer dot org</strong>
   <a href="#97177" class="date">06-Apr-2010 02:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Reading a text cell from an Excel spreadsheet returned a string with low-order embedded nulls: 0x4100 0x4200 etc. To remove the nulls, used
<br />

<br />
<span class="default">&lt;?php
<br />
$strWithoutNulls </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">( </span><span class="string">''</span><span class="keyword">, </span><span class="default">explode</span><span class="keyword">( </span><span class="string">"\0"</span><span class="keyword">, </span><span class="default">$strWithNulls </span><span class="keyword">) );
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
(unpack() didn't seem to help much here; needed chars back to re-constitute the string, not integers.)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93714""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#93714" class="date">23-Sep-2009 08:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Functions I found useful when dealing with fixed width file processing, related to unpack/pack functions.<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
* funpack<br />
* format: array of key, length pairs<br />
* data: string to unpack<br />
*/<br />
</span><span class="keyword">function </span><span class="default">funpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">trim</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos</span><span class="keyword">+= </span><span class="default">$len</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">/**<br />
* fpack<br />
* format: array of key, length pairs<br />
* data: array of key, value pairs to pack<br />
* pad: padding direction<br />
*/<br />
</span><span class="keyword">function </span><span class="default">fpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pad </span><span class="keyword">= </span><span class="default">STR_PAD_RIGHT</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">], </span><span class="default">$len</span><span class="keyword">, </span><span class="default">$pad</span><span class="keyword">), </span><span class="default">0</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92344""></a>
  <div class="note">
   <strong class="user">sica at wnet com br</strong>
   <a href="#92344" class="date">20-Jul-2009 12:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The script following is a example how to save more than one values on file separating its with "\r\n" and how to recovering its values.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// Save two integer values in a binary file<br />
</span><span class="default">$nomearq </span><span class="keyword">= </span><span class="string">"./teste.bin"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">123</span><span class="keyword">;<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"wb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"First value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
echo </span><span class="string">"Separator \\r\\n with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="string">"\r\n"</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">456</span><span class="keyword">;<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"Second value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Recover the saved values<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"rb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">file</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">,</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">));<br />
echo </span><span class="string">"&lt;br&gt;The reading values is:&lt;br&gt;"</span><span class="keyword">;<br />
foreach(</span><span class="default">$valorBin </span><span class="keyword">as </span><span class="default">$valor</span><span class="keyword">){<br />
&nbsp; </span><span class="default">$valor </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; echo </span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Results:<br />
First value (123) packed with 4 bytes<br />
Separator \r\n with 2 bytes<br />
Second value (456) packed with 4 bytes<br />
<br />
The reading values is:<br />
Array ( [1] =&gt; 123 ) <br />
Array ( [1] =&gt; 456 )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87546""></a>
  <div class="note">
   <strong class="user">jlarsen at fsu dot edu</strong>
   <a href="#87546" class="date">09-Dec-2008 03:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As with perl, the count for hex is number of nybbles or half-bytes, this differs from the other options which count in full bytes.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83349""></a>
  <div class="note">
   <strong class="user">Nhon</strong>
   <a href="#83349" class="date">21-May-2008 01:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As stated above, "if you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br />
<br />
To restore the original unsigned value, you could do this :<br />
<br />
if ($unpackedVal &lt;0)<br />
{<br />
&nbsp;&nbsp; &nbsp;&nbsp; $unpackedVal += 4294967296;<br />
}<br />
<br />
Hope this helps !<br />
<br />
Cheers</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82146""></a>
  <div class="note">
   <strong class="user">Anonymous Coward</strong>
   <a href="#82146" class="date">28-Mar-2008 10:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Warning: This unpack function makes the array with keys starting at 1 instead of starting at 0.<br />
<br />
For example:<br />
<span class="default">&lt;?php<br />
&nbsp;</span><span class="keyword">function </span><span class="default">read_field</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$a</span><span class="keyword">=</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V"</span><span class="keyword">,</span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">4</span><span class="keyword">));<br />
&nbsp; return </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br />
&nbsp;}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80972""></a>
  <div class="note">
   <strong class="user">joe dot nemeth @ palg dot com</strong>
   <a href="#80972" class="date">08-Feb-2008 10:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A simpler solution is to mask the value with 0xffffffff. For instance:<br />
<br />
<span class="default">&lt;?php<br />
$rec </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(<br />
&nbsp; </span><span class="string">"Vvalue/"</span><span class="keyword">.<br />
&nbsp; </span><span class="string">"Vhash32/"</span><span class="keyword">,<br />
&nbsp; </span><span class="default">$recbin</span><span class="keyword">);<br />
</span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'hash32'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br />
</span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'value'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Unlike sprintf(), which converts the value to a string, this preserves the numeric type of the value.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80914""></a>
  <div class="note">
   <strong class="user">Shawn Kelly</strong>
   <a href="#80914" class="date">06-Feb-2008 12:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Above it says this:<br />
<br />
&nbsp; "Note that PHP internally stores integral values as signed. If&nbsp; you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br />
<br />
This happened to me.&nbsp; I wanted to get a big number from a unsigned long, but it kept coming returning a negative.&nbsp; Happened to notice that sprintf('%u',$dta) will take the useless negative and restore it into its large unsigned proper magnitude.<br />
<br />
Hope this saves someone a little time...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57612""></a>
  <div class="note">
   <strong class="user">Justin dot SpahrSummers at gmail dot com</strong>
   <a href="#57612" class="date">08-Oct-2005 12:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I hadn't realized that if the number after the unpack type was 1 (i.e. "V1page"), that it would behave as if there was no number at all. I had been using a variable and didn't think to watch for this. For instance,<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if (</span><span class="default">$something</span><span class="keyword">)<br />
&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">2</span><span class="keyword">;<br />
else<br />
&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
<br />
</span><span class="default">$arr </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V" </span><span class="keyword">. </span><span class="default">$get </span><span class="keyword">. </span><span class="string">"page"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Now if $something was FALSE, then $arr will only have one entry named "page". If $something was TRUE, $arr would have "page1" and "page2".</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52527""></a>
  <div class="note">
   <strong class="user">info at dreystone dot com</strong>
   <a href="#52527" class="date">04-May-2005 11:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is my solution to reading a Big-Endian formatted double on an Little-Endian machine.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">ToDouble</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"S*"</span><span class="keyword">, </span><span class="default">256</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$t</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] == </span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">strrev</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return (double)</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46725""></a>
  <div class="note">
   <strong class="user">jjfoerch at earthlink dot net</strong>
   <a href="#46725" class="date">21-Oct-2004 04:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had a situation where I had to unpack a file filled with little-endian order double-floats in a way that would work on either little-endian or big-endian machines.&nbsp; PHP doesn't have a formatting code that will change the byte order of doubles, so I wrote this workaround.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/*The following code is a workaround for php's unpack function<br />
which does not have the capability of unpacking double precision<br />
floats that were packed in the opposite byte order of the current<br />
machine.<br />
*/<br />
</span><span class="keyword">function </span><span class="default">big_endian_unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar </span><span class="keyword">= </span><span class="default">unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$vals </span><span class="keyword">= </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">explode </span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$format</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$f </span><span class="keyword">as </span><span class="default">$f_k </span><span class="keyword">=&gt; </span><span class="default">$f_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">intval </span><span class="keyword">(</span><span class="default">substr </span><span class="keyword">(</span><span class="default">$f_v</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$repeater </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">) </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">1</span><span class="keyword">} == </span><span class="string">'*'</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">count </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">) - </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">0</span><span class="keyword">} != </span><span class="string">'d'</span><span class="keyword">) { </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">$repeater</span><span class="keyword">; continue; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$repeater</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$a </span><span class="keyword">= </span><span class="default">$i</span><span class="keyword">; </span><span class="default">$a </span><span class="keyword">&lt; </span><span class="default">$j</span><span class="keyword">; ++</span><span class="default">$a</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'d'</span><span class="keyword">,</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">strrev </span><span class="keyword">(</span><span class="default">$p</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list (</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'d1d'</span><span class="keyword">, </span><span class="default">$p</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ++</span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$ar </span><span class="keyword">as </span><span class="default">$ar_k </span><span class="keyword">=&gt; </span><span class="default">$ar_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar</span><span class="keyword">[</span><span class="default">$ar_k</span><span class="keyword">] = </span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$a</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; ++</span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$ar</span><span class="keyword">;<br />
}<br />
<br />
list (</span><span class="default">$endiantest</span><span class="keyword">) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'L1L'</span><span class="keyword">, </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'V'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)));<br />
if (</span><span class="default">$endiantest </span><span class="keyword">!= </span><span class="default">1</span><span class="keyword">) </span><span class="default">define </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">);<br />
if (</span><span class="default">defined </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">)) </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'big_endian_unpack'</span><span class="keyword">;<br />
else </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'unpack'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
This workaround is used like this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">foo</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; global </span><span class="default">$unpack_workaround</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bar </span><span class="keyword">= </span><span class="default">$unpack_workaround</span><span class="keyword">(</span><span class="string">'N7N/V2V/d8d'</span><span class="keyword">,</span><span class="default">$my_data</span><span class="keyword">);<br />
</span><span class="comment">//...<br />
</span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
On a little endian machine, $unpack_workaround will simply point to the function unpack.&nbsp; On a big endian machine, it will call the workaround function.<br />
<br />
Note, this solution only works for doubles.&nbsp; In my project I had no need to check for single precision floats.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45188""></a>
  <div class="note">
   <strong class="user">kennwhite dot nospam at hotmail dot com</strong>
   <a href="#45188" class="date">28-Aug-2004 12:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If having a zero-based index is useful/necessary, then instead of:<br />
<br />
$int_list = unpack("s*", $some_binary_data);<br />
<br />
&nbsp;try:<br />
<br />
$int_list = array_merge(unpack("s*", $some_binary_data));<br />
<br />
This will return a 0-based array:<br />
<br />
$int_list[0] = x<br />
$int_list[1] = y<br />
$int_list[2] = z<br />
...<br />
<br />
rather than the default 1-based array returned from unpack when no key is supplied:<br />
<br />
$int_list[1] = x<br />
$int_list[2] = y<br />
$int_list[3] = z<br />
...<br />
<br />
It's not used often, but array_merge() with only one parameter will compress a sequentially-ordered numeric-index, starting with an index of [0].</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43945""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43945" class="date">09-Jul-2004 10:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is about the last example of my previous post. For the sake of clarity, I'm including again here the example, which expands the one given in the formal documentation:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
This outputs:<br />
<br />
$array[chars1] = 65 <br />
$array[chars2] = 65 <br />
$array[int] = 65 <br />
<br />
Here, we assume that the ascii code for character 'A' is decimal 65.<br />
<br />
Remebering that the format string structure is:<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...],<br />
in this example, the format string instructs the function to<br />
&nbsp; 1. ("c2...") Read two chars from the second argument ("AA ...), <br />
&nbsp; 2. (...chars...) Use the array-keys "chars1", and "chars2" for <br />
&nbsp;&nbsp; &nbsp;&nbsp; these two chars read,<br />
&nbsp; 3. (.../n...) Read a short int from the second argument (...\0A"),<br />
&nbsp; 4. (...int") Use the word "int" as the array key for the just read<br />
&nbsp;&nbsp; &nbsp;&nbsp; short.<br />
<br />
I hope this is clearer now,<br />
<br />
Sergio.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43930""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43930" class="date">08-Jul-2004 07:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Suppose we need to get some kind of internal representation of an integer, say 65, as a four-byte long. Then we use, something like:<br />
<br />
&lt;?<br />
&nbsp; $i = 65;<br />
&nbsp; $s = pack("l", $i); // long 32 bit, machine byte order<br />
&nbsp; echo strlen($s) . "&lt;br&gt;\n";<br />
&nbsp; echo "***$s***&lt;br&gt;\n";<br />
?&gt;<br />
<br />
The output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
4<br />
***A*** <br />
<br />
(That is the string "A\0\0\0")<br />
<br />
Now we want to go back from string "A\0\0\0" to number 65. In this case we can use:<br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number 65<br />
&nbsp; $arr = unpack("l", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value&lt;br&gt;\n";<br />
?&gt;<br />
<br />
And this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[] = 65<br />
<br />
Let's give the array key a name, say "mykey". In this case, we can use: <br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number&nbsp; 65<br />
&nbsp; $arr = unpack("lmykey", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value\n";<br />
?&gt;<br />
<br />
An this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[mykey] = 65<br />
<br />
The "unpack" documentation is a little bit confusing. I think a more complete example could be:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp;&nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
whose output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$array[chars1] = 65 &lt;br&gt;<br />
$array[chars2] = 65 &lt;br&gt;<br />
$array[int] = 65 &lt;br&gt;<br />
<br />
Note that the format string is something like<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...]<br />
<br />
I hope this clarifies something<br />
<br />
Sergio</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="22398""></a>
  <div class="note">
   <strong class="user">adam at adeptsoftware dot com</strong>
   <a href="#22398" class="date">16-Jun-2002 09:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you just want to extract a dword/long int from a binary string, the following code works beautifully (intel endian):<br />
<br />
$Number = ord($Buffer{0}) | (ord($Buffer{1})&lt;&lt;8) | (ord($Buffer{2})&lt;&lt;16) | (ord($Buffer{3})&lt;&lt;24);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="12395""></a>
  <div class="note">
   <strong class="user">DanRichter.at.programmer.dot.net</strong>
   <a href="#12395" class="date">10-Apr-2001 11:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If no key name is given [e.g., unpack('C*',$data)], the keys are simply integers starting at 1, and you have a standard array. (I know of no way to get the array to start at zero.)
<br />

<br />
If you use multiple types, you must give a key name for all of them (except optionally one), because the key counter is reset with each slash. For example, in unpack('n2/C*',$data), indices 1 and 2 of the returned array are filled by integers ('n'), then overwritten with characters ('C').</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="4319""></a>
  <div class="note">
   <strong class="user">iredden at redden dot on dot ca</strong>
   <a href="#4319" class="date">11-Mar-2000 04:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php
<br />

<br />
</span><span class="keyword">function </span><span class="default">parse_pascalstr</span><span class="keyword">(</span><span class="default">$bytes_parsed</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">) { 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/cstr_len"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str_len </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str_len"</span><span class="keyword">]; 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">; 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/A"</span><span class="keyword">.</span><span class="default">$str_len</span><span class="keyword">.</span><span class="string">"str"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">); 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str"</span><span class="keyword">]; 
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">); 
<br />

<br />
&nbsp;&nbsp;&nbsp; return array(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$bytes_parsed</span><span class="keyword">); 
<br />
}
<br />

<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
