<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>打开一个到 MySQL 服务器的持久连接</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.mysql-num-rows.html">? mysql_num_rows</a></li>
      <li style="float: right;"><a href="function.mysql-ping.html">mysql_ping ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.mysql.html">MySQL 函数</a></li>
    <li>打开一个到 MySQL 服务器的持久连接</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.mysql-pconnect" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">mysql_pconnect</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">mysql_pconnect</span> &mdash; <span class="dc-title">打开一个到 MySQL 服务器的持久连接</span></p>

 </div>

 <div id="function.mysql-pconnect-refsynopsisdiv">
  <div class="warning"><strong class="warning">Warning</strong>
   <p class="para">本扩展自 PHP 5.5.0
起已废弃，并在自 PHP 7.0.0 开始被移除。应使用 <a href="book.mysqli.html" class="link">MySQLi</a>
或 <a href="ref.pdo-mysql.html" class="link">PDO_MySQL</a> 扩展来替换之。参见
<a href="mysqlinfo.api.choosing.html" class="link">MySQL：选择 API</a> 指南以及<a href="faq.databases.html#faq.databases.mysql.deprecated" class="link">相关 FAQ</a> 来获取更多信息。用以替代本函数的有：</p>
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.mysqli-connect.html" class="function">mysqli_connect()</a></span> with <code class="literal">p:</code> host prefix</li>
    <li class="member"><span class="methodname"><a href="pdo.construct.html" class="methodname">PDO::__construct()</a></span> with <strong><code>PDO::ATTR_PERSISTENT</code></strong> as a driver option</li>
   </ul>
  </div>
 </div>

 <div class="refsect1 description" id="refsect1-function.mysql-pconnect-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>mysql_pconnect</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$server</code><span class="initializer"> = ini_get(&quot;mysql.default_host&quot;)</span></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$username</code><span class="initializer"> = ini_get(&quot;mysql.default_user&quot;)</span></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$password</code><span class="initializer"> = ini_get(&quot;mysql.default_password&quot;)</span></span>
   , <span class="methodparam"><span class="type">int</span> <code class="parameter">$client_flags</code><span class="initializer"> = 0</span></span>
   ) : <span class="type">resource</span></div>

  
  <p class="para rdfs-comment">
   打开一个到 MySQL 服务器的持久连接。
  </p>
  
  <p class="para">
   <span class="function"><strong>mysql_pconnect()</strong></span> 和
   <span class="function"><a href="function.mysql-connect.html" class="function">mysql_connect()</a></span> 非常相似，但有两个主要区别。
  </p>
  <p class="para">
   首先，当连接的时候本函数将先尝试寻找一个在同一个主机上用同样的用户名和密码已经打开的（持久）连接，如果找到，则返回此连接标识而不打开新连接。
  </p>
  <p class="para">
   其次，当脚本执行完毕后到 SQL 服务器的连接不会被关闭，此连接将保持打开以备以后使用（<span class="function"><a href="function.mysql-close.html" class="function">mysql_close()</a></span>
   不会关闭由 <span class="function"><strong>mysql_pconnect()</strong></span> 建立的连接）。
  </p>
  <p class="para">
   此种连接称为"持久的"。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.mysql-pconnect-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">server</code></dt>

     <dd>

      <p class="para">
       MySQL 服务器地址，参数也可以包括端口号，例如
       "hostname:port" 或者是本机套接字的的路径，例如 ":/path/to/socket"
      </p>
      <p class="para">
       如果 PHP 配置文件中 <a href="mysql.configuration.html#ini.mysql.default-host" class="link">
       mysql.default_host</a> 的值未设置（默认情况下），则默认值为 &#039;localhost:3306&#039;
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">username</code></dt>

     <dd>

      <p class="para">
       数据库连接使用的用户名。默认为当前服务器进程的用户。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">password</code></dt>

     <dd>

      <p class="para">
       数据库连接使用的密码。默认为空密码。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">client_flags</code></dt>

     <dd>

      <p class="para">
       参数 <code class="parameter">client_flags</code> 可以为以下常量：
       128 (enable <code class="literal">LOAD DATA LOCAL</code> handling),
       <strong><code>MYSQL_CLIENT_SSL</code></strong>,
       <strong><code>MYSQL_CLIENT_COMPRESS</code></strong>,
       <strong><code>MYSQL_CLIENT_IGNORE_SPACE</code></strong> 或
       <strong><code>MYSQL_CLIENT_INTERACTIVE</code></strong>。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.mysql-pconnect-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   如果成功则返回一个正的 MySQL 持久连接标识符，出错则返回 <strong><code>false</code></strong>。
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.mysql-pconnect-changelog">
  <h3 class="title">更新日志</h3>
  <p class="para">
   <table id="function.mysql-pconnect.changelog" class="doctable informaltable">
    
     <thead>
      <tr>
       <th>版本</th>
       <th>说明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.5.0</td>
       <td>
        函数会抛出一个 <strong><code>E_DEPRECATED</code></strong> 错误。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.mysql-pconnect-notes">
  <h3 class="title">注释</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    需要注意的是，此函数仅当在 PHP 模块化运行时才会生效。更多信息请参阅
    <a href="features.persistent-connections.html" class="link">持久数据库连接</a> 章节。
   </p>
  </p></blockquote>
  <div class="warning"><strong class="warning">Warning</strong>
   <p class="para">
    使用持久连接可能需要对 Apache 和 MySQL 配置进行一些调整，以确保不超过
    MySQL 服务器允许的最大连接数。
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.mysql-pconnect-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.mysql-connect.html" class="function" rel="rdfs-seeAlso">mysql_connect()</a> - 打开一个到 MySQL 服务器的连接</span></li>
    <li class="member"><a href="features.persistent-connections.html" class="link">Persistent
    Database Connections</a></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="124103""></a>
  <div class="note">
   <strong class="user">m at louislivi dot com</strong>
   <a href="#124103" class="date">10-Aug-2019 01:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
SMProxy<br />
A MySQL database connection pool based on MySQL protocol and Swoole.<br />
https://github.com/louislivi/SMProxy</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="104266""></a>
  <div class="note">
   <strong class="user">shane</strong>
   <a href="#104266" class="date">04-Jun-2011 12:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The new mysqlnd library, which replaces the old libmysql, should make disappearing connections a thing of the past. It refreshes the connection (either change_user or ping) before trying to use it. (It also uses less memory, and generally has better performance.) I've only tried it with mysqli, but the native extension also uses it. It's available for PHP &gt;= 5.3, MySQL &gt;= 4.1.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99380""></a>
  <div class="note">
   <strong class="user">seawyvern at gmail dot com</strong>
   <a href="#99380" class="date">13-Aug-2010 12:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
(using PHP v5.3.2)<br />
This might help other people who are running into a similar issue. I would occasionally get this error in my apache error log: <br />
<br />
PHP Warning:&nbsp; mysql_pconnect(): MySQL server has gone away<br />
<br />
It appears the persistent connection mysql_pconnect() was returning had timed out and mysql_pconnect() didn't detect it. To address this issue I added some code to check for this case using mysql_ping() and request another connection from mysql_pconnect() if this situation occurred. It appears that the combination of the checking for the time out with mysql_ping( ) and re-requesting the connection with mysql_pconnect( ) either caused the original connection to re-connect or forced mysql_pconnect() to recognize that the connection had timed out and request a new one. The documentation for mysql_ping( ) says that it will force a re-connect if it detects a timeout, however comments on the documentation page mention that this feature has been disabled for some time. Anyways here is the code I used, hope it helps:<br />
<br />
$dbConnection = mysql_pconnect( $myHostname, $myUsername, $myPassword&nbsp; );<br />
<br />
if ( !mysql_ping( $dbConnection ) )<br />
{<br />
&nbsp;&nbsp; $dbConnection = mysql_pconnect( $myHostname, $myUsername, $myPassword&nbsp; );<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95342""></a>
  <div class="note">
   <strong class="user">Tom</strong>
   <a href="#95342" class="date">28-Dec-2009 05:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Persistent connections work well for CGI PHP managed by fastCGI, contrary to the suggestion above that they only work for the module version. That's because fastCGI keeps PHP processes running between requests. Persistent connections in this mode are easily made immune to connection limits too, because you can set PHP_FCGI_CHILDREN &lt;&lt; mysql's max_connections &lt;&lt;&lt; Apache's MaxClients. This also saves resources.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93760""></a>
  <div class="note">
   <strong class="user">David</strong>
   <a href="#93760" class="date">26-Sep-2009 01:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Right after I upgraded to PHP 5.3 I started getting "MySQL server has gone away" errors on almost every other page request from the apache server. I tried a few ideas that didn't work. Here is the solution: I changed all my mysql_pconnect() statements to mysql_connect(). It fixed the problem. For some reason PHP 5.3 does not like persistent connections.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85670""></a>
  <div class="note">
   <strong class="user">david at hundsness dot com</strong>
   <a href="#85670" class="date">11-Sep-2008 10:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a recap of important reasons NOT to use persistent connections:<br />
<br />
* When you lock a table, normally it is unlocked when the connection closes, but since persistent connections do not close, any tables you accidentally leave locked will remain locked, and the only way to unlock them is to wait for the connection to timeout or kill the process. The same locking problem occurs with transactions. (See comments below on 23-Apr-2002 &amp; 12-Jul-2003)<br />
<br />
* Normally temporary tables are dropped when the connection closes, but since persistent connections do not close, temporary tables aren't so temporary. If you do not explicitly drop temporary tables when you are done, that table will already exist for a new client reusing the same connection. The same problem occurs with setting session variables. (See comments below on 19-Nov-2004 &amp; 07-Aug-2006)<br />
<br />
* If PHP and MySQL are on the same server or local network, the connection time may be negligible, in which case there is no advantage to persistent connections.<br />
<br />
* Apache does not work well with persistent connections. When it receives a request from a new client, instead of using one of the available children which already has a persistent connection open, it tends to spawn a new child, which must then open a new database connection. This causes excess processes which are just sleeping, wasting resources, and causing errors when you reach your maximum connections, plus it defeats any benefit of persistent connections. (See comments below on 03-Feb-2004, and the footnote at <a href="http://devzone.zend.com/node/view/id/686#fn1" rel="nofollow" target="_blank">http://devzone.zend.com/node/view/id/686#fn1</a>)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82813""></a>
  <div class="note">
   <strong class="user">JM</strong>
   <a href="#82813" class="date">26-Apr-2008 09:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you get an error message which refers to a failure regarding /var/mysql/mysql.sock, try changing your php.ini so that mysql.default_socket=/tmp/mysql.sock</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77154""></a>
  <div class="note">
   <strong class="user">Sabyasachi Ruj</strong>
   <a href="#77154" class="date">17-Aug-2007 01:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are using mysql_pconnect(), and say the MySQL server has five persistent connection pooled for that client.<br />
<br />
Now mysql_pconnect can return any one of them.<br />
<br />
So, If you are expecting that mysql_pconnect will return always use the same persistent connection, that is not the case.<br />
<br />
So, say you are executing after connecting with mysql_pconnect:<br />
<br />
set @aa=6;<br />
<br />
And in another page you have again done mysql_pconnect, and executed:<br />
<br />
select @aa;<br />
<br />
That will not necessarily return '6' as the result!<br />
<br />
Because the second mysql_pconnect can take another persistent connection from that server's connection pool.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68690""></a>
  <div class="note">
   <strong class="user">Nils Meyer nils at weiss-bescheid dot de</strong>
   <a href="#68690" class="date">07-Aug-2006 06:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be careful when setting variables on a persistent mysql connection. Example:<br />
// Set result charset to UTF8<br />
mysql_query("SET SESSION character_set_results = 'UTF8'");<br />
<br />
If another script reuses your persistent connection, it will also use the UTF-8 charset. This created a problem with typo3 and TemplaVoila, which reads serialized data from the database. The data is returned as UTF8, but the script expects latin1 and dies with a serialize error ("Template Object could not be unserialized successfully."). This problem is especially tricky because it works on some requests and crashes on others - because the variable is not set on all connections in the persistent connection pool.<br />
<br />
A possible solution is to reset variables to their default value afterwards:<br />
$ret = mysql_query("SHOW VARIABLES LIKE 'character_set_results'"); <br />
list($foo, $old_charset) = mysql_fetch_assoc($ret);<br />
mysql_query("SET SESSION character_set_results = 'UTF8'");<br />
// do some fancy utf8 stuff<br />
// ..<br />
<br />
// revert to old encoding<br />
mysql_query("SET SESSION character_set_results = '$old_charset'");<br />
<br />
or simply use mysql_connect(), as previously stated it makes more sense in most enviroments and there are less things to bother with&nbsp;&nbsp; (like variables, transactions, temporary tables).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="66385""></a>
  <div class="note">
   <strong class="user">3ch0</strong>
   <a href="#66385" class="date">20-May-2006 02:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
pconnect is preferred when you are using a remote database server on a major web site. mysql in particular stays happier with 1 open connection as opposed to 1000 connections a minute =)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56804""></a>
  <div class="note">
   <strong class="user">Ron</strong>
   <a href="#56804" class="date">15-Sep-2005 08:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a nifty little class which will load balance across multiple replicated MySQL server instances, using persistent connections, automatically removing failed MySQL servers from the pool.<br />
<br />
You would ONLY use this for queries, never inserts/updates/deletes, UNLESS you had a multi-master situation where updates to any database serverautomatically replicate to the other servers (I don't know whether that's possible with MySQL).<br />
<br />
Using this class, you get a connection to a MySQL server like this:<br />
&nbsp;&nbsp;&nbsp; $con = MySQLConnectionFactory::create();<br />
<br />
Here is the class (you'll need to customize the $SERVERS array for your configuration -- note that you would probably use the same username, password and database for all of the servers, just changing the host name, but you're not forced to use the same ones):<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">MySQLConnectionFactory </span><span class="keyword">{<br />
&nbsp;&nbsp;&nbsp; static </span><span class="default">$SERVERS </span><span class="keyword">= array(<br />
&nbsp;&nbsp;&nbsp; array(<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'host' </span><span class="keyword">=&gt; </span><span class="string">'myHost1'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'username' </span><span class="keyword">=&gt; </span><span class="string">'myUsername1'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'password' </span><span class="keyword">=&gt; </span><span class="string">'myPassword1'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'database' </span><span class="keyword">=&gt; </span><span class="string">'myDatabase1'</span><span class="keyword">),<br />
&nbsp;&nbsp;&nbsp; array(<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'host' </span><span class="keyword">=&gt; </span><span class="string">'myHost2'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'username' </span><span class="keyword">=&gt; </span><span class="string">'myUsername1'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'password' </span><span class="keyword">=&gt; </span><span class="string">'myPassword2'</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'database' </span><span class="keyword">=&gt; </span><span class="string">'myDatabase2'</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; );<br />
<br />
&nbsp;&nbsp;&nbsp; public static function </span><span class="default">create</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Figure out which connections are open, automatically opening any connections<br />
&nbsp;&nbsp;&nbsp; // which are failed or not yet opened but can be (re)established.<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$cons </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">, </span><span class="default">$n </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">MySQLConnectionFactory</span><span class="keyword">::</span><span class="default">$SERVERS</span><span class="keyword">); </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$n</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$server </span><span class="keyword">= </span><span class="default">MySQLConnectionFactory</span><span class="keyword">::</span><span class="default">$SERVERS</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$con </span><span class="keyword">= </span><span class="default">mysql_pconnect</span><span class="keyword">(</span><span class="default">$server</span><span class="keyword">[</span><span class="string">'host'</span><span class="keyword">], </span><span class="default">$server</span><span class="keyword">[</span><span class="string">'username'</span><span class="keyword">], </span><span class="default">$server</span><span class="keyword">[</span><span class="string">'password'</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (!(</span><span class="default">$con </span><span class="keyword">=== </span><span class="default">false</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">mysql_select_db</span><span class="keyword">(</span><span class="default">$server</span><span class="keyword">[</span><span class="string">'database'</span><span class="keyword">], </span><span class="default">$con</span><span class="keyword">) === </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo(</span><span class="string">'Could not select database: ' </span><span class="keyword">. </span><span class="default">mysql_error</span><span class="keyword">());<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$cons</span><span class="keyword">[] = </span><span class="default">$con</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// If no servers are responding, throw an exception.<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$cons</span><span class="keyword">) == </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; throw new </span><span class="default">Exception<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">(</span><span class="string">'Unable to connect to any database servers - last error: ' </span><span class="keyword">. </span><span class="default">mysql_error</span><span class="keyword">());<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Pick a random connection from the list of live connections.<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$serverIdx </span><span class="keyword">= </span><span class="default">rand</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">, </span><span class="default">count</span><span class="keyword">(</span><span class="default">$cons</span><span class="keyword">)-</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$con </span><span class="keyword">= </span><span class="default">$cons</span><span class="keyword">[</span><span class="default">$serverIdx</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Return the connection.<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">$con</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="48562""></a>
  <div class="note">
   <strong class="user">tomek at 3kropki dot pl</strong>
   <a href="#48562" class="date">29-Dec-2004 09:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Instead of use wait_timeout, you can set interactive_timeout to short period of time (for ex. 20 sec.) this is a lot better solution in apache + mysql environment than wait_timeout.<br />
<br />
To know more about interactive_timeout - look to mysql documentation.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47554""></a>
  <div class="note">
   <strong class="user">federico dot chiesa at tiscali dot it</strong>
   <a href="#47554" class="date">19-Nov-2004 05:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be very careful when using persistent connections and temporary tables on MySQL: in MySQL, temporary tables are visible only to the currenct connection, but if you have a persistent connection the temporary tables will supposedly be visible to everybody sharing the same persistent connection. This can lead to major trouble. I suggest to use totally random temporary table names when using persistent connections to avoid major problems.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46913""></a>
  <div class="note">
   <strong class="user">markunderscoreconnollyatacmdotorg</strong>
   <a href="#46913" class="date">27-Oct-2004 10:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I would like to comment on the post from dfischer at qualcomm dot com that proposes spanning transactions over multiple application invocations, in case someone is bold enough to try it.<br />
<br />
I'll assume the table types being used are one of those that support transactions, such as InnoDB or BerkeleyDB.<br />
<br />
First, there is a question of whether this would work at all.&nbsp; To work at all, the transaction context would have to be preserved across all the invocations of the php code through the web server.&nbsp; Reading the description of <a href="http://www.php.net/manual/en/features.persistent-connections.php maintaining transaction context would be at best a coincidence.&nbsp; It would be interesting to find out that this does work on occasion and to understand the ramifications of such behavior.&nbsp; If I happened to get your connection and my action was a cancel, your updates might be gone. " rel="nofollow" target="_blank">http://www.php.net/manual/en/features.persistent-connections.php maintaining transaction context would be at best a coincidence.&nbsp; It would be interesting to find out that this does work on occasion and to understand the ramifications of such behavior.&nbsp; If I happened to get your connection and my action was a cancel, your updates might be gone. </a><br />
<br />
Second, if such a thing did work (occassionally or always), there would be performance implications as the underlying database managed transactions that were pretty much open-ended.&nbsp; A few long-running transactions would likely eat up many resources in a short time and the likelihood of concurrency conflicts could rise.&nbsp; If the mysql_pconnect behavior is to keep transaction open at the end of php processing, then it would probably be better to not define transactions when using mysql_pconnect. And, transactions that were never closed by code (user went out to lunch and got hit by a bus) could hold resources for quite some time (maybe until after rehab).<br />
<br />
So, even if such a scheme COULD work, it is not a good idea.&nbsp; The transaction should be committed or rolled back at the end of the user request processing.&nbsp; This allows the DBMS to properly manage resource ultilization and keeps bad things from happening to good data.&nbsp; If mysql_pconnect does not coordinate well with the transaction component of the database engine to always end a transaction at the end of processing a request, then mysql_pconnect should never be used where begin transaction is used.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43869""></a>
  <div class="note">
   <strong class="user">dfischer at qualcomm dot com</strong>
   <a href="#43869" class="date">06-Jul-2004 05:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You also may consider using pconnect if you have transactions that span multiple pages. For example, in applications that I develop, I start a transaction on the moment I query selecting the data that the user plans on editing. I then commit the transactions after the user hits the submit button and the data is committed.<br />
<br />
I cannot simply use mysql_connect as then the connection would be terminated at the end of the page and if I did not commit my transaction, it is automatically rolled back.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="40671""></a>
  <div class="note">
   <strong class="user">matt *at* roughest *dot* net</strong>
   <a href="#40671" class="date">10-Mar-2004 08:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be very careful when using persistent connections on a machine running multiple mysql servers. You must specify the correct socket path, otherwise PHP will reuse connections irregardless of what server they are connected to. That is, it will see an open connection with matching parameters and use it, even if the connection is actually for a different server.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="39599""></a>
  <div class="note">
   <strong class="user">mightye (at) mightye (dot) org</strong>
   <a href="#39599" class="date">03-Feb-2004 04:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Normally you do NOT want to use mysql_pconnect.&nbsp; This function is designed for environments which have a high overhead to connecting to the database.&nbsp; In a typical MySQL / Apache / PHP environment, Apache will create many child processes which lie in idle waiting for a web request to be assigned to them.&nbsp; Each of these child processes will open and hold its own MySQL connection.&nbsp; So if you have a MySQL server which has a limit of 50 connections, but Apache keeps more than 50 child processes running, each of these child processes can hold a connection to your MySQL server, even while they are idle (idle httpd child processes don't lend their MySQL connection to other httpd children, they hold their own).&nbsp; So even if you only have a few pages which actually connect to MySQL on a busy site, you can run out of connections, with all of them not actually being used.&nbsp; <br />
<br />
In general use mysql_connect() for connecting to MySQL unless that connection takes a long time to establish.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="39068""></a>
  <div class="note">
   <strong class="user">aaryal at foresightint dot com</strong>
   <a href="#39068" class="date">15-Jan-2004 03:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
don't use pconnect in a situation with MySQL running on one host but on multiple ports (a multiple database configuration). the connection pooling algo in php apparently only keys off of the host, username and password but not the port. therefore, if you use the same host, username and password but a different port, you might get a connection that is connected to a different port than the one you asked for.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37133""></a>
  <div class="note">
   <strong class="user">spam at vrana dot cz</strong>
   <a href="#37133" class="date">04-Nov-2003 10:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be warned if you use different parameters for mysql_pconnect() in different scripts on server: PHP can create single persistent connection for every set of parameters in each process up to mysql.max_persistent (PHP directive) per process. So even if you have MaxClients Apache directive set lesser then max_connections MySQL directive, you can easily get Too many connections MySQL error.<br />
<br />
If mysql.max_persistent is set to other value than -1 (unlimited, default value), connections over this limit are silently denied, so use it with care.<br />
<br />
Solution: For servers with potentially unlimited set of connection parameters, forbid persistent connection with mysql.allow_persistent=Off.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="34742""></a>
  <div class="note">
   <strong class="user">script_this at yahoo dot com</strong>
   <a href="#34742" class="date">05-Aug-2003 11:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
in response to uthayakutty76 at yahoo dot com's&nbsp; <br />
30-Jun-2003 12:31 post:<br />
<br />
-----------------------------------------------------------<br />
...The problem is that the connection to the MySQL <br />
servers is interrupted very quickly or there is not <br />
connection at all. We found out that when using the <br />
domain of the server instead of "localhost" problems <br />
occur.....<br />
-----------------------------------------------------------<br />
<br />
try setting the wait_timeout variable in my.cnf for <br />
mysql very high so the connections aren't ever idle for <br />
that amount of time.&nbsp; ridiculous really, but it works for <br />
localhost or remote database server where as the <br />
localhost solution only works if the database is local i <br />
think.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="34217""></a>
  <div class="note">
   <strong class="user">pulstar at mail dot com</strong>
   <a href="#34217" class="date">18-Jul-2003 11:13</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had some problems when connecting to a remote server with mysql_pconnect and using the flag MYSQL_CLIENT_COMPRESS. Sometimes it connect, but many times it give me the error:<br />
Warning: mysql_pconnect(): Unknown database 'XXXXX'<br />
<br />
If you have the same problem, try using mysql_connect instead. It worked fine for me. The script will take a long to reconnect each time the page is reloaded, but it will transfer data with compression. This is a little more secure than to send plain data over the Internet and also more faster when transmiting large amount of data.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="33994""></a>
  <div class="note">
   <strong class="user">rochlin at centralpets dot com</strong>
   <a href="#33994" class="date">12-Jul-2003 08:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Do not use transactions (e.g. with InnoDB MySQL tables) with persistent connections.&nbsp; If your script stops or exits for any reason, your transaction will be left open and your locks will be left on.&nbsp; You have to reset MySQL to release them (so far as I can figure).&nbsp;&nbsp; They won't ROLLBACK automatically on error, like they ought to.&nbsp;&nbsp; When you restart the script, you'll get a new connection, so you can't rollback or commit for the previous script.&nbsp;&nbsp; Any script with a start transaction, rollback, or commit SQL statement should use regular (not persistent) connections.&nbsp;&nbsp; Seems like PHP ought to automatically issue a ROLLBACK on any open transactions when a script exits (error or otherwise) without a COMMIT.&nbsp; ZEND's site has a brief blurb on this.&nbsp; It's OK to mix/match so you use a persistent connection for the read stuff, but open a new regular connection conditionally (if you have to update, which is usually less often).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31072""></a>
  <div class="note">
   <strong class="user">rudenko at id.com.ua</strong>
   <a href="#31072" class="date">08-Apr-2003 07:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can solve problem with persistent connections setting directive mysql.allow_persistent = Off in php configuration file. The users whitch will try to create persistant connetion /mysql_pconnect()/ will be connected to db <br />
with nonpersistant connection /mysql_connect()/<br />
<br />
For more info see user notes at section Persistant Connections. <a href="http://www.php.net/manual/en/features.persistent-connections.php" rel="nofollow" target="_blank">http://www.php.net/manual/en/features.persistent-connections.php</a><br />
--<br />
<a href="http://www.id.com.ua Ilya Rudenko" rel="nofollow" target="_blank">http://www.id.com.ua Ilya Rudenko</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30244""></a>
  <div class="note">
   <strong class="user">amn -at- frognet.net</strong>
   <a href="#30244" class="date">11-Mar-2003 10:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be careful using mysql_pconnect. If you are hosting on an ISP, they may frown upon you using multiple persistant mysql connections as this consumes resources for a longer period of time. If your script crashes, your connection can stay open for long periods of time. If there is a loop involved, you could accidently eat up all the available connections. That might be considered abuse by an ISP and you could get in trouble. Try using mysql_connect first instead. 90% of the time, a non-persistant mysql_connect call will do the trick just fine.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26416""></a>
  <div class="note">
   <strong class="user">fate_amendable_to_changeNOSPAM at yahoo dot com</strong>
   <a href="#26416" class="date">30-Oct-2002 03:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To tell mysql_pconnect to connect to mysql on a port other than the default use a colon - eg<br />
<br />
mysql_pconnect("127.0.0.1:4444", "user", "pass")<br />
<br />
would connect to localhost on port 4444 <br />
<br />
(useful for ssh tunneling etc)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="20960""></a>
  <div class="note">
   <strong class="user">david at acz dot org</strong>
   <a href="#20960" class="date">23-Apr-2002 11:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You need to be VERY careful when using LOCK TABLES with persistent connections.&nbsp; If the script terminates before the UNLOCK TABLES is executed, the the table(s) will stay locked, and very likely hang future scripts.&nbsp; This is noted in a bug report, but is still not reflected in the documentation: <a href="http://bugs.php.net/bug.php?id=7634" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=7634</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19407""></a>
  <div class="note">
   <strong class="user">bartek at bulzak dot com</strong>
   <a href="#19407" class="date">26-Feb-2002 02:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP 4.1.1 running with Apache under Linux doesn't seem to be doing all necessary flushing when handling persistant mysql connections. Try it out for yourself. Create a temporary table in a pconnect session, add rows (non unique), select/display and drop the table. Now reload your script multiple times, you will see that your results are not consistent, even though you are creating a new table everytime and dropping it.. <br />
<br />
I had my share of problems with pconnect and suggest you don't use it unless absolutely necessary. In that case make sure you test your results for consistency, especially when your queries involve temporary tables or mysql session variables.<br />
<br />
Bartek Bulzak</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="5401""></a>
  <div class="note">
   <strong class="user">sasha at mysql dot com</strong>
   <a href="#5401" class="date">27-Apr-2000 09:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need to close idle persistent connections, set a low wait_timeout in MySQL</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
