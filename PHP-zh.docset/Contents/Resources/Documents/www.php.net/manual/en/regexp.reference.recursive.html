<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>递归模式</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="regexp.reference.comments.html">? 注释</a></li>
      <li style="float: right;"><a href="regexp.reference.performance.html">性能 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="reference.pcre.pattern.syntax.html">PCRE 正则语法</a></li>
    <li>递归模式</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="regexp.reference.recursive" class="section">
  <h2 class="title">递归模式</h2>
  <p class="para">
  考虑匹配圆括号内字符串的问题，允许无限嵌套括号。如果不使用递归，
  最好的方式是使用一个模式匹配固定深度的嵌套。它不能处理任意深度的嵌套。 perl 
  5.6 提供了一个实验性的功能允许正则表达式递归。
  特殊项 (?R) 提供了递归的这种特殊用法。
  这个PCRE模式解决了圆括号问题(假设 <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_EXTENDED</a> 选项被设置了，
  因此空白字符被忽略)： <em>\(  (  (?&gt;[^()]+)  |  (?R)  )*  \)</em>。
  </p>
  <p class="para">
  首先，它匹配一个左括号。
  然后它匹配任意数量的非括号字符序列或一个模式自身的递归匹配(比如，
  一个正确的括号子串)，最终，匹配一个右括号。
  </p>
  <p class="para">
  这个例子模式包含无限重复的嵌套，因此使用了一次性子组匹配非括号字符，
  这在模式应用到模式不匹配的字符串时非常重要。比如，
  当它应用到 <em>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</em> 时就会很快的产生"不匹配"结果。
  然而，如果不使用一次性子组，这个匹配将会运行很长时间，
  因为有很多途径让 + 和 * 重复限定分隔目标字符串，
  并且在报告失败之前需要测试所有路径。
  </p>
  <p class="para">
  所有捕获子组最终被设置的捕获值都是从递归最外层子模式捕获的值。
  如果上面的模式匹配 <em>(ab(cd)ef)</em>，捕获子组最终被设置的值为 "ef"，
  即顶级得到的最后一个值。如果增加了额外的括号，<em>\(  (  (  (?&gt;[^()]+)  |  (?R)
  )*  )  \)</em>，捕获到的字符串就是顶层括号的匹配内容 "ab(cd)ef"。
  如果在模式中有超过 15 个捕获括号，
  PCRE 在递归期间就会使用 pcre_malloc 分配额外的内存来存储数据，
  随后通过 pcre_free 释放他们。如果没有内存可被分配，它就仅保存前 15 个捕获括号，
  在递归内部无法给出内存不够用的错误。
  </p>
  
  <p class="para">
  从 PHP 4.3.3 开始, <em>(?1)</em>、<em>(?2)</em> 等可以用于递归子组。这同样可以用于命名子组：
  <em>(?P&gt;name)</em> 或 <em>(?P&amp;name)</em>。
  </p>
  <p class="para">
  如果递归子组语法在它提到的子组括号外部使用(无论是子组数字序号还是子组名称)，
  这个操作就相当于程序设计语言中的子程序。
  前面一些有一个例子指出模式 <em>(sens|respons)e and \1ibility</em> 匹配 "sense and
  responsibility" 和 "response and responsibility"，但是不匹配 "sense and
  responsibility"。如果用模式 <em>(sens|respons)e and
  (?1)ibility</em> 替代，
  它会像匹配那两个字符串一样匹配 "sense and responsibility"。
  这种引用方式意义是紧接着匹配引用的子模式。(译注:
  后向引用只匹配引用的子组之前匹配的结果,
  这里的递归语法引用是拿引用的子模式重新匹配。)
  </p>
  
  <p class="para">
  目标字符串的最大长度是 int 型变量可以存储的最大正整数。然而，
  PCRE 使用递归处理子组和无限重复。
  这就是说对于某些模式可用的栈空间可能会受目标字符串限制。
  </p>
  
 </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="119691""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#119691" class="date">04-Aug-2016 09:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
sass parse sample<br />
<br />
<span class="default">&lt;?php<br />
<br />
$data </span><span class="keyword">= </span><span class="string">'a { b { 1 } c { d { 2 } } }'</span><span class="keyword">;<br />
<br />
</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/a (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br />
</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/b (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br />
</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/c (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br />
</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/d (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br />
<br />
</span><span class="comment">/*<br />
Array (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; a { b { 1 } c { d { 2 } } }<br />
&nbsp;&nbsp;&nbsp; [R] =&gt; { b { 1 } c { d { 2 } } }<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; { b { 1 } c { d { 2 } } }<br />
)<br />
Array (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; b { 1 }<br />
&nbsp;&nbsp;&nbsp; [R] =&gt; { 1 }<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; { 1 }<br />
)<br />
Array (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; c { d { 2 } }<br />
&nbsp;&nbsp;&nbsp; [R] =&gt; { d { 2 } }<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; { d { 2 } }<br />
)<br />
Array (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; d { 2 }<br />
&nbsp;&nbsp;&nbsp; [R] =&gt; { 2 }<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; { 2 }<br />
)<br />
*/</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111936""></a>
  <div class="note">
   <strong class="user">horvath at webarticum dot hu</strong>
   <a href="#111936" class="date">15-Apr-2013 12:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Below are some reusable patterns. I used comments with the 'x' modifier for human-readability.<br />
<br />
You can write also a function, that generates patterns for specified bracket/quote pairs.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">/* normal paretheses */<br />
</span><span class="default">$simple_pattern </span><span class="keyword">= </span><span class="string">"(&nbsp; &nbsp; (?#root pattern)<br />
&nbsp; (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#text or expression)<br />
&nbsp;&nbsp;&nbsp; (?&gt;[^\\(\\)]+)&nbsp; &nbsp; &nbsp; (?#text)<br />
&nbsp;&nbsp;&nbsp; |<br />
&nbsp;&nbsp;&nbsp; \\((?-2)\\)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#expression and recursion)<br />
&nbsp; )*<br />
)"</span><span class="keyword">;<br />
<br />
</span><span class="default">$simple_okay_text </span><span class="keyword">= </span><span class="string">"5( 2a + (b - c) ) - a * ( 2b - (c * 3(b - (c + a) ) ) )"</span><span class="keyword">;<br />
</span><span class="default">$simple_bad_text </span><span class="keyword">= </span><span class="string">"5( 2)a + (b - c) ) - )a * ( ((2b - (c * 3(b - (c + a) ) ) )"</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"Simple pattern results:\n"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$simple_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_okay_text</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$simple_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_bad_text</span><span class="keyword">));<br />
echo </span><span class="string">"\n----------\n"</span><span class="keyword">;<br />
<br />
</span><span class="comment">/* some brackets */<br />
</span><span class="default">$full_pattern </span><span class="keyword">= </span><span class="string">"(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (?#root pattern)<br />
&nbsp; (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#text or expression)<br />
&nbsp;&nbsp;&nbsp; (?&gt;[^\\(\\)\\{\\}\\[\\]&lt;&gt;]+)&nbsp; &nbsp; (?#text not contains brackets)<br />
&nbsp;&nbsp;&nbsp; |<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp;&nbsp; [\\(\\{\\[&lt;]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (?#start bracket)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?(?&lt;=\\()(?-3)\\)|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if normal)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?(?&lt;=\\{)(?-3)\\}|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if coursed)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?(?&lt;=\\[)(?-3)\\]|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if squared)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?1)\\&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#else so if tag)<br />
&nbsp;&nbsp; &nbsp;&nbsp; )))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#close nested-but-logically-the-some-level subpatterns)<br />
&nbsp;&nbsp;&nbsp; )<br />
&nbsp; )*<br />
)"</span><span class="keyword">;<br />
<br />
</span><span class="default">$full_okay_text </span><span class="keyword">= </span><span class="string">"5( 2a + [b - c] ) - a * ( 2b - {c * 3&lt;b - (c + a) &gt; } )"</span><span class="keyword">;<br />
</span><span class="default">$full_bad_text </span><span class="keyword">= </span><span class="string">"5[ 2a + [b - c} ) - a * ( 2b - [c * 3(b - c + a) ) ) }"</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"Full pattern results:\n"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$full_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_okay_text</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$full_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$full_okay_text</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$full_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$full_bad_text</span><span class="keyword">));<br />
echo </span><span class="string">"\n----------\n"</span><span class="keyword">;<br />
<br />
</span><span class="comment">/* some brackets and quotes */<br />
</span><span class="default">$extrafull_pattern </span><span class="keyword">= </span><span class="string">"(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#root pattern)<br />
&nbsp; (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#text or expression)<br />
&nbsp;&nbsp;&nbsp; (?&gt;[^\\(\\)\\{\\}\\[\\]&lt;&gt;'\"]+) (?#text not contains brackets and quotes)<br />
&nbsp;&nbsp;&nbsp; |<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp;&nbsp; ([\\(\\{\\[&lt;'\"])&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#start bracket)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?(?&lt;=\\()(?-4)\\)|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if normal)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?(?&lt;=\\{)(?-4)\\}|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if coursed)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?(?&lt;=\\[)(?-4)\\]|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if squared)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (?(?&lt;=\\&lt;)(?-4)\\&gt;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if tag)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ['\"]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#else so if static)<br />
&nbsp;&nbsp; &nbsp;&nbsp; ))))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (?#close nested-but-logically-the-some-level subpatterns)<br />
&nbsp;&nbsp;&nbsp; )<br />
&nbsp; )*<br />
)"</span><span class="keyword">;<br />
<br />
</span><span class="default">$extrafull_okay_text </span><span class="keyword">= </span><span class="string">"5( 2a + ['b' - c] ) - a * ( 2b - \"{c * 3&lt;b - (c + a) &gt; }\" )"</span><span class="keyword">;<br />
</span><span class="default">$extrafull_bad_text </span><span class="keyword">= </span><span class="string">"5( 2a + ['b' - c] ) - a * ( 2b - \"{c * 3&lt;b - (c + a) &gt; }\" )"</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"Extra-full pattern results:\n"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_okay_text</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$full_okay_text</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$extrafull_okay_text</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$extrafull_bad_text</span><span class="keyword">));<br />
<br />
</span><span class="comment">/*<br />
<br />
Outputs:<br />
<br />
Simple pattern results:<br />
int(0)<br />
int(0)<br />
<br />
----------<br />
Full pattern results:<br />
int(0)<br />
int(0)<br />
int(0)<br />
<br />
----------<br />
Extra-full pattern results:<br />
int(0)<br />
int(0)<br />
int(0)<br />
int(0)<br />
<br />
*/<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111935""></a>
  <div class="note">
   <strong class="user">horvath at webarticum dot hu</strong>
   <a href="#111935" class="date">15-Apr-2013 12:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
With the (?R) item you can link only to the full pattern, because it quasi equals to (?0). You can not use anchors, asserts etc., and you can only check that string CONTAINS a valid hierarchy or not.<br />
<br />
This is wrong: ^\(((?&gt;[^()]+)|(?R))*\)$<br />
<br />
However, you can bracketing the full expression, and replace (?R) to the relative link (?-2). This make it reusable. So you can check complex expressions, for example:<br />
<span class="default">&lt;?php<br />
<br />
$bracket_system </span><span class="keyword">= </span><span class="string">"(\\(((?&gt;[^()]+)|(?-2))*\\))"</span><span class="keyword">; </span><span class="comment">// (reuseable)<br />
</span><span class="default">$bracket_systems </span><span class="keyword">= </span><span class="string">"((?&gt;[^()]+)?</span><span class="default">$bracket_system</span><span class="string">)*(?&gt;[^()]+)?"</span><span class="keyword">; </span><span class="comment">// (reuseable)<br />
</span><span class="default">$equation </span><span class="keyword">= </span><span class="string">"</span><span class="default">$bracket_systems</span><span class="string">=</span><span class="default">$bracket_systems</span><span class="string">"</span><span class="keyword">; </span><span class="comment">// Both side of the equation must be contain valid bracket systems<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$equation</span><span class="string">\$/"</span><span class="keyword">,</span><span class="string">"a*(a-(2a+2))=4(a+3)-2(a-(a-2))"</span><span class="keyword">)); </span><span class="comment">// Outputs 'int(1)'<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$equation</span><span class="string">\$/"</span><span class="keyword">,</span><span class="string">"a*(a-(2a+2)=4(a+3)-2(a-(a-2)))"</span><span class="keyword">)); </span><span class="comment">// Outputs 'int(0)'<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
You can also catch multibyte quotes with the 'u' modifier (if you use UTF-8), eg:<br />
<span class="default">&lt;?php<br />
<br />
$quoted </span><span class="keyword">= </span><span class="string">"(?((?&gt;[^??]+)|(?-2))*?)"</span><span class="keyword">; </span><span class="comment">// (reuseable)<br />
</span><span class="default">$prompt </span><span class="keyword">= </span><span class="string">"[\\w ]+: </span><span class="default">$quoted</span><span class="string">"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$prompt</span><span class="string">\$/u"</span><span class="keyword">,</span><span class="string">"Your name: ?write here?"</span><span class="keyword">)); </span><span class="comment">// Outputs 'int(1)'<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108927""></a>
  <div class="note">
   <strong class="user">Daniel Klein</strong>
   <a href="#108927" class="date">06-Jun-2012 04:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The order of non-mutually exclusive alternatives within a recursed sub-pattern is important.<br />
<span class="default">&lt;?php<br />
$pattern </span><span class="keyword">= </span><span class="string">'/^(?&lt;octet&gt;[01]?\d?\d|2[0-4]\d|25[0-5])(?:\.(?P&gt;octet)){3}$/'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
You might expect that this pattern will match any IP address in dotted-decimal notation (e.g. '123.45.67.89'). The pattern is intended to match four octets in the following ranges: 0-9, 00-99 &amp; 000-255, each separated by a single dot. However, only the first octet can include values from 200-255; the remainder can only have values less than 200. The reason for this is that if the rest of the pattern fails, recursion is not back-tracked into to find an alternative match. The first part of the sub-pattern will match the first two digits of any octet from 200-255. The rest of the pattern will then fail because the third digit in the octet does not match either '\.' or '$'.<br />
<br />
<span class="default">&lt;?php<br />
var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.67'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br />
</span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.200.45.67'</span><span class="keyword">)); </span><span class="comment">// 0 (false)<br />
</span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.200'</span><span class="keyword">)); </span><span class="comment">// 0 (false)<br />
</span><span class="default">?&gt;<br />
</span><br />
The correct pattern is:<br />
<span class="default">&lt;?php<br />
$pattern </span><span class="keyword">= </span><span class="string">'/^(?&lt;octet&gt;25[0-5]|2[0-4]\d|[01]?\d?\d)(?:\.(?P&gt;octet)){3}$/'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Note that the first two alternatives are mutually exclusive so their order is unimportant. The third alternative, however, is not mutually exclusive but it will now only match when the first two fail.<br />
<br />
<span class="default">&lt;?php<br />
var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.67'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br />
</span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.200.45.67'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br />
</span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.200'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102748""></a>
  <div class="note">
   <strong class="user">Onyxagargaryll</strong>
   <a href="#102748" class="date">03-Mar-2011 04:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's an approach to create a multidimensional array according to a string's delimiters, i.e. we want to analyze...<br />
<br />
"some text (aaa(b(c1)(c2)d)e)(test) more text"<br />
<br />
... as multidimensional layers.<br />
<br />
<span class="default">&lt;?php<br />
$string </span><span class="keyword">= </span><span class="string">"some text (aaa(b(c1)(c2)d)e)(test) more text"</span><span class="keyword">;<br />
<br />
</span><span class="comment">/*<br />
&nbsp;* Analyses the string multidimensionally by its opening and closing delimiters<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">recursiveSplit</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$layer</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">"/\((([^()]*|(?R))*)\)/"</span><span class="keyword">,</span><span class="default">$string</span><span class="keyword">,</span><span class="default">$matches</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// iterate thru matches and continue recursive split<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">) &gt; </span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">count</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]); </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">is_string</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">])) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">]) &gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"&lt;pre&gt;Layer "</span><span class="keyword">.</span><span class="default">$layer</span><span class="keyword">.</span><span class="string">":&nbsp;&nbsp; "</span><span class="keyword">.</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">].</span><span class="string">"&lt;/pre&gt;&lt;br /&gt;"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">recursiveSplit</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">], </span><span class="default">$layer </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
</span><span class="default">recursiveSplit</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">);<br />
<br />
</span><span class="comment">/*<br />
<br />
Output:<br />
<br />
Layer 0:&nbsp;&nbsp; aaa(b(c1)(c2)d)e<br />
<br />
Layer 1:&nbsp;&nbsp; b(c1)(c2)d<br />
<br />
Layer 2:&nbsp;&nbsp; c1<br />
<br />
Layer 2:&nbsp;&nbsp; c2<br />
<br />
Layer 0:&nbsp;&nbsp; test<br />
*/<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101523""></a>
  <div class="note">
   <strong class="user">jonah at nucleussystems dot com</strong>
   <a href="#101523" class="date">21-Dec-2010 06:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
An unexpected behavior came up that introduced a very hard-to-track bug in some code I was working on.&nbsp; It has to do with the preg_match_all PREG_OFFSET_CAPTURE flag.&nbsp; When you capture the offset of a sub-match, it's offset is given _relative_ to it's parent.&nbsp; For example, if you extract the value between &lt; and &gt; recursively in this string:<br />
<br />
&lt;this is a &lt;string&gt;&gt;<br />
<br />
You will get an array that looks like this:<br />
<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; Array<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; &lt;this is a &lt;string&gt;&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; 0<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; this is a &lt;string&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; 1<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
&nbsp;&nbsp;&nbsp; )<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; Array<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; &lt;string&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; 0<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; string<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; 1<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
&nbsp;&nbsp;&nbsp; )<br />
)<br />
<br />
Notice that the offset in the last index is one, not the twelve we expected.&nbsp; The best way to solve this problem is to run over the results with a recursive function, adding the parent's offset.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95568""></a>
  <div class="note">
   <strong class="user">emanueledelgrande at email dot it</strong>
   <a href="#95568" class="date">09-Jan-2010 03:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The recursion in regular expressions is the only way to allow the parsing of HTML code with nested tags of indefinite depth.<br />
It seems it's not yet a spreaded practice; not so much contents are available on the web regarding regexp recursion, and until now no user contribute notes have been published on this manual page.<br />
I made several tests with complex patterns to get tags with specific attributes or namespaces, studying the recursion of a subpattern only instead of the full pattern.<br />
Here's an example that may power a fast LL parser with recursive descent (<a href="http://en.wikipedia.org/wiki/Recursive_descent_parser" rel="nofollow" target="_blank">http://en.wikipedia.org/wiki/Recursive_descent_parser</a>):<br />
<br />
$pattern = "/&lt;([\w]+)([^&gt;]*?) (([\s]*\/&gt;)| (&gt;((([^&lt;]*?|&lt;\!\-\-.*?\-\-&gt;)| (?R))*)&lt;\/\\1[\s]*&gt;))/xsm";<br />
<br />
The performances of a preg_match or preg_match_all function call over an avarage (x)HTML document are quite fast and may drive you to chose this way instead of classic DOM object methods, which have a lot of limits and are usually poor in performance with their workarounds, too.<br />
I post a sample application in a brief function (easy to be turned into OOP), which returns an array of objects:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// test function:<br />
</span><span class="keyword">function </span><span class="default">parse</span><span class="keyword">(</span><span class="default">$html</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// I have split the pattern in two lines not to have long lines alerts by the PHP.net form:<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pattern </span><span class="keyword">= </span><span class="string">"/&lt;([\w]+)([^&gt;]*?)(([\s]*\/&gt;)|"</span><span class="keyword">.<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"(&gt;((([^&lt;]*?|&lt;\!\-\-.*?\-\-&gt;)|(?R))*)&lt;\/\\1[\s]*&gt;))/sm"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="default">$html</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">, </span><span class="default">PREG_OFFSET_CAPTURE</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$elements </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">] as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$match</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$elements</span><span class="keyword">[] = (object)array(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'node' </span><span class="keyword">=&gt; </span><span class="default">$match</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">],<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'offset' </span><span class="keyword">=&gt; </span><span class="default">$match</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">],<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'tagname' </span><span class="keyword">=&gt; </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">],<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'attributes' </span><span class="keyword">=&gt; isset(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]) ? </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">] : </span><span class="string">''</span><span class="keyword">,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'omittag' </span><span class="keyword">=&gt; (</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">4</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">1</span><span class="keyword">] &gt; -</span><span class="default">1</span><span class="keyword">), </span><span class="comment">// boolean<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'inner_html' </span><span class="keyword">=&gt; isset(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">6</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]) ? </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">6</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">] : </span><span class="string">''<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$elements</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">// random html nodes as example:<br />
</span><span class="default">$html </span><span class="keyword">= &lt;&lt;&lt;EOD<br />
</span><span class="string">&lt;div id="airport"&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;div geo:position="1.234324,3.455546" class="index"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;!-- comment test:<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;div class="index_top" /&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; --&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;div class="element decorator"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;ul class="lister"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;li onclick="javascript:item.showAttribute('desc');"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;h3 class="outline"&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;a href="<a href="http://php.net/manual/en/regexp.reference.recursive.php" rel="nofollow" target="_blank">http://php.net/manual/en/regexp.reference.recursive.php</a>" onclick="openPopup()"&gt;Link&lt;/a&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;/h3&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;div class="description"&gt;Sample description&lt;/div&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;/li&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;/ul&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;/div&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;div class="clean-line"&gt;&lt;/div&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br />
&lt;/div&gt;<br />
&lt;div id="omittag_test" rel="rootChild" /&gt;<br />
</span><span class="keyword">EOD;<br />
<br />
</span><span class="comment">// application:<br />
</span><span class="default">$elements </span><span class="keyword">= </span><span class="default">parse</span><span class="keyword">(</span><span class="default">$html</span><span class="keyword">);<br />
<br />
if (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$elements</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"Elements found: &lt;b&gt;"</span><span class="keyword">.</span><span class="default">count</span><span class="keyword">(</span><span class="default">$elements</span><span class="keyword">).</span><span class="string">"&lt;/b&gt;&lt;br /&gt;"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$elements </span><span class="keyword">as </span><span class="default">$element</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"&lt;p&gt;Tpl node: &lt;pre&gt;"</span><span class="keyword">.</span><span class="default">htmlentities</span><span class="keyword">(</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">node</span><span class="keyword">).</span><span class="string">"&lt;/pre&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Tagname: &lt;tt&gt;"</span><span class="keyword">.</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">tagname</span><span class="keyword">.</span><span class="string">"&lt;/tt&gt;&lt;br /&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Attributes: &lt;tt&gt;"</span><span class="keyword">.</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">attributes</span><span class="keyword">.</span><span class="string">"&lt;/tt&gt;&lt;br /&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Omittag: &lt;tt&gt;"</span><span class="keyword">.(</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">omittag </span><span class="keyword">? </span><span class="string">'true' </span><span class="keyword">: </span><span class="string">'false'</span><span class="keyword">).</span><span class="string">"&lt;/tt&gt;&lt;br /&gt;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Inner HTML: &lt;pre&gt;"</span><span class="keyword">.</span><span class="default">htmlentities</span><span class="keyword">(</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">inner_html</span><span class="keyword">).</span><span class="string">"&lt;/pre&gt;&lt;/p&gt;"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
