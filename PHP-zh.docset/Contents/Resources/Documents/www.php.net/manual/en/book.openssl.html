<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>OpenSSL</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.mhash.html">? mhash</a></li>
      <li style="float: right;"><a href="intro.openssl.html">简介 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="refs.crypto.html">加密扩展</a></li>
    <li>OpenSSL</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="book.openssl" class="book">
 
 <h1 class="title">OpenSSL</h1>
 
 
 
 
 
 









 









 









 




 




 










<ul class="chunklist chunklist_book"><li><a href="intro.openssl.html">简介</a></li><li><a href="openssl.setup.html">安装／配置</a><ul class="chunklist chunklist_book chunklist_children"><li><a href="openssl.requirements.html">需求</a></li><li><a href="openssl.installation.html">安装</a></li><li><a href="openssl.configuration.html">运行时配置</a></li><li><a href="openssl.resources.html">资源类型</a></li></ul></li><li><a href="openssl.constants.html">预定义常量</a><ul class="chunklist chunklist_book chunklist_children"><li><a href="openssl.purpose-check.html">目的检查标志</a></li><li><a href="openssl.padding.html">非对称加密的填充标志</a></li><li><a href="openssl.key-types.html">密钥类型</a></li><li><a href="openssl.pkcs7.flags.html">PKCS7 标志/常量</a></li><li><a href="openssl.signature-algos.html">Signature Algorithms</a></li><li><a href="openssl.ciphers.html">Ciphers</a></li><li><a href="openssl.constversion.html">Version constants</a></li><li><a href="openssl.constsni.html">Server Name Indication constants</a></li></ul></li><li><a href="openssl.certparams.html">密钥/证书参数</a></li><li><a href="openssl.cert.verification.html">证书验证</a></li><li><a href="ref.openssl.html">OpenSSL 函数</a><ul class="chunklist chunklist_book chunklist_children"><li><a href="function.openssl-cipher-iv-length.html">openssl_cipher_iv_length</a> &mdash; 获取密码iv长度</li><li><a href="function.openssl-cms-decrypt.html">openssl_cms_decrypt</a> &mdash; Decrypt a CMS message</li><li><a href="function.openssl-cms-encrypt.html">openssl_cms_encrypt</a> &mdash; Encrypt a CMS message</li><li><a href="function.openssl-cms-read.html">openssl_cms_read</a> &mdash; Export the CMS file to an array of PEM certificates</li><li><a href="function.openssl-cms-sign.html">openssl_cms_sign</a> &mdash; Sign a file</li><li><a href="function.openssl-cms-verify.html">openssl_cms_verify</a> &mdash; Verify a CMS signature</li><li><a href="function.openssl-csr-export-to-file.html">openssl_csr_export_to_file</a> &mdash; 将CSR导出到文件</li><li><a href="function.openssl-csr-export.html">openssl_csr_export</a> &mdash; 将CSR作为字符串导出</li><li><a href="function.openssl-csr-get-public-key.html">openssl_csr_get_public_key</a> &mdash; 返回CSR的公钥</li><li><a href="function.openssl-csr-get-subject.html">openssl_csr_get_subject</a> &mdash; 返回CSR的主题</li><li><a href="function.openssl-csr-new.html">openssl_csr_new</a> &mdash; 生成一个 CSR</li><li><a href="function.openssl-csr-sign.html">openssl_csr_sign</a> &mdash; 用另一个证书签署 CSR (或者本身) 并且生成一个证书</li><li><a href="function.openssl-decrypt.html">openssl_decrypt</a> &mdash; 解密数据</li><li><a href="function.openssl-dh-compute-key.html">openssl_dh_compute_key</a> &mdash; 计算远程DH密钥(公钥)和本地DH密钥的共享密钥</li><li><a href="function.openssl-digest.html">openssl_digest</a> &mdash; 计算摘要</li><li><a href="function.openssl-encrypt.html">openssl_encrypt</a> &mdash; 加密数据</li><li><a href="function.openssl-error-string.html">openssl_error_string</a> &mdash; 返回 openSSL 错误消息</li><li><a href="function.openssl-free-key.html">openssl_free_key</a> &mdash; 释放密钥资源</li><li><a href="function.openssl-get-cert-locations.html">openssl_get_cert_locations</a> &mdash; 检索可用的证书位置</li><li><a href="function.openssl-get-cipher-methods.html">openssl_get_cipher_methods</a> &mdash; 获取可用的加密算法</li><li><a href="function.openssl-get-curve-names.html">openssl_get_curve_names</a> &mdash; 获得ECC的可用曲线名称列表</li><li><a href="function.openssl-get-md-methods.html">openssl_get_md_methods</a> &mdash; 获取可用的摘要算法</li><li><a href="function.openssl-get-privatekey.html">openssl_get_privatekey</a> &mdash; 别名 openssl_pkey_get_private</li><li><a href="function.openssl-get-publickey.html">openssl_get_publickey</a> &mdash; 别名 openssl_pkey_get_public</li><li><a href="function.openssl-open.html">openssl_open</a> &mdash; 打开密封的数据</li><li><a href="function.openssl-pbkdf2.html">openssl_pbkdf2</a> &mdash; 生成一个 PKCS5 v2 PBKDF2 字符串</li><li><a href="function.openssl-pkcs12-export-to-file.html">openssl_pkcs12_export_to_file</a> &mdash; 输出一个 PKCS#12 兼容的证书存储文件</li><li><a href="function.openssl-pkcs12-export.html">openssl_pkcs12_export</a> &mdash; 将 PKCS#12 兼容证书存储文件导出到变量</li><li><a href="function.openssl-pkcs12-read.html">openssl_pkcs12_read</a> &mdash; 将 PKCS#12 证书存储区解析到数组中</li><li><a href="function.openssl-pkcs7-decrypt.html">openssl_pkcs7_decrypt</a> &mdash; 解密一个 S/MIME 加密的消息</li><li><a href="function.openssl-pkcs7-encrypt.html">openssl_pkcs7_encrypt</a> &mdash; 加密一个 S/MIME 消息</li><li><a href="function.openssl-pkcs7-read.html">openssl_pkcs7_read</a> &mdash; 将PKCS7文件导出为PEM格式证书的数组</li><li><a href="function.openssl-pkcs7-sign.html">openssl_pkcs7_sign</a> &mdash; 对一个 S/MIME 消息进行签名</li><li><a href="function.openssl-pkcs7-verify.html">openssl_pkcs7_verify</a> &mdash; 校验一个已签名的 S/MIME 消息的签名</li><li><a href="function.openssl-pkey-derive.html">openssl_pkey_derive</a> &mdash; Computes shared secret for public value of remote and local DH or ECDH key</li><li><a href="function.openssl-pkey-export-to-file.html">openssl_pkey_export_to_file</a> &mdash; 将密钥导出到文件中</li><li><a href="function.openssl-pkey-export.html">openssl_pkey_export</a> &mdash; 将一个密钥的可输出表示转换为字符串</li><li><a href="function.openssl-pkey-free.html">openssl_pkey_free</a> &mdash; 释放一个私钥</li><li><a href="function.openssl-pkey-get-details.html">openssl_pkey_get_details</a> &mdash; 返回包含密钥详情的数组</li><li><a href="function.openssl-pkey-get-private.html">openssl_pkey_get_private</a> &mdash; 获取私钥</li><li><a href="function.openssl-pkey-get-public.html">openssl_pkey_get_public</a> &mdash; 从证书中解析公钥，以供使用。</li><li><a href="function.openssl-pkey-new.html">openssl_pkey_new</a> &mdash; 生成一个新的私钥</li><li><a href="function.openssl-private-decrypt.html">openssl_private_decrypt</a> &mdash; 使用私钥解密数据</li><li><a href="function.openssl-private-encrypt.html">openssl_private_encrypt</a> &mdash; 使用私钥加密数据</li><li><a href="function.openssl-public-decrypt.html">openssl_public_decrypt</a> &mdash; 使用公钥解密数据</li><li><a href="function.openssl-public-encrypt.html">openssl_public_encrypt</a> &mdash; 使用公钥加密数据</li><li><a href="function.openssl-random-pseudo-bytes.html">openssl_random_pseudo_bytes</a> &mdash; 生成一个伪随机字节串</li><li><a href="function.openssl-seal.html">openssl_seal</a> &mdash; 密封 (加密) 数据</li><li><a href="function.openssl-sign.html">openssl_sign</a> &mdash; Generate signature</li><li><a href="function.openssl-spki-export-challenge.html">openssl_spki_export_challenge</a> &mdash; 导出与签名公钥和挑战相关的挑战字符串</li><li><a href="function.openssl-spki-export.html">openssl_spki_export</a> &mdash; 通过签名公钥和挑战导出一个可用的PEM格式的公钥</li><li><a href="function.openssl-spki-new.html">openssl_spki_new</a> &mdash; 生成一个新的签名公钥和挑战</li><li><a href="function.openssl-spki-verify.html">openssl_spki_verify</a> &mdash; 验证签名公钥和挑战。</li><li><a href="function.openssl-verify.html">openssl_verify</a> &mdash; 验证签名</li><li><a href="function.openssl-x509-check-private-key.html">openssl_x509_check_private_key</a> &mdash; 检查私钥是否对应于证书</li><li><a href="function.openssl-x509-checkpurpose.html">openssl_x509_checkpurpose</a> &mdash; 验证是否可以为特定目的使用证书</li><li><a href="function.openssl-x509-export-to-file.html">openssl_x509_export_to_file</a> &mdash; 导出证书至文件</li><li><a href="function.openssl-x509-export.html">openssl_x509_export</a> &mdash; 以字符串格式导出证书</li><li><a href="function.openssl-x509-fingerprint.html">openssl_x509_fingerprint</a> &mdash; 计算一个给定的x.509证书的指纹或摘要</li><li><a href="function.openssl-x509-free.html">openssl_x509_free</a> &mdash; 释放证书资源</li><li><a href="function.openssl-x509-parse.html">openssl_x509_parse</a> &mdash; 解析一个X509证书并作为一个数组返回信息</li><li><a href="function.openssl-x509-read.html">openssl_x509_read</a> &mdash; 解析一个x.509证书并返回一个资源标识符</li><li><a href="function.openssl-x509-verify.html">openssl_x509_verify</a> &mdash; Verifies digital signature of x509 certificate against a public key</li></ul></li></ul></div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="119594""></a>
  <div class="note">
   <strong class="user">james at NOSPAM dot gmail dot com</strong>
   <a href="#119594" class="date">13-Jul-2016 10:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In regards to the comment above:<br />
<br />
"After generating a key pair with OpenSSL, the public key can be stored in plain text format. I then encrypted the private key itself using regular mcrypt with the human-memorizable key of my choice and converted it to ACSII using base64_encode. Then to get the private key back, I just decrypted it with mcrypt. This way I could store the encrypted private key on the server without worrying about having things stored unencrypted. "<br />
<br />
To anyone reading this that might not be all that familiar with public key cryptography; I haven't the slightest idea what this person is talking about, but I can tell you its an absolutely horrible idea.&nbsp; He might have ended up with something that "looked like a private key" insofar as it was a base64 encoded string, but he did not have a private key.&nbsp; The parameters that make up a public/private key pair are EXTREMELY specific and in the case of RSA rely on very large co-primes plus an even larger moduli.&nbsp; Its not just a base64 encoded string; and just for the record... base64 encoding is not encryption. <br />
<br />
One of two things happened; the more likely is the whatever program he needed the certificate for realized there was something wrong with the private key, and ignored it, reverting to either a default key, or null encryption or something.&nbsp; The worse outcome would be if it interpreted whatever was there as legitimate; and encrypted data as if it were a a proper certificate; encrypting this way would likely provide close to zero security and I'm not even sure you could decrypt the data once encrypted.&nbsp; Its not worth giving much thought.&nbsp; <br />
<br />
Just please; don't do this.<br />
<br />
You can read about pki certificate structures and attribute frameworks by pasting "T-REC-X.509-201210-I" into your favorite interwebs search widget and following the result to the International Telecommunications Union webpage, or you can refer to the numerous RFCs; 6818, 5820 being good places to start. The Internet Engineering Task Force archives all RFCs, but there are other sources as well.&nbsp; "IETF RFC" should be enough to get you there.<br />
<br />
...sorry, the "spam buster" was giving me all kinds of issues.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91210""></a>
  <div class="note">
   <strong class="user">bdh dot hall at gmail dot com</strong>
   <a href="#91210" class="date">29-May-2009 03:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was having a heck of a time finding help on making asynchronous encryption/decryption using private key/public key systems working, and I had to have it for creating a credit card module that uses recurring billing.<br />
<br />
You'd be a fool to use normal, 'synchronous' or two-way encryption for this, so the whole mcrypt library won't help.<br />
<br />
But, it turns out OpenSSL is extremely easy to use...yet it is so sparsely documented that it seems it would be incredibly hard.<br />
<br />
So I share my day of hacking with you - I hope you find it helpful!<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if (isset(</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'HTTPS'</span><span class="keyword">]) )<br />
{<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"SECURE: This page is being accessed through a secure connection.&lt;br&gt;&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
else<br />
{<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"UNSECURE: This page is being access through an unsecure connection.&lt;br&gt;&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">// Create the keypair<br />
</span><span class="default">$res</span><span class="keyword">=</span><span class="default">openssl_pkey_new</span><span class="keyword">();<br />
<br />
</span><span class="comment">// Get private key<br />
</span><span class="default">openssl_pkey_export</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">, </span><span class="default">$privatekey</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Get public key<br />
</span><span class="default">$publickey</span><span class="keyword">=</span><span class="default">openssl_pkey_get_details</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">);<br />
</span><span class="default">$publickey</span><span class="keyword">=</span><span class="default">$publickey</span><span class="keyword">[</span><span class="string">"key"</span><span class="keyword">];<br />
<br />
echo </span><span class="string">"Private Key:&lt;BR&gt;</span><span class="default">$privatekey</span><span class="string">&lt;br&gt;&lt;br&gt;Public Key:&lt;BR&gt;</span><span class="default">$publickey</span><span class="string">&lt;BR&gt;&lt;BR&gt;"</span><span class="keyword">;<br />
<br />
</span><span class="default">$cleartext </span><span class="keyword">= </span><span class="string">'1234 5678 9012 3456'</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"Clear text:&lt;br&gt;</span><span class="default">$cleartext</span><span class="string">&lt;BR&gt;&lt;BR&gt;"</span><span class="keyword">;<br />
<br />
</span><span class="default">openssl_public_encrypt</span><span class="keyword">(</span><span class="default">$cleartext</span><span class="keyword">, </span><span class="default">$crypttext</span><span class="keyword">, </span><span class="default">$publickey</span><span class="keyword">);<br />
<br />
echo </span><span class="string">"Crypt text:&lt;br&gt;</span><span class="default">$crypttext</span><span class="string">&lt;BR&gt;&lt;BR&gt;"</span><span class="keyword">;<br />
<br />
</span><span class="default">openssl_private_decrypt</span><span class="keyword">(</span><span class="default">$crypttext</span><span class="keyword">, </span><span class="default">$decrypted</span><span class="keyword">, </span><span class="default">$privatekey</span><span class="keyword">);<br />
<br />
echo </span><span class="string">"Decrypted text:&lt;BR&gt;</span><span class="default">$decrypted</span><span class="string">&lt;br&gt;&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Many thanks to other contributors in the docs for making this less painful.<br />
<br />
Note that you will want to use these sorts of functions to generate a key ONCE - save your privatekey offline for decryption, and put your public key in your scripts/configuration file. If your data is compromised you don't care about the encrypted stuff or the public key, it's only the private key and cleartext that really matter.<br />
<br />
Good luck!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85444""></a>
  <div class="note">
   <strong class="user">koen dot thomeer at pubmed dot be</strong>
   <a href="#85444" class="date">31-Aug-2008 10:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For checking the status of a client certificate using OCSP, you can use this script:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// User variables:<br />
</span><span class="default">$dir </span><span class="keyword">= </span><span class="string">'/path/to/temp/'</span><span class="keyword">; </span><span class="comment">// Directory where apache has access to (chmod 777).<br />
</span><span class="default">$RootCA </span><span class="keyword">= </span><span class="string">'/path/to/Root.cer'</span><span class="keyword">; </span><span class="comment">// Points to the Root CA in PEM format.<br />
</span><span class="default">$OCSPUrl </span><span class="keyword">= </span><span class="string">'<a href="http://ocsp.url" rel="nofollow" target="_blank">http://ocsp.url</a>'</span><span class="keyword">; </span><span class="comment">//Points to the OCSP URL<br />
// Script:<br />
</span><span class="default">$a </span><span class="keyword">= </span><span class="default">rand</span><span class="keyword">(</span><span class="default">1000</span><span class="keyword">,</span><span class="default">99999</span><span class="keyword">); </span><span class="comment">// Needed if you expect more page clicks in one second!<br />
</span><span class="default">file_put_contents</span><span class="keyword">(</span><span class="default">$dir</span><span class="keyword">.</span><span class="default">$a</span><span class="keyword">.</span><span class="string">'cert_i.pem'</span><span class="keyword">, </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'SSL_CLIENT_CERT_CHAIN_0'</span><span class="keyword">]); </span><span class="comment">// Issuer certificate.<br />
</span><span class="default">file_put_contents</span><span class="keyword">(</span><span class="default">$dir</span><span class="keyword">.</span><span class="default">$a</span><span class="keyword">.</span><span class="string">'cert_c.pem'</span><span class="keyword">, </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'SSL_CLIENT_CERT'</span><span class="keyword">]); </span><span class="comment">// Client (authentication) certificate.<br />
</span><span class="default">$output </span><span class="keyword">= </span><span class="default">shell_exec</span><span class="keyword">(</span><span class="string">'openssl ocsp -CAfile '</span><span class="keyword">.</span><span class="default">$RootCA</span><span class="keyword">.</span><span class="string">' -issuer '</span><span class="keyword">.</span><span class="default">$dir</span><span class="keyword">.</span><span class="default">$a</span><span class="keyword">.</span><span class="string">'cert_i.pem -cert '</span><span class="keyword">.</span><span class="default">$dir</span><span class="keyword">.</span><span class="default">$a</span><span class="keyword">.</span><span class="string">'cert_c.pem -url '</span><span class="keyword">.</span><span class="default">$OCSPUrl</span><span class="keyword">);<br />
</span><span class="default">$output2 </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/[\r\n]/'</span><span class="keyword">, </span><span class="default">$output</span><span class="keyword">);<br />
</span><span class="default">$output3 </span><span class="keyword">= </span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">'/: /'</span><span class="keyword">, </span><span class="default">$output2</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]);<br />
</span><span class="default">$ocsp </span><span class="keyword">= </span><span class="default">$output3</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
echo </span><span class="string">"OCSP status: "</span><span class="keyword">.</span><span class="default">$ocsp</span><span class="keyword">; </span><span class="comment">// will be "good", "revoked", or "unknown"<br />
</span><span class="default">unlink</span><span class="keyword">(</span><span class="default">$dir</span><span class="keyword">.</span><span class="default">$a</span><span class="keyword">.</span><span class="string">'cert_i.pem'</span><span class="keyword">);<br />
</span><span class="default">unlink</span><span class="keyword">(</span><span class="default">$dir</span><span class="keyword">.</span><span class="default">$a</span><span class="keyword">.</span><span class="string">'cert_c.pem'</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
It can be ameliorated, but it's just a beginning!<br />
<br />
Normally, you can extract the ocsp url from the client certificate. Also, an OCSP request contains only the hash of the issuer name, the hash of the issuer's key, and the serial number of the client certificate. All three can be extracted directly from the client certificate.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
