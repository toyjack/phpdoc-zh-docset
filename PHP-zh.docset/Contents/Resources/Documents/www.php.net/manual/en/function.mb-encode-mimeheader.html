<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>为 MIME 头编码字符串</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.mb-detect-order.html">? mb_detect_order</a></li>
      <li style="float: right;"><a href="function.mb-encode-numericentity.html">mb_encode_numericentity ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.mbstring.html">多字节字符串 函数</a></li>
    <li>为 MIME 头编码字符串</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.mb-encode-mimeheader" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">mb_encode_mimeheader</h1>
  <p class="verinfo">(PHP 4 &gt;= 4.0.6, PHP 5, PHP 7)</p><p class="refpurpose"><span class="refname">mb_encode_mimeheader</span> &mdash; <span class="dc-title">为 MIME 头编码字符串</span></p>

 </div>
   
 <div class="refsect1 description" id="refsect1-function.mb-encode-mimeheader-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>mb_encode_mimeheader</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$str</code></span>
   [, <span class="methodparam"><span class="type">string</span> <code class="parameter">$charset</code><span class="initializer"> = determined by mb_language()</span></span>
   [, <span class="methodparam"><span class="type">string</span> <code class="parameter">$transfer_encoding</code><span class="initializer"> = &quot;B&quot;</span></span>
   [, <span class="methodparam"><span class="type">string</span> <code class="parameter">$linefeed</code><span class="initializer"> = &quot;\r\n&quot;</span></span>
   [, <span class="methodparam"><span class="type">int</span> <code class="parameter">$indent</code><span class="initializer"> = 0</span></span>
  ]]]] ) : <span class="type">string</span></div>

  <p class="para rdfs-comment">
   按 MIME 头编码方案将指定的<span class="type"><span class="type 字符串">字符串</span></span> <code class="parameter">str</code> 进行编码。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.mb-encode-mimeheader-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">str</code></dt>

     <dd>

      <p class="para">
       要编码的 <span class="type"><a href="language.types.string.html" class="type string">string</a></span>。
       它的编码应该和 <span class="function"><a href="function.mb-internal-encoding.html" class="function">mb_internal_encoding()</a></span> 一样。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">charset</code></dt>

     <dd>

      <p class="para">
       <code class="parameter">charset</code> 指定了 <code class="parameter">str</code> 的字符集名。
       其默认值由当前的 NLS 设置（<em>mbstring.language</em>）来确定。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">transfer_encoding</code></dt>

     <dd>

      <p class="para">
       <code class="parameter">transfer_encoding</code> 指定了 MIME 的编码方案。
       它可以是 <em>&quot;B&quot;</em>（Base64）也可以是 <em>&quot;Q&quot;</em>（Quoted-Printable）。
       如果未设置，将回退为 <em>&quot;B&quot;</em>。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">linefeed</code></dt>

     <dd>

      <p class="para">
       <code class="parameter">linefeed</code> 指定了 EOL（行尾）标记，使 <span class="function"><strong>mb_encode_mimeheader()</strong></span> 执行了一个换行（<a href="http://www.faqs.org/rfcs/rfc2822" class="link external" title="Link : http://www.faqs.org/rfcs/rfc2822">&raquo;&nbsp;RFC</a> 文档中规定，超过长度的一行将换成多行，当前该长度硬式编码为 74 个字符）。
       如果没有设定，则回退为 <em>&quot;\r\n&quot;</em> (CRLF)。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">indent</code></dt>

     <dd>

      <p class="para">
       首行缩进（header 里 <code class="parameter">str</code> 前的字符数目）。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>

 
 <div class="refsect1 returnvalues" id="refsect1-function.mb-encode-mimeheader-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   转换后的<span class="type"><span class="type 字符串">字符串</span></span>版本以 ASCII 形式表达。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.mb-encode-mimeheader-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-3215">
    <p><strong>Example #1 <span class="function"><strong>mb_encode_mimeheader()</strong></span> 例子</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$name&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">""</span><span style="color: #007700">;&nbsp;</span><span style="color: #FF8000">//&nbsp;kanji<br /></span><span style="color: #0000BB">$mbox&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"kru"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$doma&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"gtinn.mon"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$addr&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">mb_encode_mimeheader</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">"UTF-7"</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">"Q"</span><span style="color: #007700">)&nbsp;.&nbsp;</span><span style="color: #DD0000">"&nbsp;&lt;"&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$mbox&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">"@"&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$doma&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">"&gt;"</span><span style="color: #007700">;<br />echo&nbsp;</span><span style="color: #0000BB">$addr</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.mb-encode-mimeheader-notes">
  <h3 class="title">注释</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    这个函数没有设计成据更高级上下文的中断点来换行（单词边界等）。
    这个特性将导致意外的空格可能会让原始字符串看上去很乱。
   </p>
  </p></blockquote>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.mb-encode-mimeheader-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.mb-decode-mimeheader.html" class="function" rel="rdfs-seeAlso">mb_decode_mimeheader()</a> - 解码 MIME 头字段中的字符串</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="90242""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#90242" class="date">11-Apr-2009 06:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I could not find a PHP function to MIME encode the name for a n email address.
<br />

<br />
Input&nbsp;&nbsp; = "Karl Müller&lt;kmueller@gmx.de&gt;"
<br />
Output = "Karl%20M%FCller&lt;kmueller@gmx.de&gt;"
<br />

<br />
I wrote it on my own:
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="comment">// required to encode names in email addresses&nbsp; &nbsp; 
<br />
// replace " " with "%20"
<br />
// replace "ü" with "%FC" 
<br />
// replace "%" with "%25"&nbsp; &nbsp; &nbsp; etc....
<br />
// Use "%" as Delimiter for MIME
<br />
// Use "=" as Delimiter for Quoted Printable
<br />
// Input string must be UTF8 encoded
<br />
</span><span class="keyword">public static function </span><span class="default">EncodeMime</span><span class="keyword">(</span><span class="default">$Text</span><span class="keyword">, </span><span class="default">$Delimiter</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Text </span><span class="keyword">= </span><span class="default">utf8_decode</span><span class="keyword">(</span><span class="default">$Text</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Len&nbsp; </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$Text</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Out&nbsp; </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$Len</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++)
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$Chr </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$Text</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$Asc </span><span class="keyword">= </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$Chr</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$Asc </span><span class="keyword">&gt; </span><span class="default">0x255</span><span class="keyword">) </span><span class="comment">// Unicode not allowed
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">{
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$Out </span><span class="keyword">.= </span><span class="string">"?"</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$Chr </span><span class="keyword">== </span><span class="string">" " </span><span class="keyword">|| </span><span class="default">$Chr </span><span class="keyword">== </span><span class="default">$Delimiter </span><span class="keyword">|| </span><span class="default">$Asc </span><span class="keyword">&gt; </span><span class="default">127</span><span class="keyword">) 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$Out </span><span class="keyword">.= </span><span class="default">$Delimiter </span><span class="keyword">. </span><span class="default">strtoupper</span><span class="keyword">(</span><span class="default">bin2hex</span><span class="keyword">(</span><span class="default">$Chr</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else </span><span class="default">$Out </span><span class="keyword">.= </span><span class="default">$Chr</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$Out</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82171""></a>
  <div class="note">
   <strong class="user">tokul at users dot sourceforge dot net</strong>
   <a href="#82171" class="date">30-Mar-2008 04:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
mb_encode_mimeheader() depends on correct mbstring.internal_encoding setting. It tries to convert $str from internal encoding to $charset. If you ignore mbstring internal encoding, function might encode strings incorrectly even when $str character set matches $charset</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="67186""></a>
  <div class="note">
   <strong class="user">chappy at citromail dot hu</strong>
   <a href="#67186" class="date">05-Jun-2006 04:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I found a bad function. <br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">encodeHeader</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">, </span><span class="default">$charset </span><span class="keyword">= </span><span class="string">'ISO-8859-2'</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">'/(\\w*[\\x80-\\xFF]+\\w*)/'</span><span class="keyword">, </span><span class="default">$input</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] as </span><span class="default">$value</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$replacement </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/([\\x80-\\xFF])/e'</span><span class="keyword">, </span><span class="string">'"=" . strtoupper(dechex(ord("\\1")))'</span><span class="keyword">, </span><span class="default">$value</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$input </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">, </span><span class="string">'=?' </span><span class="keyword">. </span><span class="default">$charset </span><span class="keyword">. </span><span class="string">'?Q?' </span><span class="keyword">. </span><span class="default">$replacement </span><span class="keyword">. </span><span class="string">'?='</span><span class="keyword">, </span><span class="default">$input</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$input</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
This function should be used:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">encodeHeader</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">, </span><span class="default">$charset </span><span class="keyword">= </span><span class="string">'ISO-8859-2'</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$m</span><span class="keyword">=</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">'/(\w*[\x80-\xFF]+\w*)/'</span><span class="keyword">, </span><span class="default">$input</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$m</span><span class="keyword">)</span><span class="default">$input</span><span class="keyword">=</span><span class="default">mb_encode_mimeheader</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">,</span><span class="default">$charset</span><span class="keyword">, </span><span class="string">'Q'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$input</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="65666""></a>
  <div class="note">
   <strong class="user">stormflyCUT at hyh dot pl</strong>
   <a href="#65666" class="date">05-May-2006 04:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Some solution for using national chars and have problem with UTF-8 for example in mail subject. Before you use mb_encode_mimeheader with UTF-8 set mb_internal_encoding('UTF-8').</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60283""></a>
  <div class="note">
   <strong class="user">paravoid</strong>
   <a href="#60283" class="date">01-Jan-2006 05:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If mb_ version doesn't work for you in MIME-B mode:<br />
<br />
function encode_mimeheader($string, $charset=null, $linefeed="\r\n") {<br />
&nbsp;&nbsp;&nbsp; if (!$charset)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $charset = mb_internal_encoding();<br />
<br />
&nbsp;&nbsp;&nbsp; $start = "=?$charset?B?";<br />
&nbsp;&nbsp;&nbsp; $end = "?=";<br />
&nbsp;&nbsp;&nbsp; $encoded = '';<br />
<br />
&nbsp;&nbsp;&nbsp; /* Each line must have length &lt;= 75, including $start and $end */<br />
&nbsp;&nbsp;&nbsp; $length = 75 - strlen($start) - strlen($end);<br />
&nbsp;&nbsp;&nbsp; /* Average multi-byte ratio */<br />
&nbsp;&nbsp;&nbsp; $ratio = mb_strlen($string, $charset) / strlen($string);<br />
&nbsp;&nbsp;&nbsp; /* Base64 has a 4:3 ratio */<br />
&nbsp;&nbsp;&nbsp; $magic = $avglength = floor(3 * $length * $ratio / 4);<br />
<br />
&nbsp;&nbsp;&nbsp; for ($i=0; $i &lt;= mb_strlen($string, $charset); $i+=$magic) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $magic = $avglength;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $offset = 0;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; /* Recalculate magic for each line to be 100% sure */<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; do {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $magic -= $offset;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $chunk = mb_substr($string, $i, $magic, $charset);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $chunk = base64_encode($chunk);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $offset++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } while (strlen($chunk) &gt; $length);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if ($chunk)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $encoded .= ' '.$start.$chunk.$end.$linefeed;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; /* Chomp the first space and the last linefeed */<br />
&nbsp;&nbsp;&nbsp; $encoded = substr($encoded, 1, -strlen($linefeed));<br />
<br />
&nbsp;&nbsp;&nbsp; return $encoded;<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59704""></a>
  <div class="note">
   <strong class="user">nigrez at nius dot waw dot pl</strong>
   <a href="#59704" class="date">13-Dec-2005 03:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
True, function is broken (PHP5.1, encoding from UTF-8 with pl_PL charset). Below is about 15% faster version of proposed _mb_mime_encode. Also it has header more like othe mb_* functions and doesn't trigger any errors/warnings/notices.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">mb_mime_header</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$encoding</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">, </span><span class="default">$linefeed</span><span class="keyword">=</span><span class="string">"\r\n"</span><span class="keyword">) {<br />
&nbsp; if(!</span><span class="default">$encoding</span><span class="keyword">) </span><span class="default">$encoding </span><span class="keyword">= </span><span class="default">mb_internal_encoding</span><span class="keyword">();<br />
&nbsp; </span><span class="default">$encoded </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;<br />
<br />
&nbsp; while(</span><span class="default">$length </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">)) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$encoded </span><span class="keyword">.= </span><span class="string">"=?</span><span class="default">$encoding</span><span class="string">?B?"<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">. </span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">,</span><span class="default">0</span><span class="keyword">,</span><span class="default">24</span><span class="keyword">,</span><span class="default">$encoding</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . </span><span class="string">"?=</span><span class="default">$linefeed</span><span class="string">"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$string </span><span class="keyword">= </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">,</span><span class="default">24</span><span class="keyword">,</span><span class="default">$length</span><span class="keyword">,</span><span class="default">$encoding</span><span class="keyword">);<br />
&nbsp; }<br />
<br />
&nbsp; return </span><span class="default">$encoded</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58515""></a>
  <div class="note">
   <strong class="user">gullevek at gullevek dot org</strong>
   <a href="#58515" class="date">06-Nov-2005 05:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
My first post was around 2003, and still the mb_mime_header is broken. It is *NOT* usable with longer subjects, and mostly unusable with anything else than japanese.<br />
<br />
iwakura at junx dot org is also not working for me, it produces also some gargabe.<br />
<br />
I updated my old function (the one I posted 2003) and I tested it with overlong subjects in UTF-8, ISO-2022-JP (japanese), GB2312 (simplified chinese) and EUC-KR (korean) and I got readable results in thunderbird, mail.app, outlook, etc.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">_mb_mime_encode</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$encoding</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// after 36 single bytes characters if then comes MB, it is broken<br />
&nbsp;&nbsp;&nbsp; // but I trimmed it down to 24, to stay 100% &lt; 76 chars per line<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$split </span><span class="keyword">= </span><span class="default">24</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">$pos </span><span class="keyword">&lt; </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$encoding</span><span class="keyword">))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$output </span><span class="keyword">= </span><span class="default">mb_strimwidth</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">, </span><span class="default">$split</span><span class="keyword">, </span><span class="string">""</span><span class="keyword">, </span><span class="default">$encoding</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">+= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">, </span><span class="default">$encoding</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$_string_encoded </span><span class="keyword">= </span><span class="string">"=?"</span><span class="keyword">.</span><span class="default">$encoding</span><span class="keyword">.</span><span class="string">"?B?"</span><span class="keyword">.</span><span class="default">base64_encode</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">).</span><span class="string">"?="</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$_string</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$_string </span><span class="keyword">.= </span><span class="string">"\r\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$_string </span><span class="keyword">.= </span><span class="default">$_string_encoded</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$string </span><span class="keyword">= </span><span class="default">$_string</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$string</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58262""></a>
  <div class="note">
   <strong class="user">chappy at citromail dot hu</strong>
   <a href="#58262" class="date">28-Oct-2005 11:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In countries where there's non-us ASCII, it's a very good example, for sending mail:<br />
<br />
mb_internal_encoding('iso-8859-2');<br />
setlocale(LC_CTYPE, 'hu_HU');<br />
<br />
function encode($str,$charset){<br />
&nbsp;&nbsp;&nbsp; $str=mb_encode_mimeheader(trim($str),$charset, 'Q', "\n\t");<br />
&nbsp;&nbsp;&nbsp; return $str;<br />
}<br />
<br />
print encode('the text with spec. chars: &amp;#337; &amp;#368; &amp;#336; &amp;#369;, ?','iso-8859-2');<br />
<br />
It creates a 7bit string</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56832""></a>
  <div class="note">
   <strong class="user">iwakura at junx dot org</strong>
   <a href="#56832" class="date">15-Sep-2005 11:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
i think mb_encode_mimeheader still have bug. here is sample code:<br />
<br />
function mb_encode_mimeheader2($string, $encoding = "ISO-2022-JP") {<br />
&nbsp;&nbsp;&nbsp; $string_array = array();<br />
&nbsp;&nbsp;&nbsp; $pos = 0;<br />
&nbsp;&nbsp;&nbsp; $row = 0;<br />
&nbsp;&nbsp;&nbsp; $mode = 0;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; while ($pos &lt; mb_strlen($string)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $word = mb_strimwidth($string, $pos, 1);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (!$word) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $word = mb_strimwidth($string, $pos, 2);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (mb_ereg_match("[ -~]", $word)) {&nbsp; &nbsp; // ascii<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ($mode != 1) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $row++;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $mode = 1;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $string_array[$row] = NULL;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // multibyte<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if ($mode != 2) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $row++;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $mode = 2;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $string_array[$row] = NULL;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $string_array[$row] .= $word;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $pos++;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; //echo "&lt;pre&gt;";<br />
&nbsp;&nbsp;&nbsp; //print_r($string_array);<br />
&nbsp;&nbsp;&nbsp; //echo "&lt;/pre&gt;";<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; foreach ($string_array as $key =&gt; $value) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $value = mb_convert_encoding($value, $encoding);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $string_array[$key] = mb_encode_mimeheader($value, $encoding);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; //echo "&lt;pre&gt;";<br />
&nbsp;&nbsp;&nbsp; //print_r($string_array);<br />
&nbsp;&nbsp;&nbsp; //echo "&lt;/pre&gt;";<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return implode("", $string_array);<br />
}<br />
<br />
is not the best, but it works</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50966""></a>
  <div class="note">
   <strong class="user">mortoray at ecircle-ag dot com</strong>
   <a href="#50966" class="date">15-Mar-2005 01:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
At least for Q encoding, this function is unsafe and does not encode correctly. Raw characters which appear as RFC2047 sequences are simply left as is.<br />
<br />
Ex:<br />
<br />
mb_encode_mimeheader( '=?iso-8859-1?q?this=20is=20some=20text?=' );<br />
<br />
returns '=?iso-8859-1?q?this=20is=20some=20text?='<br />
<br />
The exact same string, which is obviously not the encoding for the source string.&nbsp; That is, mb_encode_mimeheader does not do any type of escaping.<br />
<br />
That is, the following condition is not always true:<br />
&nbsp;&nbsp;&nbsp; mb_decode_mimeheader( mb_encode_mimeheader( $text ) ) == $text</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="34532""></a>
  <div class="note">
   <strong class="user">gullevek at gullevek dot org</strong>
   <a href="#34532" class="date">30-Jul-2003 12:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Read this FIRST: <a href="http://bugs.php.net/bug.php?id=23192 because mb_encode_mimeheaders is BUGGY!" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=23192 because mb_encode_mimeheaders is BUGGY!</a><br />
<br />
a work around for the multibyte broken error for too long subjects for ISO-2022-JP:<br />
<br />
$pos=0;<br />
$split=36; // after 36 single bytes characters, if then comes MB, it is broken<br />
while ($pos&lt;mb_strlen($string,$encoding))<br />
{<br />
&nbsp; $output=mb_strimwidth($string,$pos,$split,"",$encoding);<br />
&nbsp; $pos+=mb_strlen($output,$encoding);<br />
&nbsp; $_string.=(($_string)?' ':'').mb_encode_mimeheader($output,$encoding);<br />
}<br />
$string=$_string;<br />
<br />
is not the best, but it works</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31186""></a>
  <div class="note">
   <strong class="user">masataka</strong>
   <a href="#31186" class="date">12-Apr-2003 07:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
second parameter 'charset' is character encoding name, but default must be UTF-8 on PHP4.3.1.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
