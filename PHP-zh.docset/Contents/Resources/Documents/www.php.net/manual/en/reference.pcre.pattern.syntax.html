<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>模式语法</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="pcre.pattern.html">? PCRE模式</a></li>
      <li style="float: right;"><a href="regexp.introduction.html">简介 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="pcre.pattern.html">PCRE模式</a></li>
    <li>模式语法</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="reference.pcre.pattern.syntax" class="chapter">
 <h1>模式语法</h1>
<h2>Table of Contents</h2><ul class="chunklist chunklist_chapter"><li><a href="regexp.introduction.html">简介</a></li><li><a href="regexp.reference.delimiters.html">分隔符</a></li><li><a href="regexp.reference.meta.html">元字符</a></li><li><a href="regexp.reference.escape.html">转义序列(反斜线)</a></li><li><a href="regexp.reference.unicode.html">Unicode 字符属性</a></li><li><a href="regexp.reference.anchors.html">锚</a></li><li><a href="regexp.reference.dot.html">句点</a></li><li><a href="regexp.reference.character-classes.html">字符类(方括号)</a></li><li><a href="regexp.reference.alternation.html">可选路径(|)</a></li><li><a href="regexp.reference.internal-options.html">内部选项设置</a></li><li><a href="regexp.reference.subpatterns.html">子组(子模式)</a></li><li><a href="regexp.reference.repetition.html">重复/量词</a></li><li><a href="regexp.reference.back-references.html">后向引用</a></li><li><a href="regexp.reference.assertions.html">断言</a></li><li><a href="regexp.reference.onlyonce.html">一次性子组</a></li><li><a href="regexp.reference.conditional.html">条件子组</a></li><li><a href="regexp.reference.comments.html">注释</a></li><li><a href="regexp.reference.recursive.html">递归模式</a></li><li><a href="regexp.reference.performance.html">性能</a></li></ul>

 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 

 
</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="122233""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#122233" class="date">05-Jan-2018 11:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As a rule of thumb, it's better to describe your regular expression patterns using single-quoted strings.<br />
<br />
Using double-quoted strings, the interaction between PHP's and PCRE's interpretations of which bits of the string are escape sequences can get messy. Regular expressions can get messy enough as it is without another layer of escaping making it worse.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87197""></a>
  <div class="note">
   <strong class="user">mbrodin</strong>
   <a href="#87197" class="date">24-Nov-2008 01:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi!<br />
<br />
For even better prestanda of the code below, use;<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $f </span><span class="keyword">= array();<br />
<br />
&nbsp;&nbsp;&nbsp; foreach(</span><span class="default">$allTags</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] as </span><span class="default">$tag</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$f</span><span class="keyword">[] = </span><span class="string">"%(&lt;</span><span class="default">$tag</span><span class="string">.*?&gt;)(.*?)(&lt;\/</span><span class="default">$tag</span><span class="string">.*?&gt;)%is"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$f</span><span class="keyword">)) </span><span class="default">$str </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="default">$f</span><span class="keyword">, (</span><span class="default">$stripContent </span><span class="keyword">? </span><span class="string">'' </span><span class="keyword">: </span><span class="string">'${2}'</span><span class="keyword">), </span><span class="default">$str</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
This will not use preg_replace on every tag, instead it collect the regex as array, and then executes and should be better.<br />
<br />
It also check so there are any regex to replace! If not, it will not start preg_replace! :)<br />
<br />
Added the "&lt;?php" so it will highlight the code!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="78820""></a>
  <div class="note">
   <strong class="user">datacompboy at call2ru dot com</strong>
   <a href="#78820" class="date">29-Oct-2007 10:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For example, you want to cut an some &lt;div&gt; element.<br />
Accurate, from &lt;div&gt; to correspond &lt;/div&gt; element.<br />
Here is proof-of-concept code to do this:<br />
<br />
&lt;?<br />
$str = "&lt;dqiv1&gt;1+&lt;div2&gt;2+&lt;div3&gt;&lt;b&gt;&lt;c&gt;3&lt;/c&gt;&lt;/b&gt;&lt;/div3&gt;2-&lt;/div2&gt;1-&lt;/div1&gt;";<br />
<br />
preg_match("#&lt;div.&gt; ( ".<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; " ( (?&gt;[^&lt;]*) ( &lt; ( ([^/d]|d([^i]|i[^v])) | /([^d]|d([^i]|i[^v])) ) )? )* ".<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; " | (?R) )* &lt;/div.&gt;#xi", $str, $m);<br />
var_dump($m[0]);<br />
<br />
?&gt;<br />
<br />
it match accurate from &lt;div2&gt; to &lt;/div2&gt;. And, if you change &lt;dqiv1&gt; to &lt;div1&gt;, it will match from &lt;div1&gt; to &lt;/div1&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="76197""></a>
  <div class="note">
   <strong class="user">chris at madblanks dot org</strong>
   <a href="#76197" class="date">04-Jul-2007 12:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When enclosing your regular expression in double quotes, back references require two backslashes.<br />
<br />
For example, \1 is the ascii character \1. You need to provide \\1 to get the back reference.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75339""></a>
  <div class="note">
   <strong class="user">sam marshall</strong>
   <a href="#75339" class="date">24-May-2007 10:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For anyone who sees this error: <br />
<br />
Warning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \L, \l, \N, \P, \p, \U, \u, or \X at ...<br />
<br />
As this manual page says, you need PHP 5.1.0 and the /u modifier in order to enable these features, but that isn't the only requirement! It is possible to install later versions of PHP (we have 5.1.4) while linking to an older PCRE install. A quick look at the PCRE changelog suggests that you probably need at least PCRE 5; we're running 4.5, while the latest is 7.1. You can find out your PCRE version by checking phpinfo().<br />
<br />
I suspect this ancient PCRE version is included in some officially-supported Red Hat Enterprise package which is probably why we are running it so might also affect other people.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74201""></a>
  <div class="note">
   <strong class="user">pstradomski at gmail dot com</strong>
   <a href="#74201" class="date">29-Mar-2007 07:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
About strip_selected_tags function from two posts below:<br />
<br />
it does not work if somebody uses tags without ending "&gt;" character, like this:<br />
<br />
&lt;p &lt;b&gt; bold text &lt;/b&lt;/p<br />
<br />
This&nbsp; is even valid HTML (but not valid XHTML)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71263""></a>
  <div class="note">
   <strong class="user">theppg_001 at hotmail dot com</strong>
   <a href="#71263" class="date">20-Nov-2006 01:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi there<br />
This was originally made by someone eles but it didn't work correctly and so I remade it and as far as I know it works right.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
* strip_selected_tags ( string str [, string strip_tags[, strip_content flag]] )<br />
* ---------------------------------------------------------------------<br />
* Like strip_tags() but inverse; the strip_tags tags will be stripped, not kept.<br />
* strip_tags: string with tags to strip, ex: "&lt;a&gt;&lt;p&gt;&lt;quote&gt;" etc.<br />
* strip_content flag: TRUE will also strip everything between open and closed tag<br />
*/<br />
</span><span class="keyword">function </span><span class="default">strip_selected_tags</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$tags </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">, </span><span class="default">$stripContent </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">"/&lt;([^&gt;]+)&gt;/i"</span><span class="keyword">, </span><span class="default">$tags</span><span class="keyword">, </span><span class="default">$allTags</span><span class="keyword">, </span><span class="default">PREG_PATTERN_ORDER</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$replace </span><span class="keyword">= </span><span class="string">"%(&lt;</span><span class="default">$tag</span><span class="string">.*?&gt;)(.*?)(&lt;\/</span><span class="default">$tag</span><span class="string">.*?&gt;)%is"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$allTags</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] as </span><span class="default">$tag</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$stripContent</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="default">$replace</span><span class="keyword">,</span><span class="string">''</span><span class="keyword">,</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="default">$replace</span><span class="keyword">,</span><span class="string">'${2}'</span><span class="keyword">,</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$str</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Before I 'fixed' it, when running<br />
strip_selected_tags("this is &lt;p align=\"center\"&gt;a test&lt;/p&gt; and &lt;b&gt;this is bold&lt;/b&gt;","&lt;p&gt;&lt;b&gt;")<br />
You would get back<br />
"this is &lt;p align=\"center\"&gt;a test&lt;/p&gt; and this is bold"<br />
Why? Because it did not take into account that there could be options etc in the HTML Tag.<br />
My one works perfectly when stripping just the tags or the tag and its contents too!<br />
<br />
So now when you run <br />
strip_selected_tags("this is &lt;p align=\"center\"&gt;a test&lt;/p&gt; and &lt;b&gt;this is bold&lt;/b&gt;","&lt;p&gt;&lt;b&gt;")<br />
You get back<br />
"this is a test and this is bold"<br />
Or when running<br />
strip_selected_tags("this is &lt;p align=\"center\"&gt;a test&lt;/p&gt; and &lt;b&gt;this is bold&lt;/b&gt;","&lt;p&gt;&lt;b&gt;",true)<br />
You get back<br />
"this is&nbsp; and "<br />
<br />
Hope it helps someone :)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59006""></a>
  <div class="note">
   <strong class="user">Daniel Vandersluis</strong>
   <a href="#59006" class="date">23-Nov-2005 10:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Concerning note #6 in "Differences From Perl", the \G token *is* supported as the last match position anchor. This has been confirmed to work at least in preg_replace(), though I'd assume it'd work in preg_match_all(), and other functions that can make more than one match, as well.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58559""></a>
  <div class="note">
   <strong class="user">roland dot illig at gmx dot de</strong>
   <a href="#58559" class="date">08-Nov-2005 01:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
&lt;quote&gt;<br />
9. Another as yet unresolved discrepancy is that in Perl 5.005_02 the pattern /^(a)?(?(1)a|b)+$/ matches the string "a", whereas in PCRE it does not. However, in both Perl and PCRE /^(a)?a/ matched against "a" leaves $1 unset.<br />
&lt;/quote&gt;<br />
<br />
The last sentence does not indicate a bug. If the string "a" should match against the regular expression /^(a)?a/, the last "a" in the regex must be matched by any literal "a" in the string. The rest of the string is "", which obviously does not match the first /^(a)/.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="54830""></a>
  <div class="note">
   <strong class="user">Ned Baldessin</strong>
   <a href="#54830" class="date">16-Jul-2005 04:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Although \w and \W do include as "word characters" locale-specific characters (like "?" if you are using the "fr" locale), \b and \B do not work the same way.<br />
<br />
For example :<br />
"foo ?tait bar"&nbsp;&nbsp; =&gt;&nbsp;&nbsp; /\W(?tait)\W/&nbsp;&nbsp; =&gt;&nbsp;&nbsp; This captures correctly "?tait".<br />
"foo ?tait bar"&nbsp;&nbsp; =&gt;&nbsp;&nbsp; /\b(?tait)\b/&nbsp;&nbsp; =&gt;&nbsp;&nbsp; This fails to capture it.<br />
<br />
This is confusing, because the manual talks in both cases about "word characters", but fails to mention the difference in behaviour.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51510""></a>
  <div class="note">
   <strong class="user">onerob at gmail dot com</strong>
   <a href="#51510" class="date">01-Apr-2005 04:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If, like me, you tend to use the /U pattern modifier, then you will need to remember that using ? or * to to test for optional characters will match zero characters if it means that the rest of the pattern can continue matching, even if the optional characters exist.<br />
<br />
For instance, if we have this string:<br />
<br />
a___bcde<br />
<br />
and apply this pattern:<br />
<br />
'/a(_*).*e/U'<br />
<br />
The whole pattern is matched but none of the _ characters are placed in the sub-pattern. The way around this (if you still wish to use /U) is to use the ? greediness inverter. eg,<br />
<br />
'/a(_*?).*e/U'</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50693""></a>
  <div class="note">
   <strong class="user">W W W</strong>
   <a href="#50693" class="date">07-Mar-2005 07:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Back references are a great way to achieve exact matching when it would have been impossible any other way. Take these three strings.<br />
<br />
1) "www.www.com"<br />
2) 'www.www.com'<br />
3) "www.www.com'<br />
<br />
The regex /^("|').+?("|')$/ would match all three strings but what if you needed the 3rd string above to be illegal because the quotes are not the same? You could write four different regexes to check for every possible case OR you could use back references.<br />
<br />
/^("|').+?\1$/ will match strings 1 and 2 but not string 3. Try this code for further proof:<br />
<br />
$str_test="'www.www.com\"";<br />
$int_count=preg_match("/^(\"|').+?\\1$/", $str_test, $matches, PREG_OFFSET_CAPTURE);<br />
<br />
The preg_match function will not match against $str_test because the quotes are mismatched. If you change $str_test to<br />
<br />
$str_test = "'www.www.com'";<br />
<br />
the preg_match will work.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49753""></a>
  <div class="note">
   <strong class="user">info at atjeff dot co dot nz</strong>
   <a href="#49753" class="date">07-Feb-2005 04:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
ive never used regex expressions till now and had loads of difficulty trying to convert a [url]link here[/url] into an href for use with posting messages on a forum, heres what i manage to come up with:<br />
<br />
$patterns = array(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "/\[link\](.*?)\[\/link\]/",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "/\[url\](.*?)\[\/url\]/",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "/\[img\](.*?)\[\/img\]/",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "/\[b\](.*?)\[\/b\]/",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "/\[u\](.*?)\[\/u\]/",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "/\[i\](.*?)\[\/i\]/"<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; );<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $replacements = array(<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "&lt;a href=\"\\1\"&gt;\\1&lt;/a&gt;",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "&lt;a href=\"\\1\"&gt;\\1&lt;/a&gt;",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "&lt;img src=\"\\1\"&gt;",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "&lt;b&gt;\\1&lt;/b&gt;",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "&lt;u&gt;\\1&lt;/u&gt;",<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "&lt;i&gt;\\1&lt;/i&gt;"<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; );<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $newText = preg_replace($patterns,$replacements, $text);<br />
<br />
at first it would collect ALL the tags into one link/bold/whatever, until i added the "?" i still dont fully understand it... but it works :)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="48037""></a>
  <div class="note">
   <strong class="user">J Daugherty</strong>
   <a href="#48037" class="date">09-Dec-2004 09:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In the character class meta-character documentation above, the circumflex (^) is described:<br />
<br />
"^&nbsp;&nbsp; negate the class, but only if the first character"<br />
<br />
It should be a little more verbose to fully express the meaning of ^:<br />
<br />
^&nbsp; &nbsp; Negate the character class.&nbsp; If used, this must be the first character of the class (e.g. "[^012]").</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="40863""></a>
  <div class="note">
   <strong class="user">napalm at spiderfish dot net</strong>
   <a href="#40863" class="date">17-Mar-2004 08:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Pay attention that some pcre features such as once-only or recursive patterns are not implemented in php versions prior to 5.00<br />
<br />
Napalm</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
