<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>POSIX 正则表达式函数</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="regex.examples.html">? 范例</a></li>
      <li style="float: right;"><a href="function.ereg-replace.html">ereg_replace ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="book.regex.html">POSIX Regex</a></li>
    <li>POSIX 正则表达式函数</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="ref.regex" class="reference">
 <h1 class="title">POSIX 正则表达式函数</h1>
 <div class="partintro">
  <h1 class="title">参见</h1>
  <div class="warning"><strong class="warning">Warning</strong>
   
<p class="para">
 This feature was <em class="emphasis">DEPRECATED</em> in PHP 5.3.0, and
 <em class="emphasis">REMOVED</em> in PHP 7.0.0.
</p>
<p class="para">
 Alternatives to this feature include:
</p>

   <ul class="simplelist">
    <li class="member">
     <a href="book.pcre.html" class="link">PCRE</a>
     （支持完整的正则表达式）
    </li>
    <li class="member">
     <span class="function"><a href="function.fnmatch.html" class="function">fnmatch()</a></span>
     （支持 shell 风格通配符的匹配）
    </li>
   </ul>
  </div>
 </div>

 


















































<h2>Table of Contents</h2><ul class="chunklist chunklist_reference"><li><a href="function.ereg-replace.html">ereg_replace</a> &mdash; 正则表达式替换</li><li><a href="function.ereg.html">ereg</a> &mdash; 正则表达式匹配</li><li><a href="function.eregi-replace.html">eregi_replace</a> &mdash; 不区分大小写的正则表达式替换</li><li><a href="function.eregi.html">eregi</a> &mdash; 不区分大小写的正则表达式匹配</li><li><a href="function.split.html">split</a> &mdash; 用正则表达式将字符串分割到数组中</li><li><a href="function.spliti.html">spliti</a> &mdash; 用正则表达式不区分大小写将字符串分割到数组中</li><li><a href="function.sql-regcase.html">sql_regcase</a> &mdash; 产生用于不区分大小的匹配的正则表达式</li></ul>
</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="109536""></a>
  <div class="note">
   <strong class="user">swordsteel</strong>
   <a href="#109536" class="date">27-Jul-2012 02:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
So i did like to get ü ? ? ? and some more in to my check for things.
<br />

<br />
<span class="default">&lt;?php
<br />
$chars </span><span class="keyword">= array(</span><span class="string">'à'</span><span class="keyword">, </span><span class="string">'á'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'è'</span><span class="keyword">, </span><span class="string">'é'</span><span class="keyword">, </span><span class="string">'ê'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'ì'</span><span class="keyword">, </span><span class="string">'í'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'ò'</span><span class="keyword">, </span><span class="string">'ó'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'ù'</span><span class="keyword">, </span><span class="string">'ú'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'ü'</span><span class="keyword">, </span><span class="string">'Y'</span><span class="keyword">, </span><span class="string">'T'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'à'</span><span class="keyword">, </span><span class="string">'á'</span><span class="keyword">, </span><span class="string">'a'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'è'</span><span class="keyword">, </span><span class="string">'é'</span><span class="keyword">, </span><span class="string">'ê'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'ì'</span><span class="keyword">, </span><span class="string">'í'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'e'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'ò'</span><span class="keyword">, </span><span class="string">'ó'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'ù'</span><span class="keyword">, </span><span class="string">'ú'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">, </span><span class="string">'y'</span><span class="keyword">, </span><span class="string">'y'</span><span class="keyword">, </span><span class="string">'t'</span><span class="keyword">, </span><span class="string">'?'</span><span class="keyword">);
<br />

<br />
</span><span class="default">$list </span><span class="keyword">= array();
<br />
foreach(</span><span class="default">$chars </span><span class="keyword">AS </span><span class="default">$char </span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$list</span><span class="keyword">[</span><span class="default">dechex</span><span class="keyword">(</span><span class="default">ord</span><span class="keyword">(</span><span class="default">$char</span><span class="keyword">))] = </span><span class="default">$char</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">ksort</span><span class="keyword">(</span><span class="default">$list</span><span class="keyword">);
<br />
foreach (</span><span class="default">$list </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$val</span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"</span><span class="default">$key</span><span class="string"> = </span><span class="default">$val</span><span class="string">, "</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
that gave me this
<br />

<br />
c0 = à, c1 = á, c2 = ?, c3 = ?, c4 = ?, c5 = ?, c6 = ?, c7 = ?, c8 = è, c9 = é, ca = ê, cb = ?, cc = ì, cd = í, ce = ?, cf = ?, d1 = ?, d2 = ò, d3 = ó, d4 = ?, d5 = ?, d6 = ?, d8 = ?, d9 = ù, da = ú, db = ?, dc = ü, dd = Y, de = T, df = ?, e0 = à, e1 = á, e2 = a, e3 = ?, e4 = ?, e5 = ?, e6 = ?, e7 = ?, e8 = è, e9 = é, ea = ê, eb = ?, ec = ì, ed = í, ee = ?, ef = ?, f0 = e, f1 = ?, f2 = ò, f3 = ó, f4 = ?, f5 = ?, f6 = ?, f8 = ?, f9 = ù, fa = ú, fb = ?, fd = y, fe = t, ff = ?
<br />

<br />
and that is if you make it smaller...
<br />

<br />
\\xC0-\\xD6 \\xD8-\\xF6 \\xF8-\\xFB \\xFD-\\xFF
<br />

<br />
Hope this help some one with ü ? ? ?</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74258""></a>
  <div class="note">
   <strong class="user">Edward Z. Yang</strong>
   <a href="#74258" class="date">01-Apr-2007 10:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The fact that 'regex' functions are not binary safe have some very important security implications for people who are using ereg to validate their input data.<br />
<br />
Suppose I have an expression:<br />
<br />
<span class="default">&lt;?php<br />
$pattern </span><span class="keyword">= </span><span class="string">'^[[:alnum:]]*$'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
This should match any number of alphanumeric characters, right? Well, if the string you're matching is not binary, sure. However, say we have a null-byte tossed in the string:<br />
<br />
<span class="default">&lt;?php<br />
$string </span><span class="keyword">= </span><span class="default">chr</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">) . </span><span class="string">"&lt;script&gt;alert('xss')&lt;/script&gt;"</span><span class="keyword">;<br />
echo </span><span class="default">ereg</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Will return true. Note that it is trivially easy to inject null bytes into PHP parameters:<br />
<br />
index.php?content=%00ASCII<br />
<br />
Scary. So unless you really know what you're doing, just use the PCRE preg_* functions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="61606""></a>
  <div class="note">
   <strong class="user">nate[-at-]theklaibers[-dot-]com</strong>
   <a href="#61606" class="date">07-Feb-2006 12:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I am using a regex with the same thought process in mind as the earlier phone number. However, I have also implemented it to allow the '1' so a number like.<br />
<br />
1 222 222 2222 would still be valid as well (along with all of the other combinations.<br />
<br />
In my regex, I pull out the matches - not the exact string. So if someone were to forget a bracket, it wouldnt matter to the actual output as it is stripped from that match.<br />
<br />
So, if you put in 222) 233 3454, the matches would only pull out 1=&gt;222, 2=&gt;233, 3=&gt;3454<br />
<br />
This has been very helpful in tweaking my regex.<br />
<br />
Thanks,<br />
Nate</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56101""></a>
  <div class="note">
   <strong class="user">ajd at cloudiness dot com</strong>
   <a href="#56101" class="date">23-Aug-2005 09:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A minor tweak to trucex' phone validator, because some people use a dot separator between the area code, exchange and four-digit block.<br />
Posted here for your copy-and-paste convenience.<br />
<br />
$regex = '^[(]?[2-9]{1}[0-9]{2}[) -.]{0,2}' . '[0-9]{3}[- .]?' . '[0-9]{4}[ ]?' . '((x|ext)[.]?[ ]?[0-9]{1,5})?$';</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55310""></a>
  <div class="note">
   <strong class="user">nothing at nothing dot com</strong>
   <a href="#55310" class="date">29-Jul-2005 03:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
His regular expression is correct, the ^ is to check for the beginning of the string. It is just looking for delimiter characters, try putting slashes around it.<br />
"/&lt;regex&gt;/"</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55275""></a>
  <div class="note">
   <strong class="user">stringer at stringerstudios dot com</strong>
   <a href="#55275" class="date">28-Jul-2005 05:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hey trucex. Cool phone number function but your $regex produces the following error. Warning: No ending delimiter '^' found<br />
<br />
Instead of:<br />
$regex = '^[(]?[2-9]{1}[0-9]{2}[) -]{0,2}' . '[0-9]{3}[- ]?' . '[0-9]{4}[ ]?' . '((x|ext)[.]?[ ]?[0-9]{1,5})?$';<br />
<br />
It think should be:<br />
$regex = '^[(]?[2-9]{1}[0-9]{2}[) -]{0,2}' . '[0-9]{3}[- ]?' . '[0-9]{4}[ ]?' . '((x|ext)[.]?[ ]?[0-9]{1,5})?$^';</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55208""></a>
  <div class="note">
   <strong class="user">trucex[at] gmail</strong>
   <a href="#55208" class="date">27-Jul-2005 11:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was having a ton of issues with other people's phone number validation expressions, so I made my own. It works with most US phone numbers, including those with extentions. Format matches any of the following formats:<br />
<br />
5551234567<br />
555 1234567<br />
555 123 4567<br />
555 123-4567<br />
555-1234567<br />
555-123-4567<br />
555123-4567<br />
(555)1234567<br />
(555)123 4567<br />
(555)123-4567<br />
(555) 1234567<br />
(555) 123-4567<br />
(555) 123 4567<br />
<br />
And any of the following extentions can be added with or without a space between them and the number:<br />
x123<br />
x.123<br />
x. 123<br />
x 123<br />
ext.123<br />
ext. 123<br />
ext 123<br />
ext123<br />
<br />
Extentions support between 1 and 5 digits. <br />
<br />
Here is the expression:<br />
<br />
$regex = '^[(]?[2-9]{1}[0-9]{2}[) -]{0,2}' . '[0-9]{3}[- ]?' . '[0-9]{4}[ ]?' . '((x|ext)[.]?[ ]?[0-9]{1,5})?$';<br />
<br />
Enjoy!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45485""></a>
  <div class="note">
   <strong class="user">annie</strong>
   <a href="#45485" class="date">08-Sep-2004 05:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another nice tutorial about regular expressions: <a href="http://www.mkssoftware.com/docs/man5/regexp.5.asp" rel="nofollow" target="_blank">http://www.mkssoftware.com/docs/man5/regexp.5.asp</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45462""></a>
  <div class="note">
   <strong class="user">tgt at tip dot nl</strong>
   <a href="#45462" class="date">08-Sep-2004 02:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Tip !<br />
Metacharacters in regular expresions are usefull and easy to use.<br />
<br />
The following is a set of special values that denote certain common ranges. They have the advantage that also take in account the 'locale' i.e. any variant of the local language/coding system.<br />
<br />
[:digit:]&nbsp; &nbsp; &nbsp; Only the digits 0 to 9 <br />
[:alnum:]&nbsp; &nbsp; &nbsp; Any alphanumeric character 0 to 9 OR A to Z or a to z. <br />
[:alpha:]&nbsp; &nbsp; &nbsp;&nbsp; Any alpha character A to Z or a to z. <br />
[:blank:]&nbsp; &nbsp; &nbsp;&nbsp; Space and TAB characters only. <br />
[:xdigit:]&nbsp; &nbsp;&nbsp; . <br />
[:punct:]&nbsp; &nbsp; &nbsp;&nbsp; Punctuation symbols . , " ' ? ! ; : <br />
[:print:]&nbsp; &nbsp; &nbsp; Any printable character. <br />
[:space:]&nbsp; &nbsp; &nbsp; Any space characters. <br />
[:graph:]&nbsp; &nbsp; &nbsp;&nbsp; . <br />
[:upper:]&nbsp; &nbsp; &nbsp;&nbsp; Any alpha character A to Z. <br />
[:lower:]&nbsp; &nbsp; &nbsp;&nbsp; Any alpha character a to z. <br />
[:cntrl:]&nbsp; &nbsp; &nbsp; &nbsp; .</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="36704""></a>
  <div class="note">
   <strong class="user">mina86 at tlen dot pl</strong>
   <a href="#36704" class="date">19-Oct-2003 10:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I tested how fast POSIX and Perl regular expresions are, and here are the results:<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | POSIX Extended&nbsp; | Perl-Compatible |&nbsp;&nbsp; POSIX - Perl<br />
-----------+-----------------+-----------------+-----------------<br />
&nbsp;&nbsp; &nbsp; match |&nbsp; &nbsp; 0.1296420097 |&nbsp; &nbsp; 0.1006720066 |&nbsp; 0.0289700031<br />
&nbsp;&nbsp; match i |&nbsp; &nbsp; 0.1204010248 |&nbsp; &nbsp; 0.1101620197 |&nbsp; 0.0102390051<br />
&nbsp;&nbsp; replace |&nbsp; &nbsp; 0.1896649599 |&nbsp; &nbsp; 0.1298999786 |&nbsp; 0.0597649813<br />
&nbsp;replace i |&nbsp;&nbsp; 10.6998120546 |&nbsp; &nbsp; 0.1453789473 | 10.5544331074<br />
<br />
So, as you can see, preg_* functions are faster then ereg* functions. You can find source code of my test script here: <a href="http://mina86.home.staszic.waw.pl/temp/regexp-speed-test.txt" rel="nofollow" target="_blank">http://mina86.home.staszic.waw.pl/temp/regexp-speed-test.txt</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="28517""></a>
  <div class="note">
   <strong class="user">Robin</strong>
   <a href="#28517" class="date">15-Jan-2003 10:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Ever wondered how to exclude "[" and "]"?<br />
Here it goes: "[^][]". Extra characters to exclude can beadded right in the middle like this: "[^]fobar[]".</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25043""></a>
  <div class="note">
   <strong class="user">paper</strong>
   <a href="#25043" class="date">08-Sep-2002 11:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have also experienced the same problem as bps7j@yahoo.com had been experiencing, except I did not recognize the problem until after many hours of debugging.<br />
<br />
"\s" does not seem to represent spaces, however "[[:space:]]" does.<br />
<br />
Another problem I was having was matching dashes/hyphens '-'. You must escape them "\-" and place them at the end of a bracket expression.<br />
<br />
Example: To match a blank string or a string containing only uppercase letters, underscores, spaces, and hyphens:<br />
<br />
^([A-Z_\-]|[[:space:]])*$<br />
<br />
Hope this saves someone some time from debugging like I was. :)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="24578""></a>
  <div class="note">
   <strong class="user">bps7j at yahoo dot com</strong>
   <a href="#24578" class="date">21-Aug-2002 07:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Something that really got me: I'm used to using Perl's regexps, and so I used \s to check for a whitespace character in a password on a website. My PHP book (Wrox Press, Professional PHP Programming) agreed with me that this is exactly the same as [ \r\n\t\f\v], but it's NOT. In fact, what it did was keep anyone from joining the site if they put an 's' in their password! So beware, check for subtle differences between what you're used to and PHP.<br />
<br />
[[:space:]] works fine, by the way.<br />
<br />
I'm going to use the pcre functions from now on... I like Perl :o)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19744""></a>
  <div class="note">
   <strong class="user">david at NOgreenhammerSPAM dot com</strong>
   <a href="#19744" class="date">09-Mar-2002 10:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Sadly, the Posix regexp evaluator (PHP 4.1.2) does not seem to support multi-character coallating sequences, even though such sequences are included in the man-page documentation.<br />
<br />
Specifically, the man-page discusses the expression "[[.ch.]]*c" which matches the first five characters of "chchcc".&nbsp; Running this expression in ereg_replace generates the error "Warning: REG_ECOLLATE".&nbsp; (Running an equivalent expression with only one character between the periods does work, however.)<br />
<br />
Multi-character coallating sequences are not supported!<br />
<br />
This is really, really too bad, because it would have provided a simple way to exlude words from the target.<br />
<br />
I'm going to go learn PCRE, now.&nbsp; :-(</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19702""></a>
  <div class="note">
   <strong class="user">regex at dan42 dot cjb dot net</strong>
   <a href="#19702" class="date">07-Mar-2002 10:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Follow-up to my previous post:<br />
Some simple optimization allowed me to realize that excluding a word at the beginning of a string has a degree of complexity O(n) rather than O(n^2). I only had to follow the logic:<br />
<br />
if str[0] != badword[0] then OK<br />
else<br />
&nbsp; if str[1] != badword[1] then OK<br />
&nbsp; else<br />
&nbsp;&nbsp;&nbsp; if str[2] != badword[2] then OK<br />
&nbsp;&nbsp;&nbsp; else ...<br />
<br />
So excluding the word 'abc' at the beginning of a string is much more simple than I had made it out to be:<br />
&nbsp; ^([^a]|a[^b]|ab[^c])</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19660""></a>
  <div class="note">
   <strong class="user">spiceee at potentialvalleys dot com</strong>
   <a href="#19660" class="date">06-Mar-2002 10:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
sorry to be picky here but saying ^ is beginning of a line or $ is end of line is rather misleading, if you're working on a daily basis with regexes.<br />
<br />
it might be that it is most of the time correct BUT in some occasions you'd be better off to think of ^ as "start of string" and $ as "end of string".<br />
<br />
there are ways to make your regex engine forget about your system's notion of a newline, it's what is commonly refered to as multiline regexes...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19555""></a>
  <div class="note">
   <strong class="user">luciano_at_braziliantranslation.net</strong>
   <a href="#19555" class="date">03-Mar-2002 12:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
mholdgate wrote a very nice quick reference guide in the next page (<a href="http://www.php.net/manual/en/function.ereg.php" rel="nofollow" target="_blank">http://www.php.net/manual/en/function.ereg.php</a>), but I felt it could be improved a little:<br />
________________<br />
<br />
^&nbsp; &nbsp; &nbsp; &nbsp; Start of line<br />
$&nbsp; &nbsp; &nbsp; &nbsp; End of line<br />
n?&nbsp; &nbsp; &nbsp; &nbsp; Zero or only one single occurrence of character 'n'<br />
n*&nbsp; &nbsp; &nbsp; &nbsp; Zero or more occurrences of character 'n'<br />
n+&nbsp; &nbsp; &nbsp; &nbsp; At least one or more occurrences of character 'n'<br />
n{2}&nbsp; &nbsp; &nbsp; &nbsp; Exactly two occurrences of 'n'<br />
n{2,}&nbsp; &nbsp; &nbsp; &nbsp; At least 2 or more occurrences of 'n'<br />
n{2,4}&nbsp; &nbsp; &nbsp; &nbsp; From 2 to 4 occurrences of 'n'<br />
.&nbsp; &nbsp; &nbsp; &nbsp; Any single character<br />
()&nbsp; &nbsp; &nbsp; &nbsp; Parenthesis to group expressions<br />
(.*)&nbsp; &nbsp; &nbsp; &nbsp; Zero or more occurrences of any single character, ie, anything!<br />
(n|a)&nbsp; &nbsp; &nbsp; &nbsp; Either 'n' or 'a'<br />
[1-6]&nbsp; &nbsp; &nbsp; &nbsp; Any single digit in the range between 1 and 6<br />
[c-h]&nbsp; &nbsp; &nbsp; &nbsp; Any single lower case letter in the range between c and h<br />
[D-M]&nbsp; &nbsp; &nbsp; &nbsp; Any single upper case letter in the range between D and M<br />
[^a-z]&nbsp; &nbsp; &nbsp; &nbsp; Any single character EXCEPT any lower case letter between a and z.<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Pitfall: the ^ symbol only acts as an EXCEPT rule if it is the <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; very first character inside a range, and it denies the <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; entire range including the ^ symbol itself if it appears again <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; later in the range. Also remember that if it is the first <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; character in the entire expression, it means "start of line". <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; In any other place, it is always treated as a regular ^ symbol.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; In other words, you cannot deny a word with ^undesired_word <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; or a group with ^(undesired_phrase).<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Read more detailed regex documentation to find out what is <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; necessary to achieve this.<br />
<br />
[_4^a-zA-Z]&nbsp; &nbsp; Any single character which can be the underscore or the <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; number 4 or the ^ symbol or any letter, lower or upper case<br />
<br />
?, +, * and the {} count parameters can be appended not only to a single character, but also to a group() or a range[].<br />
<br />
therefore,<br />
^.{2}[a-z]{1,2}_?[0-9]*([1-6]|[a-f])[^1-9]{2}a+$<br />
would mean:<br />
<br />
^.{2}&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = A line beginning with any two characters, <br />
[a-z]{1,2}&nbsp; &nbsp;&nbsp; = followed by either 1 or 2 lower case letters, <br />
_?&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = followed by an optional underscore, <br />
[0-9]*&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = followed by zero or more digits, <br />
([1-6]|[a-f])&nbsp; &nbsp;&nbsp; = followed by either a digit between 1 and 6 OR a <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; lower case letter between a and f, <br />
[^1-9]{2}&nbsp; &nbsp;&nbsp; = followed by any two characters except digits <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; between 1 and 9 (0 is possible), <br />
a+$&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = followed by at least one or more <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; occurrences of 'a' at the end of a line.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="19254""></a>
  <div class="note">
   <strong class="user">regex at dan42 dot cjb dot net</strong>
   <a href="#19254" class="date">20-Feb-2002 09:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It's easy to exclude characters but excluding words with a regular expression is a bit more tricky. For parentheses there is no equivalent to the ^ for brackets. The only way I've found to exclude a string is to proceed by inverse logic: accept all the words that do NOT correspond to the string. So if you want to accept all strings except those _begining_ with "abc", you'd have to accept any string that matches one of the following:<br />
&nbsp; ^(ab[^c])<br />
&nbsp; ^(a[^b]c)<br />
&nbsp; ^(a[^b][^c])<br />
&nbsp; ^([^a]bc)<br />
&nbsp; ^([^a]b[^c])<br />
&nbsp; ^([^a][^b]c)<br />
&nbsp; ^([^a][^b][^c])<br />
<br />
which, put together, gives the regex<br />
&nbsp; ^(ab[^c]|a[^b]c|a[^b][^c]|[^a]bc|[^a]b[^c]|[^a][^b]c|[^a][^b][^c])<br />
<br />
Note that this won't work to detect the word "abc" anywhere in a string. You need to have some way of anchoring the inverse word match<br />
like: ^(a[^b]|[^a]b|[^a][^b])&nbsp;&nbsp; ;"ab" not at begining of line<br />
&nbsp; or: (a[^b]|[^a]b|[^a][^b])&amp;&nbsp;&nbsp; ;"ab" not at end of line<br />
&nbsp; or: 123(a[^b]|[^a]b|[^a][^b]) ;"ab" not after "123"<br />
<br />
I don't know why "(abc){0,0}" is an invalid synthax. It would've made all this much simpler.<br />
&nbsp;<br />
&nbsp;<br />
Slightly off-topic, here's a regex date validator (format yyyy-mm-dd, remove all spaces and linefeeds):<br />
&nbsp; ^(19|20)([0-9]{2}-((0[13-9]|1[0-2])-(0[1-9]|[12][0-9]|30)|<br />
&nbsp; (0[13578]|1[02])-31|02-(0[1-9]|1[0-9]|2[0-8]))|([2468]0|<br />
&nbsp; [02468][48]|[13579][26])-02-29)$</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="18732""></a>
  <div class="note">
   
   <a href="#18732" class="date">02-Feb-2002 07:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if you are looking for the abbreviations like tab, carriage return, regex-class definitions&nbsp; <br />
<br />
you should look here: <br />
<a href="http://elvin.dstc.edu.au/doc/regex.html" rel="nofollow" target="_blank">http://elvin.dstc.edu.au/doc/regex.html</a><br />
<br />
some excerpts:<br />
<br />
&nbsp;&nbsp;&nbsp; \a&nbsp; &nbsp; control characters bell<br />
&nbsp;&nbsp;&nbsp; \b&nbsp; &nbsp; backspace<br />
&nbsp;&nbsp;&nbsp; \f&nbsp; &nbsp; form feed<br />
&nbsp;&nbsp;&nbsp; \n&nbsp; &nbsp; line feed<br />
&nbsp;&nbsp;&nbsp; \r&nbsp; &nbsp; carriage return<br />
&nbsp;&nbsp;&nbsp; \t&nbsp; &nbsp; horizontal tab<br />
&nbsp;&nbsp;&nbsp; \v&nbsp; &nbsp; vertical tab<br />
<br />
class example<br />
&nbsp;&nbsp;&nbsp; \cLu&nbsp; &nbsp; all uppercase letters</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
