<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>输出文件指针处的所有剩余数据</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.fopen.html">? fopen</a></li>
      <li style="float: right;"><a href="function.fputcsv.html">fputcsv ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.filesystem.html">文件系统函数</a></li>
    <li>输出文件指针处的所有剩余数据</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.fpassthru" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">fpassthru</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">fpassthru</span> &mdash; <span class="dc-title">输出文件指针处的所有剩余数据</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.fpassthru-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>fpassthru</strong></span>
    ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$handle</code></span>
   ) : <span class="type">int</span></div>

  
  <p class="para rdfs-comment">
   将给定的文件指针从当前的位置读取到 EOF 并把结果写到输出缓冲区。
  </p>
  
  <p class="para">
   如果已经向文件写入数据，就必须调用 <span class="function"><a href="function.rewind.html" class="function">rewind()</a></span>
   来将文件指针指向文件头。
  </p>
  <p class="para">
   如果既不修改文件也不在特定位置检索，只想将文件的内容下载到输出缓冲区，应该使用
   <span class="function"><a href="function.readfile.html" class="function">readfile()</a></span>，这样可以省去
   <span class="function"><a href="function.fopen.html" class="function">fopen()</a></span> 调用。
  </p>
 </div>

  <div class="refsect1 parameters" id="refsect1-function.fpassthru-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">handle</code></dt>

     <dd>

      <p class="para">文件指针必须是有效的，必须指向由
<span class="function"><a href="function.fopen.html" class="function">fopen()</a></span> 或 <span class="function"><a href="function.fsockopen.html" class="function">fsockopen()</a></span> 成功打开的文件(并还未由 <span class="function"><a href="function.fclose.html" class="function">fclose()</a></span> 关闭)。</p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.fpassthru-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   如果发生错误， <span class="function"><strong>fpassthru()</strong></span> 返回 <strong><code>false</code></strong>。否则
   <span class="function"><strong>fpassthru()</strong></span> 返回从 <code class="parameter">handle</code>
   读取并传递到输出的字符数目。
  </p>
 </div>

 <div class="refsect1 examples" id="refsect1-function.fpassthru-examples">
  <h3 class="title">范例</h3>
  <p class="para">
   <div class="example" id="example-2561">
    <p><strong>Example #1 对二进制文件使用 <span class="function"><strong>fpassthru()</strong></span></strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #FF8000">//&nbsp;以二进制格式打开文件<br /></span><span style="color: #0000BB">$name&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'./img/ok.png'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$fp&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">fopen</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'rb'</span><span style="color: #007700">);<br /><br /></span><span style="color: #FF8000">//&nbsp;发送合适的报头<br /></span><span style="color: #0000BB">header</span><span style="color: #007700">(</span><span style="color: #DD0000">"Content-Type:&nbsp;image/png"</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">header</span><span style="color: #007700">(</span><span style="color: #DD0000">"Content-Length:&nbsp;"&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">filesize</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">));<br /><br /></span><span style="color: #FF8000">//&nbsp;发送图片并终止脚本<br /></span><span style="color: #0000BB">fpassthru</span><span style="color: #007700">(</span><span style="color: #0000BB">$fp</span><span style="color: #007700">);<br />exit;<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.fpassthru-notes">
  <h3 class="title">注释</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    当在 Windows
    系统中将 <span class="function"><strong>fpassthru()</strong></span>
    用于二进制文件，要确保在用
    <span class="function"><a href="function.fopen.html" class="function">fopen()</a></span>
    打开文件时在 mode 中附加了
    <code class="literal">b</code> 来将文件以二进制方式打开。
   </p>
   <p class="para">
    鼓励在处理二进制文件时使用
    <code class="literal">b</code>
    标志，即使系统并不需要，这样可以使脚本的移植性更好。
   </p>
  </p></blockquote>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.fpassthru-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.readfile.html" class="function" rel="rdfs-seeAlso">readfile()</a> - 输出文件</span></li>
    <li class="member"><span class="function"><a href="function.fopen.html" class="function" rel="rdfs-seeAlso">fopen()</a> - 打开文件或者 URL</span></li>
    <li class="member"><span class="function"><a href="function.popen.html" class="function" rel="rdfs-seeAlso">popen()</a> - 打开进程文件指针</span></li>
    <li class="member"><span class="function"><a href="function.fsockopen.html" class="function" rel="rdfs-seeAlso">fsockopen()</a> - 打开一个网络连接或者一个Unix套接字连接</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="112360""></a>
  <div class="note">
   <strong class="user">RaulentRoi</strong>
   <a href="#112360" class="date">06-Jun-2013 02:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Passthru didn't work for me for files greater than about 5Mb. Just adding "ob_end_clean()", all works fine now, including &gt; 50Mb files.<br />
<br />
$ToProtectedFile=$pathUnder.$filename<br />
$handle = @fopen($ToProtectedFile, "rb");<br />
<br />
@header("Cache-Control: no-cache, must-revalidate"); <br />
@header("Pragma: no-cache"); //keeps ie happy<br />
@header("Content-Disposition: attachment; filename= ".$NomFichier);<br />
@header("Content-type: application/octet-stream");<br />
@header("Content-Length: ".$SizeOfFile);<br />
@header('Content-Transfer-Encoding: binary');<br />
<br />
ob_end_clean();//required here or large files will not work<br />
@fpassthru($handle);//works fine now</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74373""></a>
  <div class="note">
   <strong class="user">public at telcontar dot net</strong>
   <a href="#74373" class="date">08-Apr-2007 01:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
(Do not delete this, it is NOT a bug report. It is a *follow up* to vague comments on the page about fpassthru() using excessive memory, and a usage tip that if you want to use pass-through processing, PHP 5 is strongly advised. It may LOOK like a bug report because unlike earlier tips, I've tried to clarify the situation. It is not a bug report because the problem is RESOLVED in PHP 5. Rather, anyone still using PHP 4 (for example, for compatibility reasons) should simply be aware that the problem is now resolved.)<br />
<br />
In PHP 4 (4.4.4 tested as a CGI, Apache 2, Linux), use of both fpassthru() and fread() in a loop suffer the SAME memory "leakage". This is characterised by all data that is sent to the client also being kept inside PHP and not released. It would appear to be a failure to garbage collect the data.<br />
<br />
In PHP 5 (5.2.1 tested as a CGI, Apache 2, Linux) this flaw is resolved in both cases. Neither fpassthru() nor fread() in a loop "leak" memory during execution.<br />
<br />
The issue of which one to use appears not to be an issue of memory as both were equally flawed in PHP 4 and both are equally fixed in PHP 5.<br />
<br />
Speed, is left to a reader exercise to test in the latest PHPs.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74080""></a>
  <div class="note">
   <strong class="user">sarabas at itstudio dot pl</strong>
   <a href="#74080" class="date">23-Mar-2007 02:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In case of multiple buffering possibility try running ob_end_clean() from the example below in a loop:<br />
<br />
while (@ob_end_clean());<br />
<br />
It will help for example in case of automatic gz compression of output.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58042""></a>
  <div class="note">
   <strong class="user">file downloads verified by session vars</strong>
   <a href="#58042" class="date">21-Oct-2005 08:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
here is my code, i tried several combinations, but most of them didnt work, and had all kinds of unnecessary headers in them, etc. this has additional good features, such as it stops sending the file if the connection stops (hopefully it does anyways), and it fixes IE filename problems when sending files that contain more than one dot in them by using a simple&nbsp; preg_replace (IE likes to terminate the filename and messes everything up):<br />
<br />
&lt;?<br />
function send_file($path) {<br />
&nbsp;&nbsp;&nbsp; session_write_close();<br />
&nbsp;&nbsp;&nbsp; ob_end_clean();<br />
&nbsp;&nbsp;&nbsp; if (!is_file($path) || connection_status()!=0)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return(FALSE);<br />
<br />
&nbsp;&nbsp;&nbsp; //to prevent long file from getting cut off from&nbsp; &nbsp;&nbsp; //max_execution_time<br />
<br />
&nbsp;&nbsp;&nbsp; set_time_limit(0);<br />
<br />
&nbsp;&nbsp;&nbsp; $name=basename($path);<br />
<br />
&nbsp;&nbsp;&nbsp; //filenames in IE containing dots will screw up the<br />
&nbsp;&nbsp;&nbsp; //filename unless we add this<br />
<br />
&nbsp;&nbsp;&nbsp; if (strstr($_SERVER['HTTP_USER_AGENT'], "MSIE"))<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $name = preg_replace('/\./', '%2e', $name, substr_count($name, '.') - 1);<br />
<br />
&nbsp;&nbsp;&nbsp; //required, or it might try to send the serving&nbsp; &nbsp;&nbsp; //document instead of the file<br />
<br />
&nbsp;&nbsp;&nbsp; header("Cache-Control: ");<br />
&nbsp;&nbsp;&nbsp; header("Pragma: ");<br />
&nbsp;&nbsp;&nbsp; header("Content-Type: application/octet-stream");<br />
&nbsp;&nbsp;&nbsp; header("Content-Length: " .(string)(filesize($path)) );<br />
&nbsp;&nbsp;&nbsp; header('Content-Disposition: attachment; filename="'.$name.'"');<br />
&nbsp;&nbsp;&nbsp; header("Content-Transfer-Encoding: binary\n");<br />
<br />
&nbsp;&nbsp;&nbsp; if($file = fopen($path, 'rb')){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; while( (!feof($file)) &amp;&amp; (connection_status()==0) ){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; print(fread($file, 1024*8));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flush();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; fclose($file);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return((connection_status()==0) and !connection_aborted());<br />
}<br />
<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55519""></a>
  <div class="note">
   <strong class="user">jonathan at corporacionlinux dot cl</strong>
   <a href="#55519" class="date">05-Aug-2005 08:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
While trying to "passthru" a file to the browser via PHP, but using the FEOF loop, the script tried to buffer the entire file before passing it to the browser. This is my original script. When calling it with a 15M PHP memory limit and a 16M file, apache killed the script.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $name </span><span class="keyword">= </span><span class="default">$tempDir </span><span class="keyword">. </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"file"</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$fd </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">, </span><span class="string">'rb'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$fd </span><span class="keyword">== </span><span class="default">false</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; die(</span><span class="string">"&lt;font color=red&gt;ERROR: File not found.&lt;/font&gt;"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// send the right headers<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Cache-Control: "</span><span class="keyword">);</span><span class="comment">// leave blank to avoid IE errors<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Pragma: "</span><span class="keyword">);</span><span class="comment">// leave blank to avoid IE errors<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-type: application/octet-stream"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-Disposition: attachment; filename=\"" </span><span class="keyword">. </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"file"</span><span class="keyword">] . </span><span class="string">"\""</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-length:"</span><span class="keyword">.(string)(</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">)));<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_write_close</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_flush</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">flush</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; while(!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$buffer </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">, </span><span class="default">2048</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print </span><span class="default">$buffer</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }<br />
&nbsp;&nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">fclose </span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; exit;<br />
</span><span class="default">?&gt;<br />
</span><br />
Apache error log read:<br />
Allowed memory size of 15728640 bytes exhausted (tried to allocate 10240 bytes)<br />
<br />
I tried everything, including a flush() inside the loop. But the solution was forcing the flush other way: <br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; $buffer </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">, </span><span class="default">32 </span><span class="keyword">* </span><span class="default">1024</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
voila... works just fine for me.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="48244""></a>
  <div class="note">
   <strong class="user">webmaster at hardcorehoneyz dot com</strong>
   <a href="#48244" class="date">16-Dec-2004 05:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In relation to using sessions and fpassthru together.<br />
<br />
Try adding: session_write_close()<br />
<br />
somewhere near the top of the download script, before you start sending the video, and that should take care of it.<br />
<br />
I've implemented and tested session_write_close() and it works like a dream. Other links can now be clicked and loaded whilst a big file is being passed using fpassthru.<br />
<br />
Big thanks to Greg for this tip. What a helpful community we live in :0)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47937""></a>
  <div class="note">
   <strong class="user">webmaster at hardcorehoneyz dot com</strong>
   <a href="#47937" class="date">06-Dec-2004 05:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I believe the following problem is a result of using sessions and fpassthru together.<br />
<br />
I have a subscription based site which protects large video files (WMV format between 100-120MB) by storing them beneath web root. Downloading a video file requires the user to click a HTML link which requests a PHP script e.g. download-video.php?video_id=123. If the user is valid (session vars created from sucessful login) the script then creates the necessary headers to trigger a 'Save As' download box, opens the file from beneath web root and sends it using fpassthru.<br />
<br />
The problem is as follows:<br />
<br />
The user should be able to click other links on the site whilst a file is downloading. But when they do so, the requested page won't load until the download is complete.<br />
<br />
As this download script is a seperate PHP request, the user should be able to load other pages on the site whilst the file is downloading.<br />
<br />
At time of writing, I've tried almost everything to remove this bug. There must be a problem with using a PHP script rather than a direct web server link to download files.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47411""></a>
  <div class="note">
   <strong class="user">lbaudrillard at hotmail dot com</strong>
   <a href="#47411" class="date">15-Nov-2004 12:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The way the PHP page is generated (buffered or not, and how if buffered) has an impact of the download function made using fpassthru (or fread, ...). I mean a download function may work just fine when it is called from a simple php file (no buffering here): <br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">download</span><span class="keyword">(</span><span class="default">$file</span><span class="keyword">) { ... }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$filename </span><span class="keyword">= </span><span class="string">"/tmp/test.zip"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">download</span><span class="keyword">(</span><span class="default">$filename</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>&nbsp; &nbsp; <br />
<br />
but may fails "in the real life" when the page is buffered:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; ob_start</span><span class="keyword">(</span><span class="string">"ob_gzhandler"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; require_once(</span><span class="default">download</span><span class="keyword">.</span><span class="default">php</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$filename </span><span class="keyword">= </span><span class="string">"/files/file.zip"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">download</span><span class="keyword">(</span><span class="default">$filename</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
In my particular case, only Firefox 1.0 English did not perform the download, because of the ob_start("ob_gzhandler"). Replacing it by ob_start() solved the problem.<br />
<br />
Hope that helps <br />
Laurent from Paris, France</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47110""></a>
  <div class="note">
   <strong class="user">phpnet at -remove-me-uchange dot co dot uk</strong>
   <a href="#47110" class="date">03-Nov-2004 05:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've modified the example given by straz at -removethispart-mac dot com to count each byte of the file out.&nbsp; This can then be compared with the filesize once the file sending is complete to determine whether the file was sent succesfully or not.<br />
<br />
Of course, this doesn't guarantee that the user actually recieved the file successfully though will let us know if something goes wrong half way through reading/sending the file at our end.<br />
<br />
&lt;?<br />
/* fpassthru is apparantly a memory-hog. Use this instead */<br />
&nbsp;&nbsp;&nbsp; while(!feof($fp)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $buf = fread($fp, 4096);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo $buf;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $bytesSent+=strlen($buf);&nbsp; &nbsp; /* We know how many bytes were sent to the user */<br />
&nbsp;&nbsp;&nbsp; }<br />
?&gt;<br />
<br />
I've then got this code to update my database to say that the file was downloaded successfully.<br />
<br />
&lt;?<br />
&nbsp;&nbsp;&nbsp; if($bytesSent==filesize($file)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; /* Do some cool stuff here! */<br />
&nbsp;&nbsp;&nbsp; }<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42557""></a>
  <div class="note">
   <strong class="user">nexz2004 at yahoo dot com</strong>
   <a href="#42557" class="date">21-May-2004 12:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
also it is possible to make your php script resume downloads, to do this you need to check $_SERVER['HTTP_RANGE'] which may contain something like this<br />
&nbsp;"bytes=10-" - resume from position 10, and to end of file<br />
<br />
when sending response it is also needed to send with headers<br />
Accept-Ranges: bytes<br />
Content-Length: {filesize}<br />
Content-Range: bytes 10-{filesize-1}/{ffilesize}<br />
<br />
hope its usefull</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="39916""></a>
  <div class="note">
   <strong class="user">axx at axxess dot ca</strong>
   <a href="#39916" class="date">15-Feb-2004 01:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have also perused this list of examples which I am sure work for that person, but, as others have mentioned here, do not work for me or (anyone else).<br />
<br />
So what I did was try out all of these examples, check other sources of information, and put together what I think to be an example of what works on 'more than a few' systems.&nbsp; The following example works for me wherever I need to create a download using fpassthru(), which works with IE6 (among other browsers):<br />
<br />
&lt;?<br />
/*/<br />
Download a file using fpassthru()<br />
/*/<br />
$fileDir = "/home/pathto/myfiles"; // supply a path name.<br />
$fileName = "myfile.zip"; // supply a file name.<br />
$fileString=$fileDir.'/'.$fileName; // combine the path and file<br />
// translate file name properly for Internet Explorer.<br />
if (strstr($_SERVER['HTTP_USER_AGENT'], "MSIE")){<br />
&nbsp; $fileName = preg_replace('/\./', '%2e', $fileName, substr_count($fileName, '.') - 1);<br />
}<br />
// make sure the file exists before sending headers<br />
if(!$fdl=@fopen($fileString,'r')){<br />
&nbsp;&nbsp;&nbsp; die("Cannot Open File!");<br />
} else {<br />
&nbsp; header("Cache-Control: ");// leave blank to avoid IE errors<br />
&nbsp; header("Pragma: ");// leave blank to avoid IE errors<br />
&nbsp; header("Content-type: application/octet-stream");<br />
&nbsp; header("Content-Disposition: attachment; filename=\"".$fileName."\"");<br />
&nbsp; header("Content-length:".(string)(filesize($fileString)));<br />
&nbsp;&nbsp;&nbsp; sleep(1);<br />
&nbsp;&nbsp;&nbsp; fpassthru($fdl);<br />
}<br />
?&gt;<br />
<br />
All that should require editing is the $fileDir and $fileName variables.&nbsp; Upload the file and point to it with your browser to see if the script will prompt you for a download.<br />
<br />
NOTE : Regarding File Types : Leaving the 'Content-type' header as-is should allow you to download pretty much any file.&nbsp; I have tested it on some of the more popular file types including zip, css, php, inc, htm, png, gif and jpg.&nbsp; During these tests, I did note that if I selected 'cancel' or 'open' when prompted to download either a gif or jpg, that it would indeed cancel or open in my image browser as it should, but subsequent attempts at 'downloading only' yielded a web page view of the image.&nbsp; Closing the window and opening a new one reset this, allowing me save a jpeg or gif to the hard drive directly.&nbsp; I believe the problem lies in the way the caching headers are treated, since if any info is specified in the 'cache-control' header, the browser download fails completely (in IE, anyways).<br />
<br />
Enjoy! Mail me if it works!&nbsp; ;-)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="39097""></a>
  <div class="note">
   <strong class="user">mm at tbwachiat dot com</strong>
   <a href="#39097" class="date">16-Jan-2004 05:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've tried all of these renditions of this elusive task.&nbsp; NONE of them have worked for me.&nbsp; And when i say work, i mean where i can click some sort of link and have a file Save As... dialog box come up on MSIE 6.0.&nbsp; In every other browser i've tried (Safari,Firebird,Netscape pc and mac) all have worked where it downloads to my desktop or asks me to save it in a certain place.<br />
<br />
on MSIE 6.0.&nbsp; the file i'm trying to download appears in it's own window. it's an image. BUT, the only thing i can do with it is SAVE IT AS A BMP. ugh.<br />
<br />
I'm using the fpassthru function because i have files that must not be served by the webserver.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="38896""></a>
  <div class="note">
   <strong class="user">The Otter</strong>
   <a href="#38896" class="date">10-Jan-2004 09:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reply to spam at flatwan dot net<br />
This might save someone some time. I created a program to list some rather large files and create links for the end user to click on in order to download them (using the php function fpassthru()).<br />
<br />
The problem I was having was it would make it half way through the download (about 377 megs) and the script would terminate and the download would stop.<br />
<br />
After doing some shotgun troubleshooting I discovered the php config option 'max_execution_time = 30'. Upon changing it to 'max_execution_time = -1' the files &gt;370 megs can be downloaded without the script aborting.<br />
<br />
The best way to do this would to be:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">@</span><span class="default">ignore_user_abort</span><span class="keyword">();<br />
@</span><span class="default">set_time_limit</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>This only changes these settings for the script that calls them. (Thanks to (I don't remember who) who wrote a form mail script that used these two lines)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37526""></a>
  <div class="note">
   <strong class="user">spam at flatwan dot net</strong>
   <a href="#37526" class="date">18-Nov-2003 04:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This might save someone some time. I created a program to list some rather large files and create links for the end user to click on in order to download them (using the php function fpassthru()).<br />
<br />
The problem I was having was it would make it half way through the download (about 377 megs) and the script would terminate and the download would stop.<br />
<br />
After doing some shotgun troubleshooting I discovered the php config option 'max_execution_time = 30'. Upon changing it to 'max_execution_time = -1' the files &gt;370 megs can be downloaded without the script aborting.<br />
<br />
Jon</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="32066""></a>
  <div class="note">
   <strong class="user">arabold AT nero DOT com</strong>
   <a href="#32066" class="date">15-May-2003 04:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a summary the different headers you need to set to make downloads *always* work with IE and Mozilla:<br />
<br />
[SNIP]<br />
&nbsp; $disposition = "inline"; // "inline" to view file in browser or "attachment" to download to hard disk<br />
&nbsp; $mime = "image/jpeg"; // or whatever the mime type is<br />
&nbsp; $name = "foo.jpg"; // file name<br />
&nbsp; $path = "/path/to/foo.jpg"; // full path and file name<br />
&nbsp;<br />
&nbsp; if (isset($_SERVER["HTTPS"])) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; /**<br />
&nbsp;&nbsp; &nbsp; &nbsp; * We need to set the following headers to make downloads work using IE in HTTPS mode.<br />
&nbsp;&nbsp; &nbsp; &nbsp; */<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Pragma: ");<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Cache-Control: ");<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Cache-Control: no-store, no-cache, must-revalidate"); // HTTP/1.1<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Cache-Control: post-check=0, pre-check=0", false);<br />
&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; else if ($disposition == "attachment") {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header("Cache-control: private");<br />
&nbsp; }<br />
&nbsp; else {<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Cache-Control: no-cache, must-revalidate");<br />
&nbsp;&nbsp; &nbsp;&nbsp; header("Pragma: no-cache");<br />
&nbsp; }<br />
&nbsp; header("Content-Type: $mime");<br />
&nbsp; header("Content-Disposition:$disposition; filename=\"".trim(htmlentities($name))."\"");<br />
&nbsp; header("Content-Description: ".trim(htmlentities($name)));<br />
&nbsp; header("Content-Length: ".(string)(filesize($path)));<br />
&nbsp; header("Connection: close");<br />
[/SNIP]<br />
<br />
This way all kinds of download work for me. Hope that helps</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31899""></a>
  <div class="note">
   <strong class="user">DarkAngela_ at hotmail dot com</strong>
   <a href="#31899" class="date">08-May-2003 04:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Just a little thing more from the ssharma's script (thx to him for his great help ...) :<br />
<br />
Don't forget to put the fopen with the "rb" argument and not just with the "r" <br />
or you won't be able to make the script work with all pdf file.<br />
<br />
My final script (working for Open and Save on a 1.9 Mb complex PDF file) :<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">//The filename is stored in the $produitFilename variable in my script (the only thing you need)<br />
<br />
// You need to specify the REAL path for your file and not the URL<br />
</span><span class="default">$fullPath&nbsp; &nbsp; </span><span class="keyword">= </span><span class="default">getcwd</span><span class="keyword">().</span><span class="string">"./directory_where_the_file_is/"</span><span class="keyword">.</span><span class="default">$produitFilename</span><span class="keyword">;<br />
<br />
if (</span><span class="default">$fd </span><span class="keyword">= </span><span class="default">fopen </span><span class="keyword">(</span><span class="default">$fullPath</span><span class="keyword">, </span><span class="string">"rb"</span><span class="keyword">)) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$fsize&nbsp; &nbsp; </span><span class="keyword">=</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$fullPath</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$fname&nbsp; &nbsp;&nbsp; </span><span class="keyword">= </span><span class="default">basename </span><span class="keyword">(</span><span class="default">$fullPath</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Pragma: "</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Cache-Control: "</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-type: application/octet-stream"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-Disposition: attachment; filename=\""</span><span class="keyword">.</span><span class="default">$fname</span><span class="keyword">.</span><span class="string">"\""</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-length: </span><span class="default">$fsize</span><span class="string">"</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">fpassthru</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Have fun and thx u all 4 ur great help ...<br />
<br />
Simon (from Paris - France)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30740""></a>
  <div class="note">
   <strong class="user">Omega2k at web dot de</strong>
   <a href="#30740" class="date">27-Mar-2003 05:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To throttle download-speed of specific files this works fine in my board hosted on my local machine:<br />
<br />
//#######################################<br />
&nbsp;$big_file=filesize($completeFilePath)/1024; //size of file in kb<br />
&nbsp;header('Content-Type: '.$mime_type);<br />
&nbsp;header('Content-disposition: '.$content_disp.'filename="'.$attachment_name.'"');<br />
&nbsp;header('Cache-Control: no-cache');<br />
&nbsp;header('Pragma: no-cache');<br />
&nbsp;header('Expires: 0');<br />
&nbsp;header('Content-Length: '.(string)(filesize($completeFilePath))); <br />
&nbsp;$fp=fopen($completeFilePath,'r');<br />
&nbsp;while(!feof($fp)) {<br />
&nbsp;&nbsp; &nbsp; $buffer = fread($fp, 1024*6); //speed-limit 6kb/s<br />
&nbsp;&nbsp; &nbsp; if ($big_file&gt;32 &amp;&amp; <br />
&nbsp;&nbsp; &nbsp; $extension!="jpg" &amp;&amp; <br />
&nbsp;&nbsp; &nbsp; $extension!="jpeg" &amp;&amp; <br />
&nbsp;&nbsp; &nbsp; $extension!="gif" &amp;&amp; <br />
&nbsp;&nbsp; &nbsp; $extension!="png" &amp;&amp; <br />
&nbsp;&nbsp; &nbsp; $extension!="txt")<br />
&nbsp;&nbsp; &nbsp; sleep(1); //if filesize&gt;32kb and no smallfile like jpg,gif or so - wait 1 second<br />
&nbsp;&nbsp; &nbsp; print $buffer;<br />
&nbsp;}<br />
&nbsp;fclose($fp);<br />
&nbsp;header ("Connection: close");<br />
//#######################################<br />
<br />
I think it's the easiest way to slow down downloading files without using a loop or for-next - this really saves performace of php and is quite exact by using 1024*number_of_kb in one second...<br />
<br />
Thats all<br />
<br />
Greetings, omega2k.dynu.com</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="29162""></a>
  <div class="note">
   <strong class="user">brett at NOSPAM dot brettbrewer dot com</strong>
   <a href="#29162" class="date">04-Feb-2003 02:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The above method worked for me after trying everything else imaginable to get Explorer to download a file via PHP. However, I had to change the content-length line. No need to "stringify" the $size variable as in the above post. The method below works for both small and very large file (tested on files larger than 30MB with no probs)...<br />
<br />
<span class="default">&lt;?php<br />
$distribution</span><span class="keyword">=</span><span class="string">"/path/to/a/file.exe"<br />
</span><span class="keyword">if (</span><span class="default">$fd </span><span class="keyword">= </span><span class="default">fopen </span><span class="keyword">(</span><span class="default">$distribution</span><span class="keyword">, </span><span class="string">"r"</span><span class="keyword">)){<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$size</span><span class="keyword">=</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$distribution</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$fname </span><span class="keyword">= </span><span class="default">basename </span><span class="keyword">(</span><span class="default">$distribution</span><span class="keyword">);<br />
<br />
</span><span class="comment">//This is some really weak code I used just to redirect to the file before I fixed<br />
//this problem...it makes the browser handle the download via Apache instead of PHP<br />
//but it would be really easy to then find out the true location of the file<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //header("Location: $distribution");<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //fclose ($fd);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //exit;<br />
<br />
//below is a much better way to do it...<br />
<br />
&nbsp;&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Pragma: "</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Cache-Control: "</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-type: application/octet-stream"</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-Disposition: attachment; filename=\""</span><span class="keyword">.</span><span class="default">$fname</span><span class="keyword">.</span><span class="string">"\""</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-length: </span><span class="default">$size</span><span class="string">"</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while(!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$buffer </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">, </span><span class="default">2048</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print </span><span class="default">$buffer</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose </span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exit;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Good luck.<br />
Brett Brewer.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="27274""></a>
  <div class="note">
   <strong class="user">shaun at nospam dot phplabs dot com</strong>
   <a href="#27274" class="date">29-Nov-2002 04:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that if you use these two headers from a previous example:<br />
<br />
header('Cache-Control: no-cache, must-revalidate');<br />
header('Pragma: no-cache');<br />
<br />
before sending a file to the browser, the "Open" option on Internet Explorer's file download dialog will not work properly. If the user clicks "Open" instead of "Save," the target application will open an empty file, because the downloaded file was not cached. The user will have to save the file to their hard drive in order to use it. <br />
<br />
Make sure to leave these headers out if you'd like your visitors to be able to use IE's "Open" option.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="27066""></a>
  <div class="note">
   <strong class="user">john at bvstudios dot com</strong>
   <a href="#27066" class="date">21-Nov-2002 12:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reply to:<br />
<br />
"3. Through no amount of futzing of headers was I able to get the filename to be set properly when the actual transfer was initiated via a refresh (META or via headers).&nbsp; I don't know if this is also an MSIE only issue or not.&nbsp; If 'download.php?dl=now' (for example) had a refresh back to 'download.php', such that it was intended to show some information (e.g. install instructions) as well as launch the download, then the MSIE insisted that the downloaded file was supposed to be named 'download.php?dl=now' or 'download.php', ignoring the filename in the headers."<br />
<br />
I recently had the exact same issue.&nbsp; What I found is that this was due to my session initialization on the page.&nbsp; For some reason doing a session_start() caused the script to try and download itself, not what I was indicating through various header() calls.<br />
<br />
The solution was to move the download portion above the session initialization.&nbsp; At first glance this may seem dangerous, but I only process it if there are POST vars and the script is reloading itself.&nbsp; This way I know the form was submitted by that page and before they can submit it, they have to have a session!&nbsp; Adding an .htaccess rule to deny all for the directory where the files are stored also helps because then only my script can access the files.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26563""></a>
  <div class="note">
   <strong class="user">mikek at nospam dot muonics dot c o m</strong>
   <a href="#26563" class="date">05-Nov-2002 02:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Found a workaround to another headache that just cropped up tonight.&nbsp; Apparently Opera 6.1 on Linux (unsure of other versions/platforms) has problems downloading files using the above methods if you have enabled compression via zlib.output_compression in php.ini.<br />
<br />
It seems that Opera sees that the actual transfer size is less than the size in the "Content-length" header for the download and decides that the transfer was incomplete or corrupted.&nbsp; It then either continuously retries the download or else leaves you with a corrupted file.<br />
<br />
Solution:&nbsp; Make sure your download script/section is off in its own directory. and add the following to your .htaccess file for that directory:<br />
<br />
php_flag zlib.output_compression off</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="26414""></a>
  <div class="note">
   <strong class="user">claude_minette at hotmail dot com</strong>
   <a href="#26414" class="date">30-Oct-2002 03:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This code works fine with a download manager... maybe not the best solution, but the only one that works with IE!!!!!<br />
<br />
It forces download, but gif file don't want to be downloaded!!! so I need to simply display them in browser...<br />
<br />
NB $file is the result of a query on the file table...<br />
<br />
require_once("auth.inc.php");<br />
$attachment = (strstr($HTTP_USER_AGENT, "MSIE")) ? "" : " attachment"; // IE 5.5 fix.<br />
//Content of file<br />
if (!headers_sent()){<br />
&nbsp;&nbsp; $ficexp=explode('.',$file["orig_name"]);<br />
&nbsp;&nbsp; $ext=$ficexp[sizeof($ficexp)-1];<br />
&nbsp;&nbsp; if ($ext!='gif'){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header('Cache-Control: no-cache, must-revalidate');<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header('Pragma: no-cache');<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header("Content-Type: application/force-download");<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header("Content-Length: ".filesize("files/".$file["save_name"]));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header("Content-Disposition: ".$attachment."; filename=".$file["orig_name"]);<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; $fn=fopen("files/".$file["save_name"], "rb");<br />
&nbsp;&nbsp; fpassthru($fn);<br />
}<br />
else {<br />
&nbsp;&nbsp;&nbsp; MessageBox('Headers already sent, cannot force download!');<br />
}<br />
<br />
Min's</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25801""></a>
  <div class="note">
   <strong class="user">mikek at muonics dot nospam dot c dot o</strong>
   <a href="#25801" class="date">07-Oct-2002 03:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Found a workaround for the MSIE cache bug that puts brackets around dotted items I posted about a while back (e.g. "somefile1.0-xyz.zip" becoming "somefile[1][0]-xyz.zip").<br />
<br />
It turns out if you encode all but the last dot as %2e, then MSIE won't do this.&nbsp; If you encode all of them (including the last dot), then MSIE sticks an extra bracketed number at the end of the file (e.g. "somefile1.0-xyz.zip[1]").&nbsp; Unfortunately, however, some other browsers then want to save the file with the %2e in the filename instead of the dots.<br />
<br />
if (strstr($_SERVER['HTTP_USER_AGENT'], "MSIE"))<br />
{<br />
&nbsp;&nbsp;&nbsp; $fileName = preg_replace('/\./', '%2e', $fileName,<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; substr_count($fileName, '.') - 1);<br />
}<br />
<br />
Viola.&nbsp; Properly named files.&nbsp; This works at least with MSIE 6.0.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25758""></a>
  <div class="note">
   <strong class="user">mikek at muonics dot nospam dot c dot o</strong>
   <a href="#25758" class="date">04-Oct-2002 08:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If your downloaded files are getting corrupted, one of the scripts included/required in your download script or page may have whitespace around the <span class="default">&lt;?php ?&gt;</span> tags.&nbsp; A common enough problem, but most often recognized when header() fails, due to headers already being sent, but one worth mention here.<br />
<br />
This one bit me just recently with my download script.&nbsp; Somewhere along the way adding functionality to my website, I wound up with a space (not a blank line, which I usually spot right away, but a single space character) after the closing ?&gt; tag in one of the require()'d files.&nbsp; Oddly enough, all the downloads seemed to work ok, but the files were corrupted: that space character wound up at the beginning of each file.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25087""></a>
  <div class="note">
   
   <a href="#25087" class="date">10-Sep-2002 05:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that the above comment about the "Connection: close" header is incorrect: it does not guarantee that the connection will be closed immediately after the transfer is complete. Instead, it informs the client that it can no longer use the existing HTTP connection to perform other HTTP requests on the same server, and that the client MUST close the connection as soon as it has finished handling the current request.<br />
<br />
If the client (for example an old HTTP proxy) is using HTTP/1.0, it may not recognize this header, and could could the connection open; the web server should detect this and close the connection and ignore any further request attempt on that connection.<br />
<br />
HTTP/1.1 clients MUST honor this header and close their connection as soon as they detect the end of the answer.<br />
<br />
In any case, the web server will initiate a watchdog after script completion, and will force the deconnection after about 15 to 30 seconds if the client does not honor this header.<br />
<br />
The exact time to wait for the "socket closed by remote" event is configurable in the web server.<br />
<br />
It is generally smaller when the "Connection: close" header has been sent by the server, than when no "Connection:close" has been sent (in which case the connection persists for longer time, to let the client navigate on the server without enduring new connection costs in terms of: connection delays, number of socket control blocks in final wait state, number of used ports).<br />
<br />
Don't abuse "Connection: close" on your server for every hosted page: this creates more incoming TCP connection attempts than necessary, and slows the navigation on your site. Use it only if your script cannot generate explicit content length in the result header, as the client will have difficulties to determine the end of the results.<br />
<br />
If you want to save connection resources to your server, always send an Explicit "Content-Length" header within your script, or use the "chunked" transfer-encoding to explicitly send the result by delimited fragments (if the client is using HTTP/1.1, it MUST support this chunked transfer encoding, per specification). See RFC2616 for details.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25085""></a>
  <div class="note">
   
   <a href="#25085" class="date">10-Sep-2002 04:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
fpassthru() works best for small files. In download manager scripts, it's best to determine the URL of the file to download (you may generate it locally in your session data if you need so), and then use HTTP __temporary__ redirects (302 status code, with a "Location:" header specifying the effective download URL).<br />
<br />
This saves your web server from maintaining PHP scripts running for long times during the file downloadn and instead the download will be managed directly by the web server without scripting support (consequence: less memory resources used by parallel downloads)...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="24843""></a>
  <div class="note">
   <strong class="user">me at gavinadams dot org</strong>
   <a href="#24843" class="date">29-Aug-2002 07:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Interesting results using fpassthru() vs. fread() under UNIX.<br />
<br />
Using fread(fp, length) to read from a valid, open pointer, in which the filename has a special character (single quote, comma, open paren, etc) fails on the read (no debug statements written after that). However, using fpassthru() works like a champ.<br />
<br />
Thanks for the helpful notes on IE session info, have seen this before but didn't know what was causing it.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="24649""></a>
  <div class="note">
   <strong class="user">mikek at muonics dot nospam dot c dot o dot m</strong>
   <a href="#24649" class="date">24-Aug-2002 09:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A few notes on using fpassthru() to php-driven download links that pop up a "Save As.." dialog:<br />
<br />
1. I found that the download progress dialog was remaining up for several seconds after the transfer was completed, before telling the user it was complete.&nbsp; This was fixed by adding the following header:<br />
<br />
header ("Connection: close");<br />
<br />
This will cause the connection to be closed as soon as the transfer is complete, rather than waiting for a timeout.<br />
<br />
2. If you have multiple periods in the filename, you might wind up with a filename with numbers in brackets (such as myfile-[1][0]-windows.zip when you put myfile-1.0-windows.zip in the headers) with MSIE.&nbsp; According to Microsoft's KB, his is a "known" bug having to due with MSIE's cache and there's no workaround that I was able to find.<br />
<br />
3. Through no amount of futzing of headers was I able to get the filename to be set properly when the actual transfer was initiated via a refresh (META or via headers).&nbsp; I don't know if this is also an MSIE only issue or not.&nbsp; If 'download.php?dl=now' (for example) had a refresh back to 'download.php', such that it was intended to show some information (e.g. install instructions) as well as launch the download, then the MSIE insisted that the downloaded file was supposed to be named 'download.php?dl=now' or 'download.php', ignoring the filename in the headers.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="23681""></a>
  <div class="note">
   <strong class="user">-</strong>
   <a href="#23681" class="date">24-Jul-2002 04:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you trying to output a user-written file on a page for verifying, editing, etc, you'll want to use fopen(), fread(), htmlentities() to avoid malicious code. Text from fpassthru, while not parsed per se can still mess up the display of a page (or at least it did for me!) --mt.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="20967""></a>
  <div class="note">
   <strong class="user">josh at trutwins dot homeip dot net</strong>
   <a href="#20967" class="date">23-Apr-2002 05:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I could not get the above examples to work.&nbsp; This is what I used instead:<br />
<br />
header("Content-Disposition: attachment; filename=$file");<br />
header("Content-Description: Image File");<br />
$fd = fopen($file,'r');<br />
fpassthru($fd);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="20474""></a>
  <div class="note">
   <strong class="user">php at brayra dot com</strong>
   <a href="#20474" class="date">04-Apr-2002 12:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is a final working copy that won't freak out Microsoft Explorer if you are using sessions. Thanks to everyone else who came before. This is not as simple as I thought it would be.<br />
<br />
the user would pass a call to the page:<br />
<a href="http://mysite/getfile.php?file=products.pdf" rel="nofollow" target="_blank">http://mysite/getfile.php?file=products.pdf</a><br />
<br />
include 'base.inc'; // inlcude base code, start session&nbsp; and manage users<br />
<br />
// This loads the file global from the post/get variables<br />
// For security reasons register globals is disabled<br />
LoadPostGet('file');<br />
<br />
$filename = '/data/files/' . $file;<br />
if(file_exists($filename)){<br />
&nbsp; $FILECMD = '/usr/bin/file';<br />
&nbsp; $contentType = '';<br />
&nbsp; $fp=popen("$FILECMD -bin $filename", 'r');<br />
&nbsp; if (!$fp) $contentType='application/octet-stream';<br />
&nbsp; else {<br />
&nbsp;&nbsp;&nbsp; while($string=fgets($fp, 1024)) $contentType .= $string;<br />
&nbsp;&nbsp;&nbsp; pclose($fp);<br />
&nbsp; }<br />
&nbsp; if(strpos($HTTP_SERVER_VARS['HTTP_USER_AGENT'], 'MSIE')){<br />
&nbsp;&nbsp;&nbsp; // IE cannot download from sessions without a cache<br />
&nbsp;&nbsp;&nbsp; header('Cache-Control: public');<br />
&nbsp; }<br />
&nbsp; header("Content-type: $contentType");<br />
&nbsp; header("Content-Disposition:inline; filename=\"".$file."\"");<br />
&nbsp; header("Content-length:".(string)(filesize($filename)));<br />
&nbsp; $fd=fopen($filename,'rb');<br />
&nbsp; while(!feof($fd)) {<br />
&nbsp;&nbsp;&nbsp; print fread($fd, 4096);<br />
&nbsp; }<br />
&nbsp; fclose($fd);<br />
}else{<br />
&nbsp; print "File Not Found";<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="18445""></a>
  <div class="note">
   <strong class="user">mirko at mcaserta dot com</strong>
   <a href="#18445" class="date">23-Jan-2002 05:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Update to the above. This also sets the correct mime type for the file you're sending. It's a small hack since it relies on the "file" system command but it should work well.<br />
<br />
&lt;?<br />
// full path to the file command<br />
$FILECMD='/usr/bin/file';<br />
// directory where the file resides<br />
$fileDir='/home/mcaserta';<br />
// full file name<br />
$fileName='test.sh';<br />
<br />
// END CONFIG<br />
<br />
$completeFilePath=$fileDir.'/'.$fileName;<br />
$fp=popen("$FILECMD -bin $completeFilePath", 'r');<br />
<br />
if (! $fp) $contentType='application/octet-stream';<br />
else {<br />
&nbsp; while($string=fgets($fp, 1024)) $contentType .= $string;<br />
&nbsp; pclose($fp);<br />
}<br />
<br />
header('Content-type: '.($contentType));<br />
header('Content-Disposition: inline; filename="'.($fileName).'"');<br />
header('Content-length: '.(string)(filesize($completeFilePath)));<br />
$fd=fopen($completeFilePath,'r');<br />
fpassthru($fd); <br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="18224""></a>
  <div class="note">
   <strong class="user">straz at -removethispart-mac dot com</strong>
   <a href="#18224" class="date">15-Jan-2002 12:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I wrote a page which authenticates the user, then calls fpassthru() to download an Acrobat document. It worked great up to about 1MB, but for larger files, the script was dying in the middle. My ISP told me they were killing my script because it was a memory hog. I tried readfile() instead, to no avail.<br />
<br />
I replaced the fpassthru() with this workaround. It works great:<br />
<br />
&nbsp;while(!feof($fn)) {<br />
&nbsp;&nbsp; $buffer = fread($fn, 4096);<br />
&nbsp;&nbsp; print $buffer;<br />
&nbsp;}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="2100""></a>
  <div class="note">
   <strong class="user">cgriffin at websales dot com</strong>
   <a href="#2100" class="date">30-Oct-1999 04:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you open a new file, write to it and then call fpassthru() it doesn't work. You need to call rewind() first to set the file pointer to the begining of the file.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
