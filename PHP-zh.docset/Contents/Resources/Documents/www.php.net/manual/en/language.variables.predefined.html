<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>预定义变量</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.variables.basics.html">? 基础</a></li>
      <li style="float: right;"><a href="language.variables.scope.html">变量范围 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="language.variables.html">变量</a></li>
    <li>预定义变量</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.variables.predefined" class="sect1">
   <h2 class="title">预定义变量</h2>

   <p class="para">
    PHP 提供了大量的预定义变量。由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。一些预定义变量在
    PHP 以<a href="features.commandline.html" class="link">命令行</a>形式运行时并不生效。
    详细参阅<a href="reserved.variables.html" class="link">预定义变量</a>一章。
   </p>

   <p class="para">
    PHP 提供了一套附加的预定数组，这些数组变量包含了来自 web
    服务器（如果可用），运行环境，和用户输入的数据。这些数组非常特别，它们在全局范围内自动生效，例如，在任何范围内自动生效。因此通常被称为自动全局变量（autoglobals）或者超全局变量（superglobals）。（PHP
    中没有用户自定义超全局变量的机制。）
    详情参阅<a href="language.variables.superglobals.html" class="link">超全局变量列表</a>。
   </p>

   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <strong>可变变量</strong><br />
    <p class="para">
     超级全局变量不能被用作函数或类方法中的<a href="language.variables.variable.html" class="link">可变变量</a>。
    </p>
   </p></blockquote>

   <p class="para">
    如果某些 <a href="ini.core.html#ini.variables-order" class="link">variables_order</a>
    中的变量没有设定，它们的对应的 PHP 预定义数组也是空的。
   </p>

  </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="80794""></a>
  <div class="note">
   <strong class="user">root at mantoru dot de</strong>
   <a href="#80794" class="date">31-Jan-2008 12:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To tokie at hanmail dot net: You took that out of context -- it is merely a recommendation.<br />
<br />
If your variables_order setting does not contain "E", $_ENV is still useful. Every call to getenv will be "cached" in $_ENV, so you can do this:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// variables_order = GPCS<br />
</span><span class="default">var_dump</span><span class="keyword">(isset(</span><span class="default">$_ENV</span><span class="keyword">[</span><span class="string">'PATH'</span><span class="keyword">])); </span><span class="comment">// bool(false)<br />
</span><span class="default">getenv</span><span class="keyword">(</span><span class="string">'PATH'</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(isset(</span><span class="default">$_ENV</span><span class="keyword">[</span><span class="string">'PATH'</span><span class="keyword">])); </span><span class="comment">// bool(true)<br />
</span><span class="default">?&gt;<br />
</span><br />
For some reason, it does not work with with own environment variables. The above example with PHP_TEST instead of PATH would fail (if it is set via putenv).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74620""></a>
  <div class="note">
   <strong class="user">pinkgothic at gmail dot com</strong>
   <a href="#74620" class="date">20-Apr-2007 07:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Dealing with "superglobals" and functions is not as straightforward as it may seem when you're doing plenty manipulations.<br />
<br />
For example:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; </span><span class="keyword">function </span><span class="default">some_other_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">];<br />
&nbsp; }<br />
&nbsp; function </span><span class="default">some_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">] = </span><span class="default">440</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">some_other_method</span><span class="keyword">();<br />
&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Calling some_method() will cause a warning-level error by PHP informing you that "id" is not set in some_other_method(). However, if you instead use:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; $_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">] = </span><span class="default">0</span><span class="keyword">;<br />
&nbsp; function </span><span class="default">some_other_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">];<br />
&nbsp; }<br />
&nbsp; function </span><span class="default">some_method</span><span class="keyword">() {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$_REQUEST</span><span class="keyword">[</span><span class="string">'id'</span><span class="keyword">] = </span><span class="default">440</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">some_other_method</span><span class="keyword">();<br />
&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Then the script will echo 440.<br />
<br />
In consequence, if you manually attempt to add keys to the superglobals, those keys *aren't* automatically superglobal. The above example isn't very sensible, of course, but this can be a huge gotcha if you're juggling user data between functions and you're unwittingly being forced to work inside a function (e.g. via PHP include in TYPO3).<br />
<br />
Unfortunately, global $_REQUEST['id'] won't save you, either - it causes a parse error - nor will a global $_REQUEST change anything after you've set the keys... consequently making it hard to conviniently 'hack' outdated scripts by making them believe they're still running in a different environment.<br />
<br />
The only "solution" to this issue is to use parameters.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72829""></a>
  <div class="note">
   <strong class="user">holger at doessing dot net</strong>
   <a href="#72829" class="date">02-Feb-2007 06:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On the subject of permalinks and queries:<br />
Say, you use an inexpensive subdomain of (e.g.) www.nice.net, thus www.very.nice.net, and that the domain owner has simply placed a frame at this particular location, linking to the actual address (ugly and subject-to-change) of your site.<br />
Consequently, the actual site URI and various associated hashes and query strings are not immediately visible to the user. Sometimes this is useful, but it also makes bookmarking/permalinking impossible (the browser will only bookmark the static address in the top frame).<br />
However, as far as the query strings go, there is workaround. Instead of providing users with permalinks to the actual URI (e.g. prtcl://weird.and.ugly/~very/ugly.php?stuff=here; may even be subject to change), I provide them with this: prtcl://www.very.nice.net?stuff=here.<br />
<br />
In brief, I then use the following code to re-populate the $_GET array:<br />
<br />
if (isset($_SERVER['HTTP_REFERER'])) { // If set, this page is running in a frame<br />
&nbsp;&nbsp;&nbsp; $uri = parse_url($_SERVER['HTTP_REFERER']); // grab URI of parent frame<br />
&nbsp;&nbsp;&nbsp; $querystring = ($uri['query']) ? $uri['query'] : false; // grab the querystring<br />
&nbsp;&nbsp;&nbsp; if ($querystring) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $vars = explode('&amp;', $querystring); // cut into individual statements<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach ($vars as $varstring) { // populate $_GET<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $var = explode('=', $varstring);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (count($var) == 2) $_GET[$var[0]] = $var[1];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; } // no, nothing to report from the parent frame<br />
} // no, not using a parent frame today...<br />
<br />
If the actual host address is ever changed, users entering the frame (with the nicer address) will be using the new (and ugly) URI, but this way the old query strings will be available to the new address also. The users will never again be bothered by you moving to another neighborhood.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="65659""></a>
  <div class="note">
   <strong class="user">I?igo Medina</strong>
   <a href="#65659" class="date">05-May-2006 01:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is true. I usually write variables in this way: $chuckNorrisFilms. So one almost never finds problems.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="64336""></a>
  <div class="note">
   <strong class="user">johnphayes at gmail dot com</strong>
   <a href="#64336" class="date">12-Apr-2006 10:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I haven't found it anywhere else in the manual, so I'll make a note of it here - PHP will automatically replace any dots ('.') in an incoming variable name with underscores ('_'). So if you have dots in your incoming variables, e.g.:<br />
<br />
example.com/page.php?chuck.norris=nevercries<br />
<br />
you can not reference them by the name used in the URI:<br />
//INCORRECT<br />
echo $_GET['chuck.norris'];<br />
<br />
instead you must use:<br />
//CORRECT<br />
echo $_GET['chuck_norris'];</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63312""></a>
  <div class="note">
   <strong class="user">DD32=theonly_DD32[&amp;amp;]yahoo.com.au</strong>
   <a href="#63312" class="date">19-Mar-2006 05:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have this function in my main files, it allows for easier SEO for some pages without having to rely on .htaccess and mod_rewrite for some things.<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">long_to_GET</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * This function converts info.php/a/1/b/2/c?d=4 TO<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * Array ( [d] =&gt; 4 [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; ) <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; **/<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(isset(</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">]) &amp;&amp; </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">] != </span><span class="string">''</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Split it out.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">,</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Remove first empty item<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">unset(</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Loop through and apend it into the $_GET superglobal.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;=</span><span class="default">count</span><span class="keyword">(</span><span class="default">$tmp</span><span class="keyword">);</span><span class="default">$i</span><span class="keyword">+=</span><span class="default">2</span><span class="keyword">){ </span><span class="default">$_GET</span><span class="keyword">[</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]] = </span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">];}<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Its probably not the most efficient, but it does the job rather nicely.<br />
<br />
DD32</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56717""></a>
  <div class="note">
   <strong class="user">Graeme Jefferis</strong>
   <a href="#56717" class="date">13-Sep-2005 04:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I find this sort of thing consistently useful for dealing with superglobals in safety and comfort.<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">foreach (</span><span class="default">$_POST </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$value</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; switch (</span><span class="default">$key</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"submitted_var_1"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"submitted_var_2"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"submitted_var_3"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $</span><span class="default">$key </span><span class="keyword">= </span><span class="default">$value</span><span class="keyword">; break;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"dangerous_var"</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$value </span><span class="keyword">= </span><span class="default">do_something_special_with</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $</span><span class="default">$key </span><span class="keyword">= </span><span class="default">$value</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56289""></a>
  <div class="note">
   <strong class="user">webdesign at benking dot com</strong>
   <a href="#56289" class="date">29-Aug-2005 02:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
# this is a follow-up to kasey at cornerspeed's 14-Jun-2004 08:33 post and debabratak at softhome's 14-Mar-2003 12:59 post, minus sessions but including a safety mechanism to block unwanted variables...<br />
<br />
# if you are like me and do not want to have to type $_POST[some_var] to get to all your passed variable data, you can safely convert all the data to the variable names (so it is like old style php) by using a pre-defined allowed arg names list like this;<br />
<br />
$allowed_args = ',f_name,l_name,subject,msg,';<br />
<br />
foreach(array_keys($_POST) as $k) {<br />
&nbsp;&nbsp;&nbsp; $temp = ",$k,";<br />
&nbsp;&nbsp;&nbsp; if(strpos($allowed_args,$temp) !== false) { $$k = $_POST[$k]; }<br />
}<br />
<br />
# then you can use the programmer friendly (less typing) vars like so;<br />
echo "Hello $f_name";<br />
<br />
# make sure you have commas in front of and after each var name in the $allowed_args list, so strpos will never surprise you by mistakingly finding an unwanted var name within another var name</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52304""></a>
  <div class="note">
   <strong class="user">myfirstname dot barros at gmail dot com</strong>
   <a href="#52304" class="date">27-Apr-2005 07:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
vars in $_REQUEST are *not* a reference to the respective $_POST and $_GET and $_COOKIE ones.<br />
<br />
Consider:<br />
<a href="http://site.com/index.php?avar=abc" rel="nofollow" target="_blank">http://site.com/index.php?avar=abc</a><br />
<br />
index.php:<br />
<span class="default">&lt;?php<br />
$_GET</span><span class="keyword">[</span><span class="string">'avar'</span><span class="keyword">] = </span><span class="string">'b'</span><span class="keyword">;<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$_GET</span><span class="keyword">); print(</span><span class="string">'&lt;br&gt;'</span><span class="keyword">);<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$_REQUEST</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
output:<br />
Array ( [avar] =&gt; 'b' )<br />
Array ( [avar] =&gt; 'abc' )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52283""></a>
  <div class="note">
   <strong class="user">sendoshin[at]noodleroni[dot]com</strong>
   <a href="#52283" class="date">26-Apr-2005 05:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is one way to safely execute PHP code files without running the risk of compromising your own code.&nbsp; A prior note pointed out that the code being evaluated would still have access to globals using the global keyword.&nbsp; While this is a valid point, there's one other approach to be looked at - one which actually gives you much more ability than just unsetting some variable references.&nbsp; It's known as code parsing.<br />
<br />
The specifics would be different and much more complex in a deployed site, but here's an extremely strip-down example of how to restrict access to global variables:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">while (</span><span class="default">$x </span><span class="keyword">= </span><span class="default">stristr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="string">"global"</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$temp </span><span class="keyword">= </span><span class="default">substr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">, </span><span class="default">$x</span><span class="keyword">-</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$temp </span><span class="keyword">.= </span><span class="default">substr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="default">stristr </span><span class="keyword">(</span><span class="default">$code_to_eval</span><span class="keyword">, </span><span class="string">";"</span><span class="keyword">, </span><span class="default">$x</span><span class="keyword">) + </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$code_to_eval </span><span class="keyword">= </span><span class="default">$temp</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ret_val </span><span class="keyword">= eval (</span><span class="default">$code_to_eval</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Of course, that's just a rudimentary example, and a deployment version would have much more checking involved, but parsing the file before you eval it lets you remove any code you don't want to let run, thus making it as safe as your parsing rules.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43228""></a>
  <div class="note">
   <strong class="user">kasey at cornerspeed dowt com</strong>
   <a href="#43228" class="date">14-Jun-2004 05:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have a few points to note to (debabratak at softhome dot net).&nbsp; Firstly, extracting all your variables from the global variable arrays is rather cumbersome and possibly unsafe.&nbsp; This causes longer run times, and wastes more memory.&nbsp; Then, your script is starting the session before it parses the superglobals.&nbsp; Bad things can happen because of this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// user sent a GET header with key = secret_access, val = true, so<br />
<br />
</span><span class="keyword">echo </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: true<br />
</span><span class="keyword">echo </span><span class="default">$secret_access</span><span class="keyword">; </span><span class="comment">// output:<br />
<br />
</span><span class="default">session_start</span><span class="keyword">();<br />
<br />
</span><span class="comment">// in previous logic, you set session variable $secret_access = false<br />
<br />
</span><span class="keyword">echo </span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: false<br />
</span><span class="keyword">echo </span><span class="default">$secret_access</span><span class="keyword">; </span><span class="comment">// output: false<br />
<br />
</span><span class="default">extract_globals</span><span class="keyword">();&nbsp; </span><span class="comment">// Globals put into "normal" variables<br />
<br />
</span><span class="keyword">echo </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: true<br />
</span><span class="keyword">echo </span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"secret_access"</span><span class="keyword">]; </span><span class="comment">// output: false<br />
</span><span class="keyword">echo </span><span class="default">$secret_access</span><span class="keyword">; </span><span class="comment">// output: true<br />
<br />
// VARIABLES ARE COMPROMISED!<br />
// DO NOT USE $secret_access !<br />
// USE $_SESSION["secret_access"] instead !!!<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Secondly, I would like to point out the fact that all $_POST, $_GET, and $_COOKIE variables are intrinsically unsafe anyway.&nbsp; Users can create their own scripts in the language of their choosing (PHP, ASP, JSP, etc.) that generate those headers to send to your PHP program via socket connections.&nbsp; PHP cannot determine that these headers are any less valid than the ones sent by a web browser, so it parses them and places them in the $_POST, $_GET, or $_COOKIE variables.<br />
<br />
The best practice is to use $_SESSION variables to validate the user before making any decisions based on form data.&nbsp; e.g.:<br />
<br />
<span class="default">&lt;?php<br />
session_start</span><span class="keyword">();<br />
if (isset(</span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"valid"</span><span class="keyword">]))<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// all your program decisions and database interactions can go here<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (isset(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"button_name"</span><span class="keyword">]))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; ...<br />
}<br />
elseif (isset(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"submit_login"</span><span class="keyword">]))<br />
{<br />
&nbsp;&nbsp;&nbsp; if ((</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"username"</span><span class="keyword">] == </span><span class="string">"foo"</span><span class="keyword">) AND (</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">"password"</span><span class="keyword">] == </span><span class="string">"bar"</span><span class="keyword">))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$_SESSION</span><span class="keyword">[</span><span class="string">"valid"</span><span class="keyword">] = </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">session_unset</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">session_destroy</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$error_msg </span><span class="keyword">= </span><span class="string">"Invalid username or password"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result_page </span><span class="keyword">= </span><span class="string">"login.php"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
elseif (isset(</span><span class="default">$logoff</span><span class="keyword">))<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_unset</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_destroy</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$success_msg </span><span class="keyword">= </span><span class="string">"You have logged off successfully"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$result_page </span><span class="keyword">= </span><span class="string">"login.php"</span><span class="keyword">;<br />
}<br />
else<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_unset</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">session_destroy</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$result_page </span><span class="keyword">= </span><span class="string">"login.php"</span><span class="keyword">;<br />
}<br />
require (</span><span class="default">$result_page</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Session variables are orders of magnitude harder to compromise than POST, GET, and COOKIE data, since the server keeps track of session id's, and the session id is unique to each client and somewhat randomly generated.&nbsp; If security is an ultimate concern, then you need to use SSL in case your traffic can be sniffed (since the session cookie is passed plain text to the client).<br />
<br />
In summary, extracting out all the superglobals to normal variable names is not a good idea for reasons of security and ambiguity, not to mention wasted CPU cycles.&nbsp; For private applications (ones that you don't want just anyone to be able to access), the only ways you can prevent malicious access is to 1) use sessions to ensure that the user is valid (for that page), and 2) use SSL-encryption to prevent session-hijacking.<br />
<br />
Kasey<br />
<br />
in reply to:<br />
--------------------------------------------------------------<br />
&nbsp;debabratak at softhome dot net<br />
14-Mar-2003 12:59<br />
After having register_globals = off, I am using the following piece of code to get all the variables created for me. I have put this code in a separate file and just make it require_once() on top of every page.<br />
<br />
session_start();<br />
$ArrayList = array("_GET", "_POST", "_SESSION", "_COOKIE", "_SERVER");<br />
foreach($ArrayList as $gblArray)<br />
{<br />
&nbsp;&nbsp; $keys = array_keys($$gblArray);<br />
&nbsp;&nbsp; foreach($keys as $key)<br />
&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; $$key = trim(${$gblArray}[$key]);<br />
&nbsp;&nbsp; }<br />
}<br />
<br />
This pulls out all the possible variables for me, including the predefined variables, so I can keep coding the old style. Note that, this code does not handle the $_FILE.<br />
<br />
Hope this helps someone.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42270""></a>
  <div class="note">
   <strong class="user">bryan at nolifeline dot com</strong>
   <a href="#42270" class="date">10-May-2004 12:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
to marcbender at mail dot com<br />
<br />
unset the globals<br />
<br />
use a preg_replace ( pattern: |\;[^\;]*$i[^\;]*\;|Uis, replacement: ";", where $i is the name of any function/variable you wish to prevent access to.) on the code-to-be-evaled.&nbsp; ideas are "global", "fopen", "mysql_connect", etc.&nbsp; You know, anything that you wouldn't want to give a hyperactive 13 year old access to.<br />
<br />
execute the code.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="41656""></a>
  <div class="note">
   <strong class="user">marcbender_AT_mail_DOT_com</strong>
   <a href="#41656" class="date">18-Apr-2004 02:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
-Security issue-<br />
<br />
In response to lopez at yellowspace,<br />
<br />
You provided a method for executing potentially unsafe code:<br />
<br />
&gt; function safeEval($evalcode) {<br />
&gt;&nbsp; &nbsp; unset($GLOBALS);<br />
&gt;&nbsp; &nbsp; unset($_ENV);<br />
&gt;&nbsp; &nbsp; // unset any other superglobal...<br />
&gt;&nbsp; &nbsp; return eval($evalcode);<br />
&gt; }<br />
<br />
Your method, though clever, won't work.&nbsp; The problem is the way that PHP handles function scope.&nbsp; If $evalcode contains a function declaration, and runs that function, the "unset"s will be effectively useless inside the body of that function.<br />
<br />
Try running the above code with $evalcode set as follows:<br />
<br />
<span class="default">&lt;?php<br />
$evalcode</span><span class="keyword">=</span><span class="string">'f();<br />
function f() {<br />
&nbsp;&nbsp; $GLOBALS["_SERVER"] = "compromised";<br />
}'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Then print $_SERVER and see what you get.<br />
<br />
Another problem is that the "global" directive will always grant access to global variables.&nbsp; Try this one:<br />
<br />
<span class="default">&lt;?php<br />
$evalcode</span><span class="keyword">=</span><span class="string">'global $a;<br />
$a = "compromised";'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
$a will of course be changed at the global level.&nbsp; I don't know if it's supposed to work this way, but on my system (PHP 4.3.4) you can do the same to any superglobal by importing it using "global".<br />
<br />
As far as I can tell, there is NO way to execute potentially unsafe code without a lot of risk.&nbsp; With the sloppy way that PHP deals with function scope etc., there isn't much hope that it ever will be.&nbsp; What we'd need is (at least):<br />
&nbsp; - a way to disable the "global" directive (restrictive eval).<br />
&nbsp; - a way to shut off any write-access to superglobals within untrusted functions.<br />
<br />
The first wouldn't be too hard to implement.&nbsp; The second, on the other hand, is practically impossible IMHO.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="35627""></a>
  <div class="note">
   <strong class="user">joker at vip dot hr</strong>
   <a href="#35627" class="date">08-Sep-2003 07:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If anyone of you have a problem with uploading files with globals off here is the solution... just add this to the top of the code:<br />
<br />
reset ($_FILES);<br />
while (list ($key, $val) = each ($_FILES)) {<br />
&nbsp;&nbsp;&nbsp; ${$key}=$_FILES[$key]['tmp_name'];<br />
&nbsp;&nbsp;&nbsp; while (list ($key1, $val1) = each ($val)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ${$key."_".$key1}=$_FILES[$key][$key1];<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
&nbsp;&nbsp; Daniel</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31724""></a>
  <div class="note">
   
   <a href="#31724" class="date">01-May-2003 09:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reply to destes at ix dot netcom dot com dot nospam:<br />
<br />
It's possible for a HTTP client to spoof HTTP_X_FORWARDED_FOR, and set it to a fake IP number.&nbsp; It's more secure to use this code and log BOTH the ip and the proxy ip.<br />
<br />
if ($_SERVER["HTTP_X_FORWARDED_FOR"]) {<br />
&nbsp;&nbsp; if ($_SERVER["HTTP_CLIENT_IP"]) {<br />
&nbsp;&nbsp;&nbsp; $proxy = $_SERVER["HTTP_CLIENT_IP"];<br />
&nbsp; } else {<br />
&nbsp;&nbsp;&nbsp; $proxy = $_SERVER["REMOTE_ADDR"];<br />
&nbsp; }<br />
&nbsp; $ip = $_SERVER["HTTP_X_FORWARDED_FOR"];<br />
} else {<br />
&nbsp; if ($_SERVER["HTTP_CLIENT_IP"]) {<br />
&nbsp;&nbsp;&nbsp; $ip = $_SERVER["HTTP_CLIENT_IP"];<br />
&nbsp; } else {<br />
&nbsp;&nbsp;&nbsp; $ip = $_SERVER["REMOTE_ADDR"];<br />
&nbsp; }<br />
}<br />
<br />
echo "Your IP $ip&lt;BR&gt;\n";<br />
if (isset($proxy)) {<br />
&nbsp; echo "Your proxy IP is $proxy&lt;BR&gt;\n";<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30678""></a>
  <div class="note">
   <strong class="user">LouisGreen at pljg dot freeserve dot co dot uk</strong>
   <a href="#30678" class="date">25-Mar-2003 10:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems that when you wish to export a varible, you can do it as return $varible, return an array(), or globalise it. If you return something, information for that varible can only travel one way when the script is running, and that is out of the function. <br />
<br />
function fn() {<br />
&nbsp;&nbsp; $varible = "something";<br />
<br />
&nbsp; return $variable;<br />
}<br />
<br />
echo fn();<br />
OR<br />
$newvariable = fn();<br />
<br />
Although if global was used, it creates a pointer to a varible, whether it existed or not, and makes whatever is created in the function linked to that global pointer. So if the pointer was global $varible, and then you set a value to $varible, it would then be accessible in the global scope. But then what if you later on in the script redefine that global to equal something else. This means that whatever is put into the global array, the information that is set in the pointer, can be set at any point (overiden). Here is an example that might make this a little clearer:<br />
<br />
function fn1() {<br />
<br />
&nbsp;&nbsp; global $varible; // Pointer to the global array<br />
&nbsp;&nbsp; $varible = "something";<br />
}<br />
<br />
fn1();<br />
echo $varible; // Prints something<br />
$varible = "12345";<br />
echo $varible; // Prints 12345<br />
<br />
function fn2() {<br />
<br />
&nbsp;&nbsp; global $varible; // Pointer to the global array<br />
&nbsp;&nbsp; echo $varible;<br />
}<br />
<br />
fn2(); // echos $varible which contains "12345"<br />
<br />
Basically when accessing the global array, you can set it refer to something already defined or set it to something, (a pointer) such as varible you plan to create in the function, and later possibly over ride the pointer with something else.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30484""></a>
  <div class="note">
   <strong class="user">Good Liam</strong>
   <a href="#30484" class="date">19-Mar-2003 09:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Warning:<br />
If you use dynamic variables in a local scope, the variable doesn't "know" when it should be a superglobal.&nbsp; An example will help elucidate this:<br />
<br />
function Example($Variable_Name='_POST') {<br />
&nbsp;&nbsp;&nbsp; print_r($$Variable_Name);<br />
} // End Example<br />
<br />
This would print out<br />
<br />
NULL<br />
<br />
To use a dynamic variable to reference a superglobal, you have to declare the value (not the name) as a global:<br />
<br />
function WorkingExample($Variable_Name='_POST') {<br />
&nbsp;&nbsp;&nbsp; global $$Variable_Name;<br />
&nbsp;&nbsp;&nbsp; print_r($$Variable_Name);<br />
} // End WorkingExample()<br />
<br />
This would print out the contents of your $_POST variable.<br />
<br />
This threw me when I first tried it, but it makes sense, in a way.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="28614""></a>
  <div class="note">
   <strong class="user">lopez dot on dot the dot lists at yellowspace dot net</strong>
   <a href="#28614" class="date">17-Jan-2003 06:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
- Security Issue and workaround - <br />
If You use "eval()" to execute code stored in a database or elsewhere, you might find this tip useful.<br />
<br />
Issue:<br />
By default, all superglobals are known in every function. <br />
Thus, if you eval database- or dynamically generated code (let's call it "potentially unsafe code"), it can use _all_ the values stored in _any_ superglobal. <br />
<br />
Workaround:<br />
Whenever you want to hide superglobals from use in evaluated code, wrap that eval() in an own function within which you unset() all the superglobals. The superglobals are not deleted by php in all scopes - just within that function. eg:<br />
<br />
function safeEval($evalcode) {<br />
&nbsp;&nbsp;&nbsp; unset($GLOBALS);<br />
&nbsp;&nbsp;&nbsp; unset($_ENV);<br />
&nbsp;&nbsp;&nbsp; // unset any other superglobal...<br />
&nbsp;&nbsp;&nbsp; return eval($evalcode);<br />
}<br />
<br />
(This example assumes that the eval returns something with 'return')<br />
<br />
In addition, by defining such a function outside classes, in the global scope, you'll make sure as well that the evaluated ('unsafe') code doesn't have access to the object variables ($this-&gt; ...).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="23063""></a>
  <div class="note">
   
   <a href="#23063" class="date">08-Jul-2002 01:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Wouldn't it be great if there was a variable called $_SERVER["PATH_USERHOME"]. Here is how to set it yourself:<br />
<br />
$path_fs = split ("/", ltrim ($_SERVER["PATH_TRANSLATED"], "/"));<br />
$path_fs_rev = array_reverse ($path_fs);<br />
<br />
$path_http = split ("/", ltrim ($_SERVER["PHP_SELF"], "/"));<br />
$path_http_rev = array_reverse ($path_http);<br />
<br />
$num_same = 0;<br />
while ($path_fs_rev[$num_same] == $path_http_rev[$num_same]) {<br />
&nbsp;&nbsp;&nbsp; $num_same++;<br />
}<br />
<br />
$path_userhome = array ();<br />
$numdirs_userhome = sizeof ($path_http) - $num_same;<br />
echo $numdirs_userhome;<br />
<br />
for ($i = 0; $i &lt; $numdirs_userhome; $i++) {<br />
&nbsp;&nbsp;&nbsp; array_push ($path_userhome, $path_http[$i]);<br />
}<br />
<br />
$_SERVER["PATH_USERHOME"] = "/" . implode ("/", $path_userhome) . "/";<br />
<br />
print_r ($_SERVER["PATH_USERHOME"]);<br />
<br />
;) Happy programming,<br />
<br />
Peder</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="9776""></a>
  <div class="note">
   <strong class="user">mike at dbeat dot com</strong>
   <a href="#9776" class="date">22-Nov-2000 06:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you're running PHP as a shell script, and you want to use the argv and argc arrays to get command-line arguments, make sure you have register_argc_argv&nbsp; =&nbsp; on.&nbsp; If you're using the 'optimized' php.ini, this defaults to off.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
